"use strict";(self.webpackChunkneo_mjs=self.webpackChunkneo_mjs||[]).push([[612],{612:(e,s,t)=>{t.r(s),t.d(s,{default:()=>l});var n=t(375);class c extends n.Z{static config={className:"Neo.util.Function"};static bindAppend(e){const s=this,t=[].slice.call(arguments).slice(1);return function(){return s.apply(e,[].slice.call(arguments).concat(t))}}static createInterceptor(e,s,t,n){let c=e[s];return e[s]=function(s){return c.call(e,t.call(n||e,s))}}static createSequence(e,s,t,n){let c=e[s]||Neo.emptyFn;return e[s]=function(){return c.apply(this,arguments),t.apply(n||this,arguments)}}static intercept(e,s,t,n,c=null){let o=e[s];return e[s]=function(){return!1===t.apply(n||e,arguments)?c:o.apply(e,arguments)}}}Neo.applyClassConfig(c);const o=c;t(544);class a extends n.Z{channel=null;maxReconnectAttempts=5;messageCallbacks={};messageId=1;reconnectAttempts=0;serverAddress=null;static observable=!0;static config={className:"Neo.data.connection.WebSocket",ntype:"socket-connection",socket_:null};construct(e){super.construct(e),this.createSocket()}attemptReconnect(e,s){let t=this;t.reconnectAttempts++,t.reconnectAttempts<t.maxReconnectAttempts&&(t.createSocket(),e&&t.on("open",{callback:e,scope:s||t,single:!0}))}beforeSend(e){let s=this.channel;return console.log("WS: Sending message",s?"\nChannel: "+s:"","\nData:",e),JSON.stringify(s?{channel:s,data:e}:e)}beforeSetSocket(e,s){if(e){let s=this;Object.assign(e,{onclose:s.onClose.bind(s),onerror:s.onError.bind(s),onmessage:s.onMessage.bind(s),onopen:s.onOpen.bind(s)}),o.createInterceptor(e,"send",s.beforeSend,s)}return e}close(e,s){this.socket.close(e,s)}createSocket(){this.socket=new WebSocket(this.serverAddress)}destroy(...e){this.close(),super.destroy(...e)}onClose(e,s,t){console.log("onClose",e,s,t)}onError(){console.log("onError",arguments)}onMessage(e){let s=JSON.parse(e.data);console.log("onMessage",s),s.mId&&(this.messageCallbacks[s.mId].resolve(s.data),delete this.messageCallbacks[s.mId])}onOpen(){this.fire("open",{scope:this})}promiseMessage(e){let s=this;return new Promise(((t,n)=>{s.messageCallbacks[s.messageId]={reject:n,resolve:t},s.sendMessage({data:e,mId:s.messageId}),s.messageId++}))}sendMessage(e){let s=this,t=s.socket,n=e;switch(t.readyState){case WebSocket.CLOSED:case WebSocket.CLOSING:s.attemptReconnect((function(){s.sendMessage(n)}));break;case WebSocket.CONNECTING:s.on("open",(function(){s.sendMessage(n)}),s,{single:!0});break;case WebSocket.OPEN:t.send(e)}}}Neo.applyClassConfig(a);const l=a}}]);