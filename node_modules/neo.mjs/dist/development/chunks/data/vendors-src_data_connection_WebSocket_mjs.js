"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_data_connection_WebSocket_mjs"],{

/***/ "./src/data/connection/WebSocket.mjs":
/*!*******************************************!*\
  !*** ./src/data/connection/WebSocket.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         */
        socket_: null
    }

    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     * @protected
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket();
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            me.createSocket();

            callback && me.on('open', {
                callback,
                scope : scope || me,
                single: true
            });
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me      = this,
            channel = me.channel;

        console.log('WS: Sending message', (channel ? '\nChannel: ' + channel : ''), '\nData:', data);

        return JSON.stringify(channel ? {channel, data} : data);
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createInterceptor(value, 'send', me.beforeSend, me);
        }

        return value;
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason);
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress);
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args);
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        console.log('onClose', event, reason, wasClean);
    }

    /**
     *
     */
    onError() {
        console.log('onError', arguments);
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        console.log('onMessage', data);

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId];
        }
    }

    /**
     *
     */
    onOpen() {
        this.fire('open', {scope: this});
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++;
        });
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me     = this,
            socket = me.socket,
            d      = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d);
                }, me, {single: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

Neo.applyClassConfig(Socket);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Socket);


/***/ }),

/***/ "./src/util/Function.mjs":
/*!*******************************!*\
  !*** ./src/util/Function.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Function
 * @extends Neo.core.Base
 */
class NeoFunction extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Function'
         * @protected
         */
        className: 'Neo.util.Function'
    }

    /**
     * Append args instead of prepending them
     * @param {Object} scope
     * @returns {Function}
     */
    static bindAppend(scope) {
        const fn   = this,
              args = [].slice.call(arguments).slice(1);

        return function() {
            return fn.apply(scope, [].slice.call(arguments).concat(args));
        }
    }

    /**
     * Intended for functions with 1 param where the interceptor can change the value
     * @param {Object} target
     * @param {String} targetMethodName
     * @param {Function} interceptFunction
     * @param {Object} scope=target
     * @returns {Function}
     */
    static createInterceptor(target, targetMethodName, interceptFunction, scope) {
        let targetMethod = target[targetMethodName];

        return (target[targetMethodName] = function(value) {
            return targetMethod.call(target, interceptFunction.call(scope || target, value));
        });
    }

    /**
     * @param {Neo.core.Base} target
     * @param {String} methodName
     * @param {Function} fn
     * @param {Object} scope
     * @returns {Function}
     */
    static createSequence(target, methodName, fn, scope) {
        let method = target[methodName] || Neo.emptyFn;

        return (target[methodName] = function() {
            method.apply(this, arguments);
            return fn.apply(scope || this, arguments);
        });
    }

    /**
     * The interceptor can prevent the targetMethod from getting executed in case it returns false.
     * @param {Object} target
     * @param {String} targetMethodName
     * @param {Function} interceptFunction
     * @param {Object} scope=target
     * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
     * @returns {Function}
     */
    static intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
        let targetMethod = target[targetMethodName];

        return (target[targetMethodName] = function() {
            return (interceptFunction.apply(scope || target, arguments) === false)
                ? preventedReturnValue
                : targetMethod.apply(target, arguments);
        });
    }
}

Neo.applyClassConfig(NeoFunction);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NeoFunction);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2RhdGEvdmVuZG9ycy1zcmNfZGF0YV9jb25uZWN0aW9uX1dlYlNvY2tldF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNJO0FBQ0U7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixZQUFZLDRFQUE2QjtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpELDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyxhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLE1BQU0sRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQy9QYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQUk7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxXQUFXLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvY29ubmVjdGlvbi9XZWJTb2NrZXQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9GdW5jdGlvbi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0Z1bmN0aW9uIGZyb20gJy4uLy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICBmcm9tICcuLi8uLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NvY2tldC1jb25uZWN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NvY2tldC1jb25uZWN0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1dlYlNvY2tldHxudWxsfSBzb2NrZXRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc29ja2V0XzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjaGFubmVsPW51bGxcbiAgICAgKi9cbiAgICBjaGFubmVsID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4UmVjb25uZWN0QXR0ZW1wdHM9NVxuICAgICAqL1xuICAgIG1heFJlY29ubmVjdEF0dGVtcHRzID0gNVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVzc2FnZUNhbGxiYWNrcz17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXNzYWdlQ2FsbGJhY2tzID0ge31cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1lc3NhZ2VJZD0xXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lc3NhZ2VJZCA9IDFcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJlY29ubmVjdEF0dGVtcHRzPTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVjb25uZWN0QXR0ZW1wdHMgPSAwXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNlcnZlckFkZHJlc3M9bnVsbFxuICAgICAqL1xuICAgIHNlcnZlckFkZHJlc3MgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTb2NrZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgICAqL1xuICAgIGF0dGVtcHRSZWNvbm5lY3QoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUucmVjb25uZWN0QXR0ZW1wdHMrKztcblxuICAgICAgICBpZiAobWUucmVjb25uZWN0QXR0ZW1wdHMgPCBtZS5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgbWUuY3JlYXRlU29ja2V0KCk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrICYmIG1lLm9uKCdvcGVuJywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogc2NvcGUgfHwgbWUsXG4gICAgICAgICAgICAgICAgc2luZ2xlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVyY2VwdHMgdGhlIFdlYlNvY2tldCBzZW5kIGNhbGxzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNlbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjaGFubmVsID0gbWUuY2hhbm5lbDtcblxuICAgICAgICBjb25zb2xlLmxvZygnV1M6IFNlbmRpbmcgbWVzc2FnZScsIChjaGFubmVsID8gJ1xcbkNoYW5uZWw6ICcgKyBjaGFubmVsIDogJycpLCAnXFxuRGF0YTonLCBkYXRhKTtcblxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2hhbm5lbCA/IHtjaGFubmVsLCBkYXRhfSA6IGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNvY2tldCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7V2ViU29ja2V0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtXZWJTb2NrZXR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7V2ViU29ja2V0fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNvY2tldCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgb25jbG9zZSAgOiBtZS5vbkNsb3NlICAuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25lcnJvciAgOiBtZS5vbkVycm9yICAuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25tZXNzYWdlOiBtZS5vbk1lc3NhZ2UuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25vcGVuICAgOiBtZS5vbk9wZW4gICAuYmluZChtZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW9GdW5jdGlvbi5jcmVhdGVJbnRlcmNlcHRvcih2YWx1ZSwgJ3NlbmQnLCBtZS5iZWZvcmVTZW5kLCBtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBkZWZhdWx0cyB0byAxMDAwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtyZWFzb25dXG4gICAgICovXG4gICAgY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVTb2NrZXQoKSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLnNlcnZlckFkZHJlc3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb3NlRXZlbnR9IGV2ZW50IFRoZSBXZWJzb2NrZXQgZ2VuZXJhdGVkIENsb3NlRXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgIGV2ZW50LmNvZGUgVGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlIGNvZGUgcHJvdmlkZWQgYnkgdGhlIHNlcnZlclxuICAgICAqXG4gICAgICogICAgICAgIENvZGUgICAgICAgIE5hbWUgICAgICAgICAgICAgICAgICBEZXNjcmlwdGlvblxuICAgICAqICAgICAgICAwLTk5OSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgYW5kIG5vdCB1c2VkLlxuICAgICAqICAgICAgICAxMDAwICAgICAgICBDTE9TRV9OT1JNQUwgICAgICAgICAgTm9ybWFsIGNsb3N1cmU7IHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgd2hhdGV2ZXIgcHVycG9zZSBmb3Igd2hpY2ggaXQgd2FzIGNyZWF0ZWQuXG4gICAgICogICAgICAgIDEwMDEgICAgICAgIENMT1NFX0dPSU5HX0FXQVkgICAgICBUaGUgZW5kcG9pbnQgaXMgZ29pbmcgYXdheSwgZWl0aGVyIGJlY2F1c2Ugb2YgYSBzZXJ2ZXIgZmFpbHVyZSBvciBiZWNhdXNlIHRoZSBicm93c2VyIGlzIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlIHRoYXQgb3BlbmVkIHRoZSBjb25uZWN0aW9uLlxuICAgICAqICAgICAgICAxMDAyICAgICAgICBDTE9TRV9QUk9UT0NPTF9FUlJPUiAgVGhlIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGR1ZSB0byBhIHByb3RvY29sIGVycm9yLlxuICAgICAqICAgICAgICAxMDAzICAgICAgICBDTE9TRV9VTlNVUFBPUlRFRCAgICAgVGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgdGVybWluYXRlZCBiZWNhdXNlIHRoZSBlbmRwb2ludCByZWNlaXZlZCBkYXRhIG9mIGEgdHlwZSBpdCBjYW5ub3QgYWNjZXB0IChmb3IgZXhhbXBsZSwgYSB0ZXh0LW9ubHkgZW5kcG9pbnQgcmVjZWl2ZWQgYmluYXJ5IGRhdGEpLlxuICAgICAqICAgICAgICAxMDA0ICAgICAgICBDTE9TRV9UT09fTEFSR0UgICAgICAgVGhlIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgYSBkYXRhIGZyYW1lIHdhcyByZWNlaXZlZCB0aGF0IGlzIHRvbyBsYXJnZS5cbiAgICAgKiAgICAgICAgMTAwNSAgICAgICAgQ0xPU0VfTk9fU1RBVFVTICAgICAgIFJlc2VydmVkLiAgSW5kaWNhdGVzIHRoYXQgbm8gc3RhdHVzIGNvZGUgd2FzIHByb3ZpZGVkIGV2ZW4gdGhvdWdoIG9uZSB3YXMgZXhwZWN0ZWQuXG4gICAgICogICAgICAgIDEwMDYgICAgICAgIENMT1NFX0FCTk9STUFMICAgICAgICBSZXNlcnZlZC4gVXNlZCB0byBpbmRpY2F0ZSB0aGF0IGEgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFibm9ybWFsbHkgKHRoYXQgaXMsIHdpdGggbm8gY2xvc2UgZnJhbWUgYmVpbmcgc2VudCkgd2hlbiBhIHN0YXR1cyBjb2RlIGlzIGV4cGVjdGVkLlxuICAgICAqICAgICAgICAxMDA3LTE5OTkgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgYnkgdGhlIFdlYlNvY2tldCBzdGFuZGFyZC5cbiAgICAgKiAgICAgICAgMjAwMC0yOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2VydmVkIGZvciB1c2UgYnkgV2ViU29ja2V0IGV4dGVuc2lvbnMuXG4gICAgICogICAgICAgIDMwMDAtMzk5OSAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgZm9yIHVzZSBieSBsaWJyYXJpZXMgYW5kIGZyYW1ld29ya3MuIE1heSBub3QgYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMuXG4gICAgICogICAgICAgIDQwMDAtNDk5OSAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgZm9yIHVzZSBieSBhcHBsaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgIHJlYXNvbiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSByZWFzb24gdGhlIHNlcnZlciBjbG9zZWQgdGhlIGNvbm5lY3Rpb24uIFRoaXMgaXMgc3BlY2lmaWMgdG8gdGhlIHBhcnRpY3VsYXIgc2VydmVyIGFuZCBzdWItcHJvdG9jb2wuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICB3YXNDbGVhbiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkLlxuICAgICAqL1xuICAgIG9uQ2xvc2UoZXZlbnQsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uQ2xvc2UnLCBldmVudCwgcmVhc29uLCB3YXNDbGVhbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkVycm9yKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb25FcnJvcicsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdvbk1lc3NhZ2UnLCBkYXRhKTtcblxuICAgICAgICBpZiAoZGF0YS5tSWQpIHtcbiAgICAgICAgICAgIG1lLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tSWRdLnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5tZXNzYWdlQ2FsbGJhY2tzW2RhdGEubUlkXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ29wZW4nLCB7c2NvcGU6IHRoaXN9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZU1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZS5tZXNzYWdlQ2FsbGJhY2tzW21lLm1lc3NhZ2VJZF0gPSB7cmVqZWN0LCByZXNvbHZlfTtcblxuICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2Uoe2RhdGEsIG1JZDogbWUubWVzc2FnZUlkfSk7XG4gICAgICAgICAgICBtZS5tZXNzYWdlSWQrKztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc29ja2V0ID0gbWUuc29ja2V0LFxuICAgICAgICAgICAgZCAgICAgID0gZGF0YTtcblxuICAgICAgICAvLyBDT05ORUNUSU5HICAwICAgVGhlIGNvbm5lY3Rpb24gaXMgbm90IHlldCBvcGVuLlxuICAgICAgICAvLyBPUEVOICAgICAgICAxICAgVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBhbmQgcmVhZHkgdG8gY29tbXVuaWNhdGUuXG4gICAgICAgIC8vIENMT1NJTkcgICAgIDIgICBUaGUgY29ubmVjdGlvbiBpcyBpbiB0aGUgcHJvY2VzcyBvZiBjbG9zaW5nLlxuICAgICAgICAvLyBDTE9TRUQgICAgICAzICAgVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkIG9yIGNvdWxkbid0IGJlIG9wZW5lZC5cblxuICAgICAgICAvLyBJZiBzb2NrZXQgaXMgbm90IHlldCByZWFkeSBsZXQncyBkZWZlciB0byBvcGVuIHRoZW4gcmVzZW5kXG4gICAgICAgIHN3aXRjaCAoc29ja2V0LnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NFRDpcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NJTkc6XG4gICAgICAgICAgICAgICAgbWUuYXR0ZW1wdFJlY29ubmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UoZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DT05ORUNUSU5HOlxuICAgICAgICAgICAgICAgIG1lLm9uKCdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKGQpO1xuICAgICAgICAgICAgICAgIH0sIG1lLCB7c2luZ2xlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5PUEVOOlxuICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhTb2NrZXQpO1xuXG5leHBvcnQgZGVmYXVsdCBTb2NrZXQ7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuRnVuY3Rpb25cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgTmVvRnVuY3Rpb24gZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkZ1bmN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5GdW5jdGlvbidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYXJncyBpbnN0ZWFkIG9mIHByZXBlbmRpbmcgdGhlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZEFwcGVuZChzY29wZSkge1xuICAgICAgICBjb25zdCBmbiAgID0gdGhpcyxcbiAgICAgICAgICAgICAgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZW5kZWQgZm9yIGZ1bmN0aW9ucyB3aXRoIDEgcGFyYW0gd2hlcmUgdGhlIGludGVyY2VwdG9yIGNhbiBjaGFuZ2UgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRNZXRob2ROYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0RnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGFyZ2V0XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnRlcmNlcHRvcih0YXJnZXQsIHRhcmdldE1ldGhvZE5hbWUsIGludGVyY2VwdEZ1bmN0aW9uLCBzY29wZSkge1xuICAgICAgICBsZXQgdGFyZ2V0TWV0aG9kID0gdGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdO1xuXG4gICAgICAgIHJldHVybiAodGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRNZXRob2QuY2FsbCh0YXJnZXQsIGludGVyY2VwdEZ1bmN0aW9uLmNhbGwoc2NvcGUgfHwgdGFyZ2V0LCB2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNlcXVlbmNlKHRhcmdldCwgbWV0aG9kTmFtZSwgZm4sIHNjb3BlKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSB0YXJnZXRbbWV0aG9kTmFtZV0gfHwgTmVvLmVtcHR5Rm47XG5cbiAgICAgICAgcmV0dXJuICh0YXJnZXRbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcmNlcHRvciBjYW4gcHJldmVudCB0aGUgdGFyZ2V0TWV0aG9kIGZyb20gZ2V0dGluZyBleGVjdXRlZCBpbiBjYXNlIGl0IHJldHVybnMgZmFsc2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRNZXRob2ROYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0RnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBwcmV2ZW50ZWRSZXR1cm5WYWx1ZT1udWxsIFRoZSB2YWx1ZSB0byByZXR1cm4gaW4gY2FzZSB0aGUgaW50ZXJjZXB0RnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJjZXB0KHRhcmdldCwgdGFyZ2V0TWV0aG9kTmFtZSwgaW50ZXJjZXB0RnVuY3Rpb24sIHNjb3BlLCBwcmV2ZW50ZWRSZXR1cm5WYWx1ZT1udWxsKSB7XG4gICAgICAgIGxldCB0YXJnZXRNZXRob2QgPSB0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV07XG5cbiAgICAgICAgcmV0dXJuICh0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoaW50ZXJjZXB0RnVuY3Rpb24uYXBwbHkoc2NvcGUgfHwgdGFyZ2V0LCBhcmd1bWVudHMpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICA/IHByZXZlbnRlZFJldHVyblZhbHVlXG4gICAgICAgICAgICAgICAgOiB0YXJnZXRNZXRob2QuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE5lb0Z1bmN0aW9uKTtcblxuZXhwb3J0IGRlZmF1bHQgTmVvRnVuY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=