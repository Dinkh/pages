"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_calendar_basic_app_mjs"],{

/***/ "./examples/calendar/basic/MainContainer.mjs":
/*!***************************************************!*\
  !*** ./examples/calendar/basic/MainContainer.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/calendar/view/MainContainer.mjs */ "./src/calendar/view/MainContainer.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./examples/calendar/basic/MainContainerController.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");






/**
 * @class Neo.examples.calendar.basic.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        className : 'Neo.examples.calendar.basic.MainContainer',
        autoMount : true,
        cls       : ['neo-examples-calendar-maincontainer', 'neo-viewport'],
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        layout    : {ntype: 'vbox', align: 'stretch'},

        items: [{
            module : _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex   : 'none',
            padding: 20,
            reference: 'headerToolbar',

            style: {
                backgroundColor: '#f2f2f2',
                padding        : '10px 5px 10px 10px'
            },

            items: [{
                ntype: 'component',
                cls  : ['neo-header'],
                html : '<i class="fa fa-calendar"></i>neo.mjs Calendar'
            }, '->', {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'onSwitchThemeButtonClick',
                height : 27,
                iconCls: 'fa fa-moon',
                text   : 'Theme Dark'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                height : 27,
                iconCls: 'fab fa-github',
                style  : {marginLeft: '5px'},
                text   : 'GitHub',
                url    : 'https://github.com/neomjs/neo/tree/dev/src/calendar'
            }]
        }, {
            module   : _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 1,
            reference: 'calendar',

            calendarStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/calendars.json'
            },

            eventStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/events.json'
            },

            modelData: {
                currentDate: new Date('2021-07-20')
            }
        }]
    }
}

Neo.applyClassConfig(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./examples/calendar/basic/MainContainerController.mjs":
/*!*************************************************************!*\
  !*** ./examples/calendar/basic/MainContainerController.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.examples.calendar.basic.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.calendar.basic.MainContainerController'
         * @protected
         */
        className: 'Neo.examples.calendar.basic.MainContainerController'
    }

    /**
     * @param {Object} data
     */
    onSwitchThemeButtonClick(data) {
        let me            = this,
            button        = data.component,
            component     = me.component,
            headerToolbar = me.getReference('headerToolbar'),
            buttonText, cls, headerColor, iconCls, style, theme;

        if (button.text === 'Theme Light') {
            buttonText  = 'Theme Dark';
            headerColor = '#f2f2f2';
            iconCls     = 'fa fa-moon';
            theme       = 'neo-theme-light';
        } else {
            buttonText  = 'Theme Light';
            headerColor = '#33343d';
            iconCls     = 'fa fa-sun';
            theme       = 'neo-theme-dark';
        }

        cls = [...component.cls];

        component.cls.forEach(item => {
            if (item.includes('neo-theme')) {
                _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, item);
            }
        });

        _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, theme);
        component.cls = cls;

        button.set({
            iconCls,
            text: buttonText
        });

        style = headerToolbar.style || {};
        style.backgroundColor = headerColor;
        headerToolbar.style = style;
    }
}

Neo.applyClassConfig(MainContainerController);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainerController);


/***/ }),

/***/ "./examples/calendar/basic/app.mjs":
/*!*****************************************!*\
  !*** ./examples/calendar/basic/app.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onStart": () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/calendar/basic/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.calendar.basic'
});


/***/ }),

/***/ "./src/calendar/view/EditEventContainer.mjs":
/*!**************************************************!*\
  !*** ./src/calendar/view/EditEventContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/Calendars.mjs */ "./src/calendar/store/Calendars.mjs");
/* harmony import */ var _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../form/field/Time.mjs */ "./src/form/field/Time.mjs");








/**
 * @class Neo.calendar.view.EditEventContainer
 * @extends Neo.form.Container
 */
class EditEventContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.EditEventContainer'
         * @protected
         */
        className: 'Neo.calendar.view.EditEventContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-event-container']
         */
        baseCls: ['neo-calendar-edit-event-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            endTime             : data => data.endTime,
            intlFormat_time     : data => data.intlFormat_time,
            minimumEventDuration: data => data.minimumEventDuration,
            startTime           : data => data.startTime
        },
        /**
         * @member {Object|null} calendarFieldConfig=null
         */
        calendarFieldConfig: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         */
        endTime_: '24:00',
        /**
         * @member {Object|null} endTimeFieldConfig=null
         */
        endTimeFieldConfig: null,
        /**
         * Bound to the view model.
         * @member {Intl.DateTimeFormat|null} intlFormat_time=null
         * @protected
         */
        intlFormat_time: null,
        /**
         * @member {Neo.calendar.view.week.Component|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Event|null} record_=null
         */
        record_: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         */
        startTime_: '00:00',
        /**
         * @member {Object|null} startTimeFieldConfig=null
         */
        startTimeFieldConfig: null,
        /**
         * @member {Object|null} titleFieldConfig=null
         */
        titleFieldConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1;
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.getField('title').focus();
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Event} value
     * @param {Neo.calendar.model.Event} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        if (value && oldValue) {
            let me         = this,
                timeFormat = me.intlFormat_time;

            me.getField('endTime')  .minValue = me.getEndTimeMinValue(value);
            me.getField('startTime').maxValue = me.getStartTimeMaxValue(value);

            me.reset({
                calendarId: value.calendarId,
                endTime   : timeFormat.format(value.endDate),
                startTime : timeFormat.format(value.startDate),
                title     : value.title
            });
        } else if (value) {
            this.createItems();
        }
    }

    /**
     *
     */
    createItems() {
        let me         = this,
            record     = me.record,
            timeFormat = me.intlFormat_time,
            timeFieldDefaults = {
                module              : _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                listeners           : {change: me.onTimeFieldChange, scope: me},
                stepSize            : 15 * 60,
                width               : '9em'
            };

        if (record) {
            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Title',
                listeners           : {change: me.onTitleFieldChange, scope: me},
                name                : 'title',
                required            : true,
                value               : record.title,
                ...me.titleFieldConfig
            }, {
                module              : _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                clearToOriginalValue: true,
                colorField          : 'color',
                displayField        : 'name',
                flex                : 'none',
                forceSelection      : true,
                labelPosition       : 'inline',
                labelText           : 'Calendar',
                listeners           : {change: me.onCalendarFieldChange, scope: me},
                name                : 'calendarId',
                required            : true,
                triggerAction       : 'all',
                value               : record.calendarId,

                colorFormatter: (scope,data) => {
                    let value = data[scope.colorField];

                    if (value === 'yellow') {
                        return 'var(--event-yellow-border-color)';
                    }

                    return `var(--event-${value}-color)`;
                },

                store: {
                    module  : _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    sourceId: me.model.getStore('calendars').id
                },

                ...me.calendarFieldConfig
            }, {
                labelText: 'Start Time',
                maxValue : me.getStartTimeMaxValue(record),
                minValue : me.startTime,
                name     : 'startTime',
                value    : timeFormat.format(record.startDate),
                ...timeFieldDefaults,
                ...me.startTimeFieldConfig
            }, {
                labelText: 'End Time',
                maxValue : me.endTime,
                minValue : me.getEndTimeMinValue(record),
                name     : 'endTime',
                value    : timeFormat.format(record.endDate),
                ...timeFieldDefaults,
                ...me.endTimeFieldConfig
            }, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-button', 'neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems();
        }
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getEndTimeMinValue(record) {
        let date = new Date(record.startDate.valueOf());

        date.setMinutes(date.getMinutes() + this.minimumEventDuration);

        return this.intlFormat_time.format(date);
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getStartTimeMaxValue(record) {
        let date = new Date(record.endDate.valueOf());

        date.setMinutes(date.getMinutes() - this.minimumEventDuration);

        return this.intlFormat_time.format(date);
    }

    /**
     * @param {Object} data
     */
    onCalendarFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.calendarId = data.record[data.component.store.keyProperty];
        }
    }

    /**
     * todo: we could add a confirm dialog
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        me.getModel().getStore('events').remove(me.record);
        me.unmount();
    }

    /**
     * @param {Object} data
     */
    onFocusLeave(data) {
        let me = this;

        // we need a short delay, since a TimeField picker could be open
        setTimeout(() => {
            me.mounted && me.unmount();
        }, 100);
    }

    /**
     * @param {Object} data
     */
    onTimeFieldChange(data) {
        let me     = this,
            name   = data.component.name,
            field  = name === 'endTime' ? 'endDate' : 'startDate',
            record = me.record,
            date   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(me.record[field]),
            value  = data.value.split(':').map(e => Number(e));

        date.setHours(value[0]);
        date.setMinutes(value[1]);

        record[field] = date;

        if (name === 'endTime') {
            me.getField('startTime').maxValue = me.getStartTimeMaxValue(record);
        } else {
            me.getField('endTime')  .minValue = me.getEndTimeMinValue(record);
        }
    }

    /**
     * @param {Object} data
     */
    onTitleFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.title = data.value;
        }
    }
}

Neo.applyClassConfig(EditEventContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditEventContainer);


/***/ }),

/***/ "./src/calendar/view/MainContainer.mjs":
/*!*********************************************!*\
  !*** ./src/calendar/view/MainContainer.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calendars/Container.mjs */ "./src/calendar/view/calendars/Container.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../component/DateSelector.mjs */ "./src/component/DateSelector.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calendars/EditContainer.mjs */ "./src/calendar/view/calendars/EditContainer.mjs");
/* harmony import */ var _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EditEventContainer.mjs */ "./src/calendar/view/EditEventContainer.mjs");
/* harmony import */ var _MainContainerModel_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MainContainerModel.mjs */ "./src/calendar/view/MainContainerModel.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");









const todayDate = new Date();

/**
 * @class Neo.calendar.view.MainContainer
 * @extends Neo.container.Base
 */
class MainContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid entries for the views config
     * @member {String[]} validViews=['day','week','month','year']
     * @static
     */
    static validViews = ['day', 'week', 'month', 'year']

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.MainContainer'
         * @protected
         */
        className: 'Neo.calendar.view.MainContainer',
        /**
         * @member {String} ntype='calendar-maincontainer'
         * @protected
         */
        ntype: 'calendar-maincontainer',
        /**
         * The currently active view. Must be a value included inside the views config.
         * valid values: 'day', 'week', 'month', 'year'
         * @member {String} activeView_='week'
         */
        activeView_: 'week',
        /**
         * @member {String[]} baseCls=['neo-calendar-maincontainer','neo-container']
         */
        baseCls: ['neo-calendar-maincontainer', 'neo-container'],
        /**
         * Scale the calendar with using s different base font-size
         * @member {Number|null} baseFontSize_=null
         */
        baseFontSize_: null,
        /**
         * @member {Neo.calendar.view.Container|null} calendarsContainer=null
         */
        calendarsContainer: null,
        /**
         * @member {Object|null} calendarStoreConfig_=null
         */
        calendarStoreConfig_: null,
        /**
         * @member {Object|null} colorStoreConfig_=null
         */
        colorStoreConfig_: null,
        /**
         * @member {Neo.component.DateSelector|null} dateSelector=null
         */
        dateSelector: null,
        /**
         * @member {Object|null} dateSelectorConfig=null
         */
        dateSelectorConfig: null,
        /**
         * @member {Neo.calendar.view.DayComponent|null} dayComponent=null
         */
        dayComponent: null,
        /**
         * @member {Object|null} dayComponentConfig=null
         */
        dayComponentConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.calendars.EditContainer|null} editCalendarContainer_=null
         */
        editCalendarContainer_: null,
        /**
         * @member {Object|null} editCalendarContainerConfig=null
         */
        editCalendarContainerConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.EditEventContainer|null} editEventContainer_=null
         */
        editEventContainer_: null,
        /**
         * @member {Object|null} editEventContainerConfig=null
         */
        editEventContainerConfig: null,
        /**
         * @member {Object|null} eventStoreConfig_=null
         */
        eventStoreConfig_: null,
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.MainContainerModel} model=MainContainerModel
         */
        model: _MainContainerModel_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
        /**
         * @member {Neo.calendar.view.Component|null} monthComponent=null
         */
        monthComponent: null,
        /**
         * @member {Object|null} monthComponentConfig=null
         */
        monthComponentConfig: null,
        /**
         * True to only keep the active view inside the DOM
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /**
         * @member {Object|null} settingsContainerConfig=null
         */
        settingsContainerConfig: null,
        /**
         * @member {Number} settingsContainerWidth=300
         */
        settingsContainerWidth: 310,
        /**
         * @member {Boolean} settingsExpanded_=false
         */
        settingsExpanded_: false,
        /**
         * @member {Boolean} sideBarExpanded_=true
         */
        sideBarExpanded_: true,
        /**
         * @member {Number} sideBarWidth=220
         */
        sideBarWidth: 220,
        /**
         * @member {Boolean} useSettingsContainer_=true
         */
        useSettingsContainer_: true,
        /**
         * Any combination and order of 'day', 'week', 'month', 'year'
         * @member {String[]} views_=['day','week','month','year']
         */
        views_: ['day', 'week', 'month', 'year'],
        /**
         * @member {Neo.calendar.view.Component|null} weekComponent=null
         */
        weekComponent: null,
        /**
         * @member {Object|null} weekComponentConfig=null
         */
        weekComponentConfig: null,
        /**
         * @member {Neo.calendar.view.YearComponent|null} yearComponent=null
         */
        yearComponent: null,
        /**
         * @member {Object|null} yearComponentConfig=null
         */
        yearComponentConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItemsContent();
        !me.sideBarExpanded && me.afterSetSideBarExpanded(false, true);
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items[1].items[1].layout.activeIndex = me.views.indexOf(value);

            me.items[0].items[1].items.forEach(item => {
                if (item.toggleGroup === 'mainViews') {
                    item.pressed = item.value === value;
                }
            });
        }
    }

    /**
     * Triggered after the baseFontSize config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetBaseFontSize(value, oldValue) {
        if (oldValue !== undefined) {
            let style = this.style || {};

            if (!value) {
                delete style.fontSize;
            } else {
                style.fontSize = `${value}px`;
            }

            this.style = style;
        }
    }

    /**
     * Triggered after the settingsExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSettingsExpanded(value, oldValue) {
        if (Neo.isBoolean(oldValue)) {
            let me                = this,
                settingsContainer = me.items[1].items[2];

            if (value) {
                if (settingsContainer) {
                    settingsContainer.expand();
                } else {
                    me.createSettingsContainer(true).then(() => {
                        // short delay to ensure the vnode already exists
                        setTimeout(() => {
                            me.items[1].items[2].expand();
                        }, 50);
                    });
                }
            } else {
                settingsContainer.collapse(me.settingsContainerWidth);
            }
        }
    }

    /**
     * Triggered after the sideBarExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSideBarExpanded(value, oldValue) {
        if (oldValue !== undefined) {
            let me      = this,
                sideBar = me.items[1].items[0],
                style   = sideBar.style || {};

            if (value) {
                delete sideBar.vdom.removeDom;

                me.promiseVdomUpdate().then(() => {
                    sideBar.mounted = true;

                    setTimeout(() => {
                        style.marginLeft = '0px';
                        sideBar.style = style;
                    }, 50);
                });
            } else {
                style.marginLeft    = `-${me.sideBarWidth}px`;
                sideBar._style      = style; // silent update
                sideBar._vdom.style = style; // silent update

                me.promiseVdomUpdate().then(() => {
                    setTimeout(() => {
                        sideBar.vdom.removeDom = true;
                        sideBar.update();

                        sideBar.mounted = false;
                    }, 400);
                });
            }
        }
    }

    /**
     * Triggered after the useSettingsContainer config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseSettingsContainer(value, oldValue) {
        let me = this;

        if (value) {
            me.settingsExpanded && me.createSettingsContainer(false);

            // we need a short delay to ensure the items already got created
            setTimeout(() => {
                me.items[0].items[1].add({
                    handler: me.toggleSettings.bind(me),
                    iconCls: 'fa fa-cog',
                    style  : {marginLeft: '10px'}
                });
            }, 10);
        } else if (!value && oldValue) {
            // we only need this logic in case we dynamically change the config from true to false
            me.items[1]         .removeLast();
            me.items[0].items[1].removeLast();
        }
    }

    /**
     * Gets triggered before getting the value of the editCalendarContainer config
     * @param {Neo.calendar.view.calendars.EditContainer|null} value
     * @returns {Neo.calendar.view.calendars.EditContainer}
     */
    beforeGetEditCalendarContainer(value) {
        if (!value) {
            let me = this;

            me._editCalendarContainer = value = Neo.create({
                module : _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                appName: me.appName,
                model  : {parent: me.getModel()},
                owner  : me,
                width  : 250,
                ...me.editCalendarContainerConfig
            });
        }

        return value;
    }

    /**
     * Gets triggered before getting the value of the editEventContainer config
     * @param {Neo.calendar.view.EditEventContainer|null} value
     * @returns {Neo.calendar.view.EditEventContainer}
     */
    beforeGetEditEventContainer(value) {
        if (!value) {
            let me = this;

            me._editEventContainer = value = Neo.create({
                module : _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                appName: me.appName,
                model  : {parent: me.getModel()},
                owner  : me,
                width  : 250,
                ...me.editEventContainerConfig
            });
        }

        return value;
    }

    /**
     * Triggered before the activeView config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView', 'validViews');
    }

    /**
     * Triggered before the views config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetViews(value, oldValue) {
        let validViews = this.getStaticConfig('validViews');

        value.forEach(view => {
            if (!validViews.includes(view)) {
                console.error(view, 'is not a valid entry for views. Stick to:', validViews);
                return oldValue;
            }
        });

        return value;
    }

    /**
     * @param {String} view
     * @protected
     */
    changeActiveView(view) {
        this.activeView = view;
    }

    /**
     * @returns {Object[]}
     */
    createHeaderItems() {
        let me = this;

        return [{
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-left', 'neo-toolbar'],
            width : me.sideBarWidth,
            items : [{
                handler: me.toggleSidebar.bind(me),
                iconCls: 'fa fa-bars'
            }, '->', {
                handler: me.onPreviousIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-left',
            }, {
                handler: me.onTodayButtonClick.bind(me),
                height : 24,
                text   : 'Today'
            }, {
                handler: me.onNextIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-right'
            }]
        }, {
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-toolbar'],
            items : ['->', ...me.createViewHeaderButtons()]
        }];
    }

    /**
     * @protected
     */
    createItemsContent() {
        let me = this;

        me.calendarsContainer = Neo.create({
            module  : _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex    : 1,
            parentId: me.id, // we need the parentId to access the model inside the ctor
            owner   : me
        });

        me.dateSelector = Neo.create({
            module   : _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName  : me.appName,
            flex     : 'none',
            height   : me.sideBarWidth,
            listeners: {change: me.onDateSelectorChange, scope: me},
            parentId : me.id, // we need the parentId to access the model inside the ctor

            bind: {
                locale              : data => data.locale,
                scrollNewYearFromTop: data => data.scrollNewYearFromTop,
                showWeekends        : data => data.showWeekends,
                value               : data => _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(data.currentDate),
                weekStartDay        : data => data.weekStartDay
            },

            ...me.dateSelectorConfig
        });

        me.items = [{
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 'none',
            layout: {ntype: 'hbox', align: 'stretch'},
            items : me.createHeaderItems()
        }, {
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 1,
            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                cls   : ['neo-calendar-sidebar', 'neo-container'],
                layout: {ntype: 'vbox', align: 'stretch'},
                width : me.sideBarWidth,
                items : [me.dateSelector, me.calendarsContainer]
            }, {
                module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                flex     : 1,
                items    : me.createViews(),
                listeners: {cardLoaded: me.onCardLoaded, scope: me},
                layout   : {
                    ntype              : 'card',
                    activeIndex        : me.views.indexOf(me.activeView),
                    removeInactiveCards: me.removeInactiveCards
                }
            }]
        }];
    }

    /**
     * @param {Boolean} collapsed
     * @returns {Promise<*>}
     */
    createSettingsContainer(collapsed) {
        let me = this;

        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("src_calendar_view_SettingsContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./SettingsContainer.mjs */ "./src/calendar/view/SettingsContainer.mjs")).then(module => {
            me.items[1].add({
                module             : module.default,
                collapsed,
                removeInactiveCards: me.removeInactiveCards,
                style              : {marginRight: !collapsed ? '0' : `-${me.settingsContainerWidth}px`},
                width              : me.settingsContainerWidth,
                ...me.settingsContainerConfig
            });
        });
    }

    /**
     * @returns {Object[]}
     */
    createViewHeaderButtons() {
        let me          = this,
            activeIndex = me.views.indexOf(me.activeView),
            buttons     = [];

        me.views.forEach((view, index) => {
            buttons.push({
                handler    : me.changeActiveView.bind(me, view),
                height     : 24,
                pressed    : activeIndex === index,
                text       : Neo.capitalize(view),
                toggleGroup: 'mainViews',
                value      : view
            });
        });

        return buttons;
    }

    /**
     * @returns {Neo.component.Base[]}
     */
    createViews() {
        let me    = this,
            cards = [],
            cmp,

        defaultConfig = {
            appName : me.appName,
            owner   : me,
            parentId: me.id
        },

        map = {
            day: {
                module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_calendar_view_week_Component_mjs"), __webpack_require__.e("src_calendar_view_DayComponent_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./DayComponent.mjs */ "./src/calendar/view/DayComponent.mjs")),
                flag  : 'day',
                ...defaultConfig,
                ...me.dayComponentConfig
            },
            month: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_month_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./month/Component.mjs */ "./src/calendar/view/month/Component.mjs")),
                flag  : 'month',
                ...defaultConfig,
                ...me.monthComponentConfig
            },
            week: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_week_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./week/Component.mjs */ "./src/calendar/view/week/Component.mjs")),
                flag  : 'week',
                ...defaultConfig,
                ...me.weekComponentConfig
            },
            year: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_YearComponent_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./YearComponent.mjs */ "./src/calendar/view/YearComponent.mjs")),
                flag  : 'year',
                ...defaultConfig,
                ...me.yearComponentConfig
            }
        };

        me.views.forEach(view => {
            me[`${view}Component`] = cmp = map[view];
            cards.push(cmp);
        });

        return cards;
    }

    /**
     * @param data
     */
    onCardLoaded(data) {
        this[`${data.item.flag}Component`] = data.item;

        // fire the event on this instance as well => setting views can subscribe to it more easily
        this.fire('cardLoaded', {item: data.item});
    }

    /**
     * @param {Object} data
     * @param {String} data.oldValue
     * @param {String} data.value
     */
    onDateSelectorChange(data) {
        data.oldValue !== undefined && this.getModel().setData('currentDate', new Date(`${data.value}T00:00:00`));
    }

    /**
     * @param data
     */
    onNextIntervalButtonClick(data) {
        this.switchInterval(1);
    }

    /**
     * @param data
     */
    onPreviousIntervalButtonClick(data) {
        this.switchInterval(-1);
    }

    /**
     * @param data
     */
    onTodayButtonClick(data) {
        this.model.setData({
            currentDate: todayDate
        });
    }

    /**
     * @protected
     */
    toggleSettings() {
        this.settingsExpanded = !this.settingsExpanded;
    }

    /**
     * @protected
     */
    toggleSidebar() {
        this.sideBarExpanded = !this.sideBarExpanded;
    }

    /**
     * @param {Number} multiplier
     */
    switchInterval(multiplier) {
        let me          = this,
            currentDate = me.data.currentDate,

        map = {
            day  : () => {currentDate.setDate(    currentDate.getDate()     + multiplier)},
            month: () => {currentDate.setMonth(   currentDate.getMonth()    + multiplier)},
            week : () => {currentDate.setDate(    currentDate.getDate() + 7 * multiplier)},
            year : () => {currentDate.setFullYear(currentDate.getFullYear() + multiplier)}
        };

        map[me.activeView]();

        me.model.setData({currentDate});
    }
}

Neo.applyClassConfig(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./src/calendar/view/calendars/ColorsList.mjs":
/*!****************************************************!*\
  !*** ./src/calendar/view/calendars/ColorsList.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../list/Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.calendar.view.calendars.ColorsList
 * @extends Neo.list.Base
 */
class ColorsList extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.ColorsList'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.ColorsList',
        /**
         * @member {String[]} baseCls=['neo-calendars-colors-list','neo-list']
         */
        baseCls: ['neo-calendars-colors-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.colors'
        },
        /**
         * @member {Boolean} useWrapperNode=false
         */
        useWrapperNode: false,
        /**
         * The list gets used as a form field, so we are adjusting the selection based on this config
         * @member {String} value_=null
         */
        value_: null,
        /**
         * Added a tabIndex to enable tabbing through the form
         * @member {Object} _vdom={tag:'ul',cn:[],tabIndex:'0'}
         */
        _vdom:
        {tag: 'ul', cn: [], tabIndex: '0'}
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this,
            record;

        if (value && oldValue !== undefined && !me.disableSelection) {
            record = me.store.find('name', value)[0];
            me.selectionModel?.select(me.getItemId(record[me.getKeyProperty()]));
        }
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        return {style: {
            backgroundColor: `var(--event-${record.name}-color)`,
            color          : `var(--event-${record.name}-color)` // needed for the box-shadow (CSS currentColor)
        }};
    }

    /**
     * @returns {Object}
     */
    getVdomRoot() {
        return this.vdom;
    }

    /**
     * @returns {Object}
     */
    getVnodeRoot() {
        return this.vnode;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me    = this,
            value = me.value;

        value && me.afterSetValue(value, null);
    }

    /**
     * Gets triggered from selection.Model: select()
     * @param {String[]} items
     */
    onSelect(items) {
        let me       = this,
            recordId = me.getItemRecordId(items[0]);

        me.fire('change', {
            record: me.store.get(recordId)
        });
    }
}

Neo.applyClassConfig(ColorsList);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorsList);


/***/ }),

/***/ "./src/calendar/view/calendars/Container.mjs":
/*!***************************************************!*\
  !*** ./src/calendar/view/calendars/Container.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _List_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./List.mjs */ "./src/calendar/view/calendars/List.mjs");



/**
 * @class Neo.calendar.view.calendars.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.Container'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.Container',
        /**
         * @member {String[]} baseCls=['neo-calendar-calendarscontainer','neo-container']
         */
        baseCls: ['neo-calendar-calendarscontainer', 'neo-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore: 'stores.calendars'
        },
        /**
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore: null,
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _List_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            owner : '@config:owner' // passing the owner config downwards
        }, {
            ntype       : 'button',
            cls         : ['neo-add-calendar-button'],
            flex        : 'none',
            handler     : 'onAddCalendarButtonClick',
            handlerScope: 'this',
            style       : {marginTop: 'auto'},
            text        : 'Add Calendar'
        }],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * @param {Object} data
     */
    onAddCalendarButtonClick(data) {
        this.calendarStore.add({
            active: true,
            color : 'red',
            name  : 'New Calendar'
        });
    }
}

Neo.applyClassConfig(Container);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Container);


/***/ }),

/***/ "./src/calendar/view/calendars/EditContainer.mjs":
/*!*******************************************************!*\
  !*** ./src/calendar/view/calendars/EditContainer.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorsList.mjs */ "./src/calendar/view/calendars/ColorsList.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../form/field/Text.mjs */ "./src/form/field/Text.mjs");





/**
 * @class Neo.calendar.view.calendars.EditContainer
 * @extends Neo.form.Container
 */
class EditContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.EditContainer'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.EditContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-container']
         */
        baseCls: ['neo-calendar-edit-container'],
        /**
         * @member {Neo.calendar.view.calendars.ColorsList|null} colorsList=null
         */
        colorsList: null,
        /**
         * @member {Object|null} colorsListConfig=null
         */
        colorsListConfig: null,
        /**
         * @member {Object|null} nameFieldConfig=null
         */
        nameFieldConfig: null,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Calendar|null} record_=null
         */
        record_: null,
        /**
         * @member {Number|null} unMountTimeoutId=null
         * @protected
         */
        unMountTimeoutId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1;
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        value && this.getField('name').focus();
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        let me = this;

        if (value && oldValue) {
            me.reset({
                name: value.name
            });

            me.colorsList.value = value.color;
        } else if (value) {
            me.createItems();
        }
    }

    /**
     * Triggered before the record config gets changed
     * We need the before method to also get clicks on the same edit icon,
     * since it does trigger for not changed values.
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    beforeSetRecord(value, oldValue) {
        let me = this;

        if (me.unMountTimeoutId) {
            clearTimeout(me.unMountTimeoutId);
            me.unMountTimeoutId = null;
        }

        return value;
    }

    /**
     *
     */
    createItems() {
        let me     = this,
            record = me.record;

        if (record) {
            me.colorsList = Neo.create({
                module      : _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                appName     : me.appName,
                listeners   : {change: me.onColorChange, scope: me},
                parentId    : me.parentId,
                value       : record.color,
                wrapperStyle: {marginTop: '0.2em'},
                ...me.colorsListConfig
            });

            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Calendar Name',
                listeners           : {change: me.onNameFieldChange, scope: me},
                name                : 'name',
                required            : true,
                value               : record.name,
                ...me.nameFieldConfig
            },
            me.colorsList, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems();
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.record
     */
    onColorChange(data) {
        this.record.color = data.record.name;
    }

    /**
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        // todo: we could add a confirm dialog

        me.getModel().getStore('calendars').remove(me.record);
        me.unmount();
    }

    /**
     * @param {Object} [data]
     */
    onFocusLeave(data) {
        let me = this;

        // we need a short delay to get record-changes (clicking on another edit icon)
        me.unMountTimeoutId = setTimeout(() => {
            me.unMountTimeoutId = null;
            me.mounted && me.unmount();
        }, 200);
    }

    /**
     * @param {Object} data
     */
    onNameFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.name = data.value;
        }
    }
}

Neo.applyClassConfig(EditContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditContainer);


/***/ }),

/***/ "./src/calendar/view/calendars/List.mjs":
/*!**********************************************!*\
  !*** ./src/calendar/view/calendars/List.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../list/Component.mjs */ "./src/list/Component.mjs");



/**
 * @class Neo.calendar.view.calendars.List
 * @extends Neo.list.Component
 */
class List extends _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.List'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.List',
        /**
         * @member {String[]} baseCls=['neo-calendars-list','neo-list']
         */
        baseCls: ['neo-calendars-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.calendars'
        },
        /**
         * @member {Object} itemDefaults
         */
        itemDefaults: {
            module        : _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex          : 'none',
            hideLabel     : true,
            iconCls       : ['fas', 'fa-square'],
            iconClsChecked: ['fas', 'fa-check-square']
        },
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me       = this,
            id       = record[me.getKeyProperty()],
            items    = me.items || [],
            checkBox = items[index],

        config = {
            checked       : record.active,
            cls           : [`neo-color-${record.color}`],
            fieldValue    : id,
            id            : me.getComponentId(index),
            valueLabelText: record.name
        };

        if (checkBox) {
            checkBox.setSilent(config);
        } else {
            items[index] = checkBox = Neo.create({
                appName  : me.appName,
                listeners: {change: me.onCheckboxChange, scope: me},
                parentId : me.id,
                ...me.itemDefaults,
                ...config
            });
        }

        me.items = items;

        return [checkBox.vdom, {tag: 'i', cls: ['neo-edit-icon', 'fas fa-edit'], id: me.getEditIconId(index)}];
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getEditIconId(index) {
        return `${this.id}__${index}__edit-icon`;
    }

    /**
     * @param {Object} data
     */
    onCheckboxChange(data) {
        this.store.get(data.component.fieldValue).active = data.value;
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        // The click even arrives before the CheckBox onInputValueChange() gets triggered.
        // We need a short delay to ensure the vdom of the list item contains the new checked state
        setTimeout(() => {
            super.onClick(data);
        }, 20);

        if (data.path[0].cls.includes('neo-edit-icon')) {
            let me                    = this,
                listItemRect          = data.path[1].rect,
                mainContainer         = me.owner,
                editCalendarContainer = mainContainer.editCalendarContainer,
                mounted               = editCalendarContainer.mounted,
                record                = me.store.get(me.getItemRecordId(data.path[1].id)),
                style                 = editCalendarContainer.style;

            Object.assign(style, {
                left: `${listItemRect.right + 13}px`,
                top : `${listItemRect.top   - 10}px`
            });

            editCalendarContainer[mounted ? 'set' : 'setSilent']({
                parentId: mainContainer.id,
                record,
                style
            });

            if (!mounted) {
                editCalendarContainer.render(true);
            } else {
                editCalendarContainer.afterSetMounted(true, false);
            }
        }
    }

    /**
     * @param {String} itemId
     */
    onKeyDownEnter(itemId) {
        let me       = this,
            recordId = me.getItemRecordId(itemId),
            checkBox = me.items[me.store.indexOf(recordId)];

        checkBox.checked = !checkBox.checked;
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        this.getModel().setData('activeCalendarId', this.getItemRecordId(items[0]));
    }
}

Neo.applyClassConfig(List);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (List);


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} text_=''
         */
        text_: '',
        /**
         * @member {Object} _vdom={tag: 'label'}
         */
        _vdom:
        {tag: 'label', draggable: false}
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.vdom.html = value;
        this.update();
    }
}

Neo.applyClassConfig(Label);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Label);


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");





/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me        = this,
            component = me.component,
            listenerId;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed();
        } else {
            listenerId = component.on('constructed', () => {
                component.un('constructed', listenerId);
                me.onComponentConstructed();
            });
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent();
    }

    /**
     * @param {String} handlerName
     * @returns {Neo.controller.Component|null}
     */
    getHandlerScope(handlerName) {
        let me     = this,
            parent = me.parent;

        return Neo.isFunction(me[handlerName]) ?
            me : parent ?
            parent.getHandlerScope(handlerName) : null;
    }

    /**
     * sameLevelOnly=false will return the closest VM inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getModel(sameLevelOnly=false) {
        let component = this.component;
        return sameLevelOnly ? component.model : component.getModel();
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me = this,
            parentComponent, parentId;

        if (me.parent) {
            return me.parent;
        }

        parentId        = me.component.parentId;
        parentComponent = parentId && Neo.getComponent(parentId);

        return parentComponent?.getController() || null;
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component;
            }
        }

        return component || null;
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me        = this,
            listeners = component.listeners,
            reference = component.reference,
            eventHandler, handlerScope;

        if (listeners) {
            Object.entries(listeners).forEach(([key, value]) => {
                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                        handlerScope = me.getHandlerScope(eventHandler);

                        if (!handlerScope) {
                            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown event handler for', eventHandler, component);
                        } else {
                            listeners[key] = {};
                            listeners[key].fn = handlerScope[eventHandler].bind(handlerScope);
                        }
                    } else {
                        value.forEach(listener => {
                            if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                                eventHandler = listener.fn;
                                handlerScope = me.getHandlerScope(eventHandler);

                                if (!handlerScope) {
                                    _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown event handler for', eventHandler, component);
                                } else {
                                    listener.fn = handlerScope[eventHandler].bind(handlerScope);
                                }
                            }
                        });
                    }
                }
            });
        }

        if (reference) {
            me.references[reference] = component;
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me           = this,
            domListeners = component.domListeners,
            eventHandler, scope;

        if (domListeners) {
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    eventHandler = null;

                    if (key !== 'scope' && key !== 'delegate') {
                        if (Neo.isString(value)) {
                            eventHandler = value;
                        } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                            eventHandler = value.fn;
                        }

                        if (eventHandler) {
                            scope = me.getHandlerScope(eventHandler);

                            if (!scope) {
                                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown domEvent handler for', eventHandler, component);
                            } else {
                                domListener[key] = scope[eventHandler].bind(scope);
                            }
                        }
                    }
                });
            });
        }
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me = this,
            references = me.references,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break;
            }
        }

        me.getParent()?.removeReference(component);
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/form/Container.mjs":
/*!********************************!*\
  !*** ./src/form/Container.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../form/field/Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");




/**
 * @class Neo.form.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.Container'
         * @protected
         */
        className: 'Neo.form.Container',
        /**
         * @member {String} ntype='form-container'
         * @protected
         */
        ntype: 'form-container',
        /**
         * @member {String[]} baseCls=['neo-form-container'],
         * @protected
         */
        baseCls: ['neo-form-container'],
        /**
         * @member {Object} vdom={tag: 'form',cn:[],onsubmit:'return false;'}
         */
        vdom:
        {tag: 'form', cn: [], onsubmit: 'return false;'}
    }

    /**
     * Either pass a field id or name
     * @param {String} name
     * @returns {Neo.form.field.Base|null} fields
     */
    getField(name) {
        let fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildren(this),
            field;

        for (field of fields) {
            if (field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                if (field.id === name || field.name === name) {
                    return field;
                }
            }
        }

        return null;
    }

    /**
     * @returns {Neo.form.field.Base[]} fields
     */
    getFields() {
        let fields = [];

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildren(this).forEach(item => {
            item instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && fields.push(item);
        });

        return fields;
    }

    /**
     * @returns {Object}
     */
    getSubmitValues() {
        let values = {};

        this.getFields().forEach(item => {
            values[item.name || item.id] = item.getSubmitValue();
        });

        return values;
    }

    /**
     * @returns {Object}
     */
    getValues() {
        let values = {};

        this.getFields().forEach(item => {
            values[item.name || item.id] = item.value;
        });

        return values;
    }

    /**
     * Returns true in case no form field isValid() call returns false
     * @returns {Boolean}
     */
    isValid() {
        let fields = this.getFields(),
            i      = 0,
            len    = fields.length;

        for (; i < len; i++) {
            if (!fields[i].isValid()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Resets field values by field name or field id.
     * Fields not included with a value will get reset to null.
     * @param {Object} [values]
     */
    reset(values={}) {
        let keys = values ? Object.keys(values) : [],
            index;

        this.getFields().forEach(item => {
            index = keys.indexOf(item.name);

            if (index < 0) {
                index = keys.indexOf(item.id);
            }

            item.reset(index > -1 ? values[keys[index]] : null);
        });
    }

    /**
     * Set field values by field name or field id
     * @param {Object} values={}
     */
    setValues(values={}) {
        let keys = Object.keys(values),
            index;

        this.getFields().forEach(item => {
            index = keys.indexOf(item.name);

            if (index < 0) {
                index = keys.indexOf(item.id);
            }

            if (index > -1) {
                item.value = values[keys[index]];
            }
        });
    }

    /**
     * Updates the invalid state for all fields, which have updateValidationIndicators() implemented.
     * This can be useful for create entity forms which show up "clean", when pressing a submit button.
     * @returns {Boolean}
     */
    validate() {
        this.getFields().forEach(item => {
            item.validate?.(false);
        });

        return this.isValid();
    }
}

Neo.applyClassConfig(Container);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Container);


/***/ }),

/***/ "./src/form/field/Color.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _Select_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Select.mjs */ "./src/form/field/Select.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.Select
 */
class Color extends _Select_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-selectfield','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-selectfield', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getInputWrapperId()});

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.vdom, {id: me.getColorIndicatorId()})?.vdom,
            list           = me.list,
            record         = me.record,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor();
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]));
        } else {
            selectionModel?.deselectAll(true);
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter);
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me     = this,
            record = me.record,
            value  = me.value;

        return record ? me.colorFormatter(me, record) : me.forceSelection ? null : value;
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`;
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let list  = this.list,
            index = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem();
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let list = this.list;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem();
    }
}

Neo.applyClassConfig(Color);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);


/***/ }),

/***/ "./src/list/Color.mjs":
/*!****************************!*\
  !*** ./src/list/Color.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.list.Color
 * @extends Neo.list.Base
 */
class Color extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * form.field.Color needs to trigger a silent vdom update
     * @member {Boolean} silentSelectUpdate=false
     * @protected
     */
    silentSelectUpdate = false

    static config = {
        /**
         * @member {String} className='Neo.list.Color'
         * @protected
         */
        className: 'Neo.list.Color',
        /**
         * @member {String} ntype='colorlist'
         * @protected
         */
        ntype: 'colorlist',
        /**
         * @member {String[]} baseCls=['neo-color-list','neo-list']
         */
        baseCls: ['neo-color-list', 'neo-list'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField]
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me         = this,
            id         = record[me.store.keyProperty],
            isSelected = me.selectionModel.isSelected(me.getItemId(id));

        return [{
            tag  : 'i',
            cls  : ['neo-icon', 'fas', `fa-${isSelected ? 'check-' : ''}square`],
            id   : me.getListItemIconId(id),
            style: {
                color: me.colorFormatter(me, record)
            }
        }, {
            vtype: 'text',
            html : record[me.displayField],
            id   : me.getListItemVtextId(id)
        }];
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemIconId(recordId) {
        return `${this.id}__icon__${recordId}`;
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getListItemVtextId(recordId) {
        return `${this.id}__vtext__${recordId}`;
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        let me = this;

        me.createItems(me.silentSelectUpdate);

        !me.silentSelect && me.focus(items[0]);
    }
}

Neo.applyClassConfig(Color);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);


/***/ }),

/***/ "./src/list/Component.mjs":
/*!********************************!*\
  !*** ./src/list/Component.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * A base class for lists which will use component based list items
 * @class Neo.list.Component
 * @extends Neo.list.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Component'
         * @protected
         */
        className: 'Neo.list.Component',
        /**
         * @member {String} ntype='component-list'
         * @protected
         */
        ntype: 'component-list',
        /**
         * @member {Neo.component.Base[]|null} items=null
         */
        items: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        value && this.items?.forEach(item => {
            item.appName = value;
        });
    }

    /**
     *
     */
    destroy(...args) {
        let items = this.items || [];

        items.forEach(item => {
            item.destroy();
        });

        super.destroy(...args);
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getComponentId(index) {
        return `${this.id}__${index}__component`;
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getItemId(recordId) {
        return `${this.id}__${this.store.indexOf(recordId)}`;
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId = vnodeId.split('__')[1];
        return this.store.getAt(parseInt(itemId))[this.getKeyProperty()];
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.sortItems(data);
        super.onStoreSort(data);
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    sortItems(data) {
        let me       = this,
            newItems = [],
            fromIndex, key, previousKeys;

        if (me.items) {
            key          = me.getKeyProperty();
            previousKeys = data.previousItems.map(e => e[key]);

            data.items.forEach(item => {
                fromIndex = previousKeys.indexOf(item[key]);
                newItems.push(me.items[fromIndex]);
            });

            me.items = newItems;
        }
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Base extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left']
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left']

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String} dock_='top'
         */
        dock_: 'top',
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} _layout={ntype: 'hbox', align: 'center', pack : 'start'}
         */
        _layout: {
            ntype: 'hbox',
            align: 'center',
            pack : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value;
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        let me            = this,
            cls           = me.cls,
            dockPositions = me.getStaticConfig('dockPositions');

        dockPositions.forEach(key => {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][key === value ? 'add' : 'remove'](cls, 'neo-dock-' + key);
        });

        me.cls    = cls;
        me.layout = me.getLayoutConfig();
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    ...me.sortZoneConfig
                });
            });
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions');
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            items.forEach((item, index) => {
                if (item === '->') {
                    items[index] = Neo.create({
                        module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                        flex  : 1
                    });
                }
            });
        }

        return super.createItems();
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let layoutConfig;

        switch(this.dock) {
            case 'bottom':
            case 'top':
                layoutConfig = {
                    ntype: 'hbox',
                    align: 'center',
                    pack : 'start'
                };
                break;
            case 'left':
                layoutConfig = {
                    ntype    : 'vbox',
                    align    : 'center',
                    direction: 'column-reverse',
                    pack     : 'start'
                };
                break;
            case 'right':
                layoutConfig = {
                    ntype    : 'vbox',
                    align    : 'center',
                    direction: 'column',
                    pack     : 'start'
                };
                break;
        }

        return layoutConfig;
    }
}

Neo.applyClassConfig(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NhbGVuZGFyX2Jhc2ljX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ2dCO0FBQ2Y7QUFDQTtBQUNNOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBdUI7QUFDM0MscUJBQXFCLGdDQUFnQzs7QUFFckQ7QUFDQSxxQkFBcUIsNkRBQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlCQUF5Qiw0REFBTTtBQUMvQjtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCx1QkFBdUIsNEVBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsYUFBYSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFMkM7QUFDVjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUVBQW1CO0FBQ3pEO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixrRUFBZTtBQUMvQjtBQUNBLFNBQVM7O0FBRVQsUUFB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SSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NhbGVuZGFyL2Jhc2ljL01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NhbGVuZGFyL2Jhc2ljL2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L0VkaXRFdmVudENvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9jYWxlbmRhcnMvQ29sb3JzTGlzdC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L2NhbGVuZGFycy9Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9jYWxlbmRhcnMvRWRpdENvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L2NhbGVuZGFycy9MaXN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9MYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL0NvbG9yLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvQ29sb3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbGlzdC9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQnV0dG9uICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ2FsZW5kYXIgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NhbGVuZGFyL3ZpZXcvTWFpbkNvbnRhaW5lci5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJDb250cm9sbGVyIGZyb20gJy4vTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzJztcbmltcG9ydCBUb29sYmFyICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdG9vbGJhci9CYXNlLm1qcyc7XG5pbXBvcnQgVmlld3BvcnQgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgVmlld3BvcnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIGNsYXNzTmFtZSA6ICdOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lcicsXG4gICAgICAgIGF1dG9Nb3VudCA6IHRydWUsXG4gICAgICAgIGNscyAgICAgICA6IFsnbmVvLWV4YW1wbGVzLWNhbGVuZGFyLW1haW5jb250YWluZXInLCAnbmVvLXZpZXdwb3J0J10sXG4gICAgICAgIGNvbnRyb2xsZXI6IE1haW5Db250YWluZXJDb250cm9sbGVyLFxuICAgICAgICBsYXlvdXQgICAgOiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG5cbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICBtb2R1bGUgOiBUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgIDogJ25vbmUnLFxuICAgICAgICAgICAgcGFkZGluZzogMjAsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdoZWFkZXJUb29sYmFyJyxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjJmMmYyJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nICAgICAgICA6ICcxMHB4IDVweCAxMHB4IDEwcHgnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLWhlYWRlciddLFxuICAgICAgICAgICAgICAgIGh0bWwgOiAnPGkgY2xhc3M9XCJmYSBmYS1jYWxlbmRhclwiPjwvaT5uZW8ubWpzIENhbGVuZGFyJ1xuICAgICAgICAgICAgfSwgJy0+Jywge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiAnb25Td2l0Y2hUaGVtZUJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiAyNyxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtbW9vbicsXG4gICAgICAgICAgICAgICAgdGV4dCAgIDogJ1RoZW1lIERhcmsnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhlaWdodCA6IDI3LFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYWIgZmEtZ2l0aHViJyxcbiAgICAgICAgICAgICAgICBzdHlsZSAgOiB7bWFyZ2luTGVmdDogJzVweCd9LFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdHaXRIdWInLFxuICAgICAgICAgICAgICAgIHVybCAgICA6ICdodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby90cmVlL2Rldi9zcmMvY2FsZW5kYXInXG4gICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IENhbGVuZGFyLFxuICAgICAgICAgICAgZmxleCAgICAgOiAxLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnY2FsZW5kYXInLFxuXG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdXJsICAgICA6ICcuLi8uLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9kYXRhL2NhbGVuZGFycy5qc29uJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZXZlbnRTdG9yZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVybCAgICAgOiAnLi4vLi4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvZGF0YS9ldmVudHMuanNvbidcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1vZGVsRGF0YToge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlOiBuZXcgRGF0ZSgnMjAyMS0wNy0yMCcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhNYWluQ29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFpbkNvbnRhaW5lcjtcbiIsImltcG9ydCBDb21wb25lbnRDb250cm9sbGVyIGZyb20gJy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLmNhbGVuZGFyLmJhc2ljLk1haW5Db250YWluZXJDb250cm9sbGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIgZXh0ZW5kcyBDb21wb25lbnRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYy5NYWluQ29udGFpbmVyQ29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmV4YW1wbGVzLmNhbGVuZGFyLmJhc2ljLk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Td2l0Y2hUaGVtZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnV0dG9uICAgICAgICA9IGRhdGEuY29tcG9uZW50LFxuICAgICAgICAgICAgY29tcG9uZW50ICAgICA9IG1lLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGhlYWRlclRvb2xiYXIgPSBtZS5nZXRSZWZlcmVuY2UoJ2hlYWRlclRvb2xiYXInKSxcbiAgICAgICAgICAgIGJ1dHRvblRleHQsIGNscywgaGVhZGVyQ29sb3IsIGljb25DbHMsIHN0eWxlLCB0aGVtZTtcblxuICAgICAgICBpZiAoYnV0dG9uLnRleHQgPT09ICdUaGVtZSBMaWdodCcpIHtcbiAgICAgICAgICAgIGJ1dHRvblRleHQgID0gJ1RoZW1lIERhcmsnO1xuICAgICAgICAgICAgaGVhZGVyQ29sb3IgPSAnI2YyZjJmMic7XG4gICAgICAgICAgICBpY29uQ2xzICAgICA9ICdmYSBmYS1tb29uJztcbiAgICAgICAgICAgIHRoZW1lICAgICAgID0gJ25lby10aGVtZS1saWdodCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidXR0b25UZXh0ICA9ICdUaGVtZSBMaWdodCc7XG4gICAgICAgICAgICBoZWFkZXJDb2xvciA9ICcjMzMzNDNkJztcbiAgICAgICAgICAgIGljb25DbHMgICAgID0gJ2ZhIGZhLXN1bic7XG4gICAgICAgICAgICB0aGVtZSAgICAgICA9ICduZW8tdGhlbWUtZGFyayc7XG4gICAgICAgIH1cblxuICAgICAgICBjbHMgPSBbLi4uY29tcG9uZW50LmNsc107XG5cbiAgICAgICAgY29tcG9uZW50LmNscy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaW5jbHVkZXMoJ25lby10aGVtZScpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHRoZW1lKTtcbiAgICAgICAgY29tcG9uZW50LmNscyA9IGNscztcblxuICAgICAgICBidXR0b24uc2V0KHtcbiAgICAgICAgICAgIGljb25DbHMsXG4gICAgICAgICAgICB0ZXh0OiBidXR0b25UZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0eWxlID0gaGVhZGVyVG9vbGJhci5zdHlsZSB8fCB7fTtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaGVhZGVyQ29sb3I7XG4gICAgICAgIGhlYWRlclRvb2xiYXIuc3R5bGUgPSBzdHlsZTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE1haW5Db250YWluZXJDb250cm9sbGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXI7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYydcbn0pO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICAgICAgZnJvbSAnLi4vLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDYWxlbmRhclN0b3JlIGZyb20gJy4uL3N0b3JlL0NhbGVuZGFycy5tanMnO1xuaW1wb3J0IENvbG9yRmllbGQgICAgZnJvbSAnLi4vLi4vZm9ybS9maWVsZC9Db2xvci5tanMnO1xuaW1wb3J0IERhdGVVdGlsICAgICAgZnJvbSAnLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgRm9ybUNvbnRhaW5lciBmcm9tICcuLi8uLi9mb3JtL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCAgICAgZnJvbSAnLi4vLi4vZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5pbXBvcnQgVGltZUZpZWxkICAgICBmcm9tICcuLi8uLi9mb3JtL2ZpZWxkL1RpbWUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5Db250YWluZXJcbiAqL1xuY2xhc3MgRWRpdEV2ZW50Q29udGFpbmVyIGV4dGVuZHMgRm9ybUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci1lZGl0LWV2ZW50LWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhci1lZGl0LWV2ZW50LWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBlbmRUaW1lICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmVuZFRpbWUsXG4gICAgICAgICAgICBpbnRsRm9ybWF0X3RpbWUgICAgIDogZGF0YSA9PiBkYXRhLmludGxGb3JtYXRfdGltZSxcbiAgICAgICAgICAgIG1pbmltdW1FdmVudER1cmF0aW9uOiBkYXRhID0+IGRhdGEubWluaW11bUV2ZW50RHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydFRpbWUgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLnN0YXJ0VGltZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbGVuZGFyRmllbGRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY2FsZW5kYXJGaWVsZENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZnVsbCBob3VycyBhcmUgdmFsaWQgZm9yIG5vd1xuICAgICAgICAgKiBmb3JtYXQ6ICdoaDptbSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBlbmRUaW1lXz0nMjQ6MDAnXG4gICAgICAgICAqL1xuICAgICAgICBlbmRUaW1lXzogJzI0OjAwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBlbmRUaW1lRmllbGRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZW5kVGltZUZpZWxkQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gaW50bEZvcm1hdF90aW1lPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF90aW1lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcud2Vlay5Db21wb25lbnR8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIubW9kZWwuRXZlbnR8bnVsbH0gcmVjb3JkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmdWxsIGhvdXJzIGFyZSB2YWxpZCBmb3Igbm93XG4gICAgICAgICAqIGZvcm1hdDogJ2hoOm1tJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHN0YXJ0VGltZV89JzAwOjAwJ1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRUaW1lXzogJzAwOjAwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBzdGFydFRpbWVGaWVsZENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydFRpbWVGaWVsZENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSB0aXRsZUZpZWxkQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlRmllbGRDb25maWc6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICAvLyBmb2N1cyB0cmFwLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMzA2XG4gICAgICAgIHRoaXMudmRvbS50YWJJbmRleCA9IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLmdldEZpZWxkKCd0aXRsZScpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZWNvcmQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuRXZlbnR9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuRXZlbnR9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVjb3JkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gbWUuaW50bEZvcm1hdF90aW1lO1xuXG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnZW5kVGltZScpICAubWluVmFsdWUgPSBtZS5nZXRFbmRUaW1lTWluVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgbWUuZ2V0RmllbGQoJ3N0YXJ0VGltZScpLm1heFZhbHVlID0gbWUuZ2V0U3RhcnRUaW1lTWF4VmFsdWUodmFsdWUpO1xuXG4gICAgICAgICAgICBtZS5yZXNldCh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJJZDogdmFsdWUuY2FsZW5kYXJJZCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lICAgOiB0aW1lRm9ybWF0LmZvcm1hdCh2YWx1ZS5lbmREYXRlKSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgOiB0aW1lRm9ybWF0LmZvcm1hdCh2YWx1ZS5zdGFydERhdGUpLFxuICAgICAgICAgICAgICAgIHRpdGxlICAgICA6IHZhbHVlLnRpdGxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVJdGVtcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkICAgICA9IG1lLnJlY29yZCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQgPSBtZS5pbnRsRm9ybWF0X3RpbWUsXG4gICAgICAgICAgICB0aW1lRmllbGREZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogVGltZUZpZWxkLFxuICAgICAgICAgICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZsZXggICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vblRpbWVGaWVsZENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBzdGVwU2l6ZSAgICAgICAgICAgIDogMTUgKiA2MCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICAgIDogJzllbSdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgbWUuaXRlbXMgPSBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICAgOiBUZXh0RmllbGQsXG4gICAgICAgICAgICAgICAgY2xlYXJUb09yaWdpbmFsVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgZmxleCAgICAgICAgICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uICAgICAgIDogJ2lubGluZScsXG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0ICAgICAgICAgICA6ICdUaXRsZScsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzICAgICAgICAgICA6IHtjaGFuZ2U6IG1lLm9uVGl0bGVGaWVsZENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgIDogJ3RpdGxlJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlZCAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgICAgIDogcmVjb3JkLnRpdGxlLFxuICAgICAgICAgICAgICAgIC4uLm1lLnRpdGxlRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogQ29sb3JGaWVsZCxcbiAgICAgICAgICAgICAgICBjbGVhclRvT3JpZ2luYWxWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvckZpZWxkICAgICAgICAgIDogJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RmllbGQgICAgICAgIDogJ25hbWUnLFxuICAgICAgICAgICAgICAgIGZsZXggICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgZm9yY2VTZWxlY3Rpb24gICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgICAgICAgOiAnQ2FsZW5kYXInLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vbkNhbGVuZGFyRmllbGRDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgICAgICAgICAgICA6ICdjYWxlbmRhcklkJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlZCAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQWN0aW9uICAgICAgIDogJ2FsbCcsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA6IHJlY29yZC5jYWxlbmRhcklkLFxuXG4gICAgICAgICAgICAgICAgY29sb3JGb3JtYXR0ZXI6IChzY29wZSxkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbc2NvcGUuY29sb3JGaWVsZF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAneWVsbG93Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd2YXIoLS1ldmVudC15ZWxsb3ctYm9yZGVyLWNvbG9yKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHZhcigtLWV2ZW50LSR7dmFsdWV9LWNvbG9yKWA7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHN0b3JlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBDYWxlbmRhclN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZDogbWUubW9kZWwuZ2V0U3RvcmUoJ2NhbGVuZGFycycpLmlkXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC4uLm1lLmNhbGVuZGFyRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQ6ICdTdGFydCBUaW1lJyxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA6IG1lLmdldFN0YXJ0VGltZU1heFZhbHVlKHJlY29yZCksXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgOiBtZS5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgOiAnc3RhcnRUaW1lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHRpbWVGb3JtYXQuZm9ybWF0KHJlY29yZC5zdGFydERhdGUpLFxuICAgICAgICAgICAgICAgIC4uLnRpbWVGaWVsZERlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLm1lLnN0YXJ0VGltZUZpZWxkQ29uZmlnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0OiAnRW5kIFRpbWUnLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlIDogbWUuZW5kVGltZSxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA6IG1lLmdldEVuZFRpbWVNaW5WYWx1ZShyZWNvcmQpLFxuICAgICAgICAgICAgICAgIG5hbWUgICAgIDogJ2VuZFRpbWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgIDogdGltZUZvcm1hdC5mb3JtYXQocmVjb3JkLmVuZERhdGUpLFxuICAgICAgICAgICAgICAgIC4uLnRpbWVGaWVsZERlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLm1lLmVuZFRpbWVGaWVsZENvbmZpZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBjbHMgICAgOiBbJ25lby1idXR0b24nLCAnbmVvLXJlZCddLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uRGVsZXRlQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhcyBmYS10cmFzaC1hbHQnLFxuICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5Ub3A6ICczZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnRGVsZXRlJ1xuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5FdmVudH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRFbmRUaW1lTWluVmFsdWUocmVjb3JkKSB7XG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUocmVjb3JkLnN0YXJ0RGF0ZS52YWx1ZU9mKCkpO1xuXG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIHRoaXMubWluaW11bUV2ZW50RHVyYXRpb24pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmludGxGb3JtYXRfdGltZS5mb3JtYXQoZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuRXZlbnR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3RhcnRUaW1lTWF4VmFsdWUocmVjb3JkKSB7XG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUocmVjb3JkLmVuZERhdGUudmFsdWVPZigpKTtcblxuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgLSB0aGlzLm1pbmltdW1FdmVudER1cmF0aW9uKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbnRsRm9ybWF0X3RpbWUuZm9ybWF0KGRhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DYWxlbmRhckZpZWxkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNFbXB0eShkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmQuY2FsZW5kYXJJZCA9IGRhdGEucmVjb3JkW2RhdGEuY29tcG9uZW50LnN0b3JlLmtleVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHdlIGNvdWxkIGFkZCBhIGNvbmZpcm0gZGlhbG9nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRlbGV0ZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRNb2RlbCgpLmdldFN0b3JlKCdldmVudHMnKS5yZW1vdmUobWUucmVjb3JkKTtcbiAgICAgICAgbWUudW5tb3VudCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB3ZSBuZWVkIGEgc2hvcnQgZGVsYXksIHNpbmNlIGEgVGltZUZpZWxkIHBpY2tlciBjb3VsZCBiZSBvcGVuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbWUubW91bnRlZCAmJiBtZS51bm1vdW50KCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRpbWVGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbmFtZSAgID0gZGF0YS5jb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgIGZpZWxkICA9IG5hbWUgPT09ICdlbmRUaW1lJyA/ICdlbmREYXRlJyA6ICdzdGFydERhdGUnLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgZGF0ZSAgID0gRGF0ZVV0aWwuY2xvbmUobWUucmVjb3JkW2ZpZWxkXSksXG4gICAgICAgICAgICB2YWx1ZSAgPSBkYXRhLnZhbHVlLnNwbGl0KCc6JykubWFwKGUgPT4gTnVtYmVyKGUpKTtcblxuICAgICAgICBkYXRlLnNldEhvdXJzKHZhbHVlWzBdKTtcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKHZhbHVlWzFdKTtcblxuICAgICAgICByZWNvcmRbZmllbGRdID0gZGF0ZTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2VuZFRpbWUnKSB7XG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnc3RhcnRUaW1lJykubWF4VmFsdWUgPSBtZS5nZXRTdGFydFRpbWVNYXhWYWx1ZShyZWNvcmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZ2V0RmllbGQoJ2VuZFRpbWUnKSAgLm1pblZhbHVlID0gbWUuZ2V0RW5kVGltZU1pblZhbHVlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVGl0bGVGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkLnRpdGxlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoRWRpdEV2ZW50Q29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgRWRpdEV2ZW50Q29udGFpbmVyO1xuIiwiaW1wb3J0IENhbGVuZGFyc0NvbnRhaW5lciAgICBmcm9tICcuL2NhbGVuZGFycy9Db250YWluZXIubWpzJztcbmltcG9ydCBDb250YWluZXIgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBEYXRlU2VsZWN0b3IgICAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0RhdGVTZWxlY3Rvci5tanMnO1xuaW1wb3J0IERhdGVVdGlsICAgICAgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBFZGl0Q2FsZW5kYXJDb250YWluZXIgZnJvbSAnLi9jYWxlbmRhcnMvRWRpdENvbnRhaW5lci5tanMnO1xuaW1wb3J0IEVkaXRFdmVudENvbnRhaW5lciAgICBmcm9tICcuL0VkaXRFdmVudENvbnRhaW5lci5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJNb2RlbCAgICBmcm9tICcuL01haW5Db250YWluZXJNb2RlbC5tanMnO1xuaW1wb3J0IFRvb2xiYXIgICAgICAgICAgICAgICBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIGVudHJpZXMgZm9yIHRoZSB2aWV3cyBjb25maWdcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdmFsaWRWaWV3cz1bJ2RheScsJ3dlZWsnLCdtb250aCcsJ3llYXInXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRWaWV3cyA9IFsnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhciddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY2FsZW5kYXItbWFpbmNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjYWxlbmRhci1tYWluY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIHZpZXcuIE11c3QgYmUgYSB2YWx1ZSBpbmNsdWRlZCBpbnNpZGUgdGhlIHZpZXdzIGNvbmZpZy5cbiAgICAgICAgICogdmFsaWQgdmFsdWVzOiAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcidcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVWaWV3Xz0nd2VlaydcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZVZpZXdfOiAnd2VlaycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci1tYWluY29udGFpbmVyJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhci1tYWluY29udGFpbmVyJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIHRoZSBjYWxlbmRhciB3aXRoIHVzaW5nIHMgZGlmZmVyZW50IGJhc2UgZm9udC1zaXplXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBiYXNlRm9udFNpemVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VGb250U2l6ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5Db250YWluZXJ8bnVsbH0gY2FsZW5kYXJzQ29udGFpbmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyc0NvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYWxlbmRhclN0b3JlQ29uZmlnXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjYWxlbmRhclN0b3JlQ29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjb2xvclN0b3JlQ29uZmlnXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvclN0b3JlQ29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuRGF0ZVNlbGVjdG9yfG51bGx9IGRhdGVTZWxlY3Rvcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRlU2VsZWN0b3I6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF0ZVNlbGVjdG9yQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGVTZWxlY3RvckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LkRheUNvbXBvbmVudHxudWxsfSBkYXlDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF5Q29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRheUNvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXlDb21wb25lbnRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXJ8bnVsbH0gZWRpdENhbGVuZGFyQ29udGFpbmVyXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGVkaXRDYWxlbmRhckNvbnRhaW5lckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyfG51bGx9IGVkaXRFdmVudENvbnRhaW5lcl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBlZGl0RXZlbnRDb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGV2ZW50U3RvcmVDb25maWdfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50U3RvcmVDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOid2Ym94JyxhbGlnbjonc3RyZXRjaCd9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lck1vZGVsfSBtb2RlbD1NYWluQ29udGFpbmVyTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBNYWluQ29udGFpbmVyTW9kZWwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5Db21wb25lbnR8bnVsbH0gbW9udGhDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbW9udGhDb21wb25lbnRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhDb21wb25lbnRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIG9ubHkga2VlcCB0aGUgYWN0aXZlIHZpZXcgaW5zaWRlIHRoZSBET01cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3ZlSW5hY3RpdmVDYXJkcz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHNldHRpbmdzQ29udGFpbmVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNldHRpbmdzQ29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzZXR0aW5nc0NvbnRhaW5lcldpZHRoPTMwMFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0dGluZ3NDb250YWluZXJXaWR0aDogMzEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2V0dGluZ3NFeHBhbmRlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNldHRpbmdzRXhwYW5kZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpZGVCYXJFeHBhbmRlZF89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZUJhckV4cGFuZGVkXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2lkZUJhcldpZHRoPTIyMFxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZUJhcldpZHRoOiAyMjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VTZXR0aW5nc0NvbnRhaW5lcl89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU2V0dGluZ3NDb250YWluZXJfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW55IGNvbWJpbmF0aW9uIGFuZCBvcmRlciBvZiAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcidcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHZpZXdzXz1bJ2RheScsJ3dlZWsnLCdtb250aCcsJ3llYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgdmlld3NfOiBbJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LkNvbXBvbmVudHxudWxsfSB3ZWVrQ29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd2Vla0NvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3ZWVrQ29tcG9uZW50Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuWWVhckNvbXBvbmVudHxudWxsfSB5ZWFyQ29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHllYXJDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0geWVhckNvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB5ZWFyQ29tcG9uZW50Q29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jcmVhdGVJdGVtc0NvbnRlbnQoKTtcbiAgICAgICAgIW1lLnNpZGVCYXJFeHBhbmRlZCAmJiBtZS5hZnRlclNldFNpZGVCYXJFeHBhbmRlZChmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhY3RpdmVWaWV3IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFjdGl2ZVZpZXcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5pdGVtc1sxXS5pdGVtc1sxXS5sYXlvdXQuYWN0aXZlSW5kZXggPSBtZS52aWV3cy5pbmRleE9mKHZhbHVlKTtcblxuICAgICAgICAgICAgbWUuaXRlbXNbMF0uaXRlbXNbMV0uaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2dnbGVHcm91cCA9PT0gJ21haW5WaWV3cycpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmVzc2VkID0gaXRlbS52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGJhc2VGb250U2l6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRCYXNlRm9udFNpemUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5mb250U2l6ZSA9IGAke3ZhbHVlfXB4YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZXR0aW5nc0V4cGFuZGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2V0dGluZ3NFeHBhbmRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc0Jvb2xlYW4ob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ29udGFpbmVyID0gbWUuaXRlbXNbMV0uaXRlbXNbMl07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0NvbnRhaW5lci5leHBhbmQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVTZXR0aW5nc0NvbnRhaW5lcih0cnVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3J0IGRlbGF5IHRvIGVuc3VyZSB0aGUgdm5vZGUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLml0ZW1zWzFdLml0ZW1zWzJdLmV4cGFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ29udGFpbmVyLmNvbGxhcHNlKG1lLnNldHRpbmdzQ29udGFpbmVyV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaWRlQmFyRXhwYW5kZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaWRlQmFyRXhwYW5kZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc2lkZUJhciA9IG1lLml0ZW1zWzFdLml0ZW1zWzBdLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgPSBzaWRlQmFyLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2lkZUJhci52ZG9tLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgICAgIG1lLnByb21pc2VWZG9tVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVCYXIubW91bnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5tYXJnaW5MZWZ0ID0gJzBweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlQmFyLnN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubWFyZ2luTGVmdCAgICA9IGAtJHttZS5zaWRlQmFyV2lkdGh9cHhgO1xuICAgICAgICAgICAgICAgIHNpZGVCYXIuX3N0eWxlICAgICAgPSBzdHlsZTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIHNpZGVCYXIuX3Zkb20uc3R5bGUgPSBzdHlsZTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlQmFyLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVCYXIudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVCYXIubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCA0MDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VTZXR0aW5nc0NvbnRhaW5lciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZVNldHRpbmdzQ29udGFpbmVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUuc2V0dGluZ3NFeHBhbmRlZCAmJiBtZS5jcmVhdGVTZXR0aW5nc0NvbnRhaW5lcihmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBzaG9ydCBkZWxheSB0byBlbnN1cmUgdGhlIGl0ZW1zIGFscmVhZHkgZ290IGNyZWF0ZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLml0ZW1zWzBdLml0ZW1zWzFdLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLnRvZ2dsZVNldHRpbmdzLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY29nJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpbkxlZnQ6ICcxMHB4J31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0aGlzIGxvZ2ljIGluIGNhc2Ugd2UgZHluYW1pY2FsbHkgY2hhbmdlIHRoZSBjb25maWcgZnJvbSB0cnVlIHRvIGZhbHNlXG4gICAgICAgICAgICBtZS5pdGVtc1sxXSAgICAgICAgIC5yZW1vdmVMYXN0KCk7XG4gICAgICAgICAgICBtZS5pdGVtc1swXS5pdGVtc1sxXS5yZW1vdmVMYXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGVkaXRDYWxlbmRhckNvbnRhaW5lciBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyfG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyfVxuICAgICAqL1xuICAgIGJlZm9yZUdldEVkaXRDYWxlbmRhckNvbnRhaW5lcih2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5fZWRpdENhbGVuZGFyQ29udGFpbmVyID0gdmFsdWUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBFZGl0Q2FsZW5kYXJDb250YWluZXIsXG4gICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBtb2RlbCAgOiB7cGFyZW50OiBtZS5nZXRNb2RlbCgpfSxcbiAgICAgICAgICAgICAgICBvd25lciAgOiBtZSxcbiAgICAgICAgICAgICAgICB3aWR0aCAgOiAyNTAsXG4gICAgICAgICAgICAgICAgLi4ubWUuZWRpdENhbGVuZGFyQ29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGVkaXRFdmVudENvbnRhaW5lciBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lcnxudWxsfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXJ9XG4gICAgICovXG4gICAgYmVmb3JlR2V0RWRpdEV2ZW50Q29udGFpbmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLl9lZGl0RXZlbnRDb250YWluZXIgPSB2YWx1ZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEVkaXRFdmVudENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIG1vZGVsICA6IHtwYXJlbnQ6IG1lLmdldE1vZGVsKCl9LFxuICAgICAgICAgICAgICAgIG93bmVyICA6IG1lLFxuICAgICAgICAgICAgICAgIHdpZHRoICA6IDI1MCxcbiAgICAgICAgICAgICAgICAuLi5tZS5lZGl0RXZlbnRDb250YWluZXJDb25maWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGFjdGl2ZVZpZXcgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2FjdGl2ZVZpZXcnLCAndmFsaWRWaWV3cycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZpZXdzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWaWV3cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbGlkVmlld3MgPSB0aGlzLmdldFN0YXRpY0NvbmZpZygndmFsaWRWaWV3cycpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkVmlld3MuaW5jbHVkZXModmlldykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHZpZXcsICdpcyBub3QgYSB2YWxpZCBlbnRyeSBmb3Igdmlld3MuIFN0aWNrIHRvOicsIHZhbGlkVmlld3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2aWV3XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYW5nZUFjdGl2ZVZpZXcodmlldykge1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgPSB2aWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBjcmVhdGVIZWFkZXJJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG1vZHVsZTogVG9vbGJhcixcbiAgICAgICAgICAgIGNscyAgIDogWyduZW8tY2FsZW5kYXItaGVhZGVyLXRvb2xiYXInLCAnbmVvLWxlZnQnLCAnbmVvLXRvb2xiYXInXSxcbiAgICAgICAgICAgIHdpZHRoIDogbWUuc2lkZUJhcldpZHRoLFxuICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLnRvZ2dsZVNpZGViYXIuYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWJhcnMnXG4gICAgICAgICAgICB9LCAnLT4nLCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25QcmV2aW91c0ludGVydmFsQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWNoZXZyb24tbGVmdCcsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25Ub2RheUJ1dHRvbkNsaWNrLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA6IDI0LFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdUb2RheSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS5vbk5leHRJbnRlcnZhbEJ1dHRvbkNsaWNrLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYSBmYS1jaGV2cm9uLXJpZ2h0J1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlOiBUb29sYmFyLFxuICAgICAgICAgICAgY2xzICAgOiBbJ25lby1jYWxlbmRhci1oZWFkZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddLFxuICAgICAgICAgICAgaXRlbXMgOiBbJy0+JywgLi4ubWUuY3JlYXRlVmlld0hlYWRlckJ1dHRvbnMoKV1cbiAgICAgICAgfV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zQ29udGVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYWxlbmRhcnNDb250YWluZXIgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIG1vZHVsZSAgOiBDYWxlbmRhcnNDb250YWluZXIsXG4gICAgICAgICAgICBmbGV4ICAgIDogMSxcbiAgICAgICAgICAgIHBhcmVudElkOiBtZS5pZCwgLy8gd2UgbmVlZCB0aGUgcGFyZW50SWQgdG8gYWNjZXNzIHRoZSBtb2RlbCBpbnNpZGUgdGhlIGN0b3JcbiAgICAgICAgICAgIG93bmVyICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kYXRlU2VsZWN0b3IgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogRGF0ZVNlbGVjdG9yLFxuICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgZmxleCAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBoZWlnaHQgICA6IG1lLnNpZGVCYXJXaWR0aCxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25EYXRlU2VsZWN0b3JDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICBwYXJlbnRJZCA6IG1lLmlkLCAvLyB3ZSBuZWVkIHRoZSBwYXJlbnRJZCB0byBhY2Nlc3MgdGhlIG1vZGVsIGluc2lkZSB0aGUgY3RvclxuXG4gICAgICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICAgICAgbG9jYWxlICAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsTmV3WWVhckZyb21Ub3A6IGRhdGEgPT4gZGF0YS5zY3JvbGxOZXdZZWFyRnJvbVRvcCxcbiAgICAgICAgICAgICAgICBzaG93V2Vla2VuZHMgICAgICAgIDogZGF0YSA9PiBkYXRhLnNob3dXZWVrZW5kcyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgICAgIDogZGF0YSA9PiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRhLmN1cnJlbnREYXRlKSxcbiAgICAgICAgICAgICAgICB3ZWVrU3RhcnREYXkgICAgICAgIDogZGF0YSA9PiBkYXRhLndlZWtTdGFydERheVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLi4ubWUuZGF0ZVNlbGVjdG9yQ29uZmlnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLml0ZW1zID0gW3tcbiAgICAgICAgICAgIG1vZHVsZTogQ29udGFpbmVyLFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZScsXG4gICAgICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgIGl0ZW1zIDogbWUuY3JlYXRlSGVhZGVySXRlbXMoKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGU6IENvbnRhaW5lcixcbiAgICAgICAgICAgIGZsZXggIDogMSxcbiAgICAgICAgICAgIGxheW91dDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZTogQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGNscyAgIDogWyduZW8tY2FsZW5kYXItc2lkZWJhcicsICduZW8tY29udGFpbmVyJ10sXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgICAgICAgICAgd2lkdGggOiBtZS5zaWRlQmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgaXRlbXMgOiBbbWUuZGF0ZVNlbGVjdG9yLCBtZS5jYWxlbmRhcnNDb250YWluZXJdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBDb250YWluZXIsXG4gICAgICAgICAgICAgICAgZmxleCAgICAgOiAxLFxuICAgICAgICAgICAgICAgIGl0ZW1zICAgIDogbWUuY3JlYXRlVmlld3MoKSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtjYXJkTG9hZGVkOiBtZS5vbkNhcmRMb2FkZWQsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgbGF5b3V0ICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgICAgICAgICAgICA6ICdjYXJkJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlSW5kZXggICAgICAgIDogbWUudmlld3MuaW5kZXhPZihtZS5hY3RpdmVWaWV3KSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogbWUucmVtb3ZlSW5hY3RpdmVDYXJkc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGFwc2VkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgY3JlYXRlU2V0dGluZ3NDb250YWluZXIoY29sbGFwc2VkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGltcG9ydCgnLi9TZXR0aW5nc0NvbnRhaW5lci5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBtZS5pdGVtc1sxXS5hZGQoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIGNvbGxhcHNlZCxcbiAgICAgICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBtZS5yZW1vdmVJbmFjdGl2ZUNhcmRzLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgICA6IHttYXJnaW5SaWdodDogIWNvbGxhcHNlZCA/ICcwJyA6IGAtJHttZS5zZXR0aW5nc0NvbnRhaW5lcldpZHRofXB4YH0sXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgIDogbWUuc2V0dGluZ3NDb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAuLi5tZS5zZXR0aW5nc0NvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3SGVhZGVyQnV0dG9ucygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gbWUudmlld3MuaW5kZXhPZihtZS5hY3RpdmVWaWV3KSxcbiAgICAgICAgICAgIGJ1dHRvbnMgICAgID0gW107XG5cbiAgICAgICAgbWUudmlld3MuZm9yRWFjaCgodmlldywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaGFuZGxlciAgICA6IG1lLmNoYW5nZUFjdGl2ZVZpZXcuYmluZChtZSwgdmlldyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICA6IDI0LFxuICAgICAgICAgICAgICAgIHByZXNzZWQgICAgOiBhY3RpdmVJbmRleCA9PT0gaW5kZXgsXG4gICAgICAgICAgICAgICAgdGV4dCAgICAgICA6IE5lby5jYXBpdGFsaXplKHZpZXcpLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUdyb3VwOiAnbWFpblZpZXdzJyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgIDogdmlld1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBidXR0b25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3cygpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhcmRzID0gW10sXG4gICAgICAgICAgICBjbXAsXG5cbiAgICAgICAgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGFwcE5hbWUgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgcGFyZW50SWQ6IG1lLmlkXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgZGF5OiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiAoKSA9PiBpbXBvcnQoJy4vRGF5Q29tcG9uZW50Lm1qcycpLFxuICAgICAgICAgICAgICAgIGZsYWcgIDogJ2RheScsXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5tZS5kYXlDb21wb25lbnRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb250aDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuL21vbnRoL0NvbXBvbmVudC5tanMnKSxcbiAgICAgICAgICAgICAgICBmbGFnICA6ICdtb250aCcsXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5tZS5tb250aENvbXBvbmVudENvbmZpZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdlZWs6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6ICgpID0+IGltcG9ydCgnLi93ZWVrL0NvbXBvbmVudC5tanMnKSxcbiAgICAgICAgICAgICAgICBmbGFnICA6ICd3ZWVrJyxcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAgICAgICAgIC4uLm1lLndlZWtDb21wb25lbnRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5ZWFyOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiAoKSA9PiBpbXBvcnQoJy4vWWVhckNvbXBvbmVudC5tanMnKSxcbiAgICAgICAgICAgICAgICBmbGFnICA6ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAgICAgICAgIC4uLm1lLnllYXJDb21wb25lbnRDb25maWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBtZS52aWV3cy5mb3JFYWNoKHZpZXcgPT4ge1xuICAgICAgICAgICAgbWVbYCR7dmlld31Db21wb25lbnRgXSA9IGNtcCA9IG1hcFt2aWV3XTtcbiAgICAgICAgICAgIGNhcmRzLnB1c2goY21wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhcmRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25DYXJkTG9hZGVkKGRhdGEpIHtcbiAgICAgICAgdGhpc1tgJHtkYXRhLml0ZW0uZmxhZ31Db21wb25lbnRgXSA9IGRhdGEuaXRlbTtcblxuICAgICAgICAvLyBmaXJlIHRoZSBldmVudCBvbiB0aGlzIGluc3RhbmNlIGFzIHdlbGwgPT4gc2V0dGluZyB2aWV3cyBjYW4gc3Vic2NyaWJlIHRvIGl0IG1vcmUgZWFzaWx5XG4gICAgICAgIHRoaXMuZmlyZSgnY2FyZExvYWRlZCcsIHtpdGVtOiBkYXRhLml0ZW19KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGVTZWxlY3RvckNoYW5nZShkYXRhKSB7XG4gICAgICAgIGRhdGEub2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldE1vZGVsKCkuc2V0RGF0YSgnY3VycmVudERhdGUnLCBuZXcgRGF0ZShgJHtkYXRhLnZhbHVlfVQwMDowMDowMGApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uTmV4dEludGVydmFsQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLnN3aXRjaEludGVydmFsKDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25QcmV2aW91c0ludGVydmFsQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLnN3aXRjaEludGVydmFsKC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uVG9kYXlCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0RGF0YSh7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZTogdG9kYXlEYXRlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0b2dnbGVTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0V4cGFuZGVkID0gIXRoaXMuc2V0dGluZ3NFeHBhbmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdG9nZ2xlU2lkZWJhcigpIHtcbiAgICAgICAgdGhpcy5zaWRlQmFyRXhwYW5kZWQgPSAhdGhpcy5zaWRlQmFyRXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpcGxpZXJcbiAgICAgKi9cbiAgICBzd2l0Y2hJbnRlcnZhbChtdWx0aXBsaWVyKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IG1lLmRhdGEuY3VycmVudERhdGUsXG5cbiAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgZGF5ICA6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXREYXRlKCAgICBjdXJyZW50RGF0ZS5nZXREYXRlKCkgICAgICsgbXVsdGlwbGllcil9LFxuICAgICAgICAgICAgbW9udGg6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXRNb250aCggICBjdXJyZW50RGF0ZS5nZXRNb250aCgpICAgICsgbXVsdGlwbGllcil9LFxuICAgICAgICAgICAgd2VlayA6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXREYXRlKCAgICBjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyA3ICogbXVsdGlwbGllcil9LFxuICAgICAgICAgICAgeWVhciA6ICgpID0+IHtjdXJyZW50RGF0ZS5zZXRGdWxsWWVhcihjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpICsgbXVsdGlwbGllcil9XG4gICAgICAgIH07XG5cbiAgICAgICAgbWFwW21lLmFjdGl2ZVZpZXddKCk7XG5cbiAgICAgICAgbWUubW9kZWwuc2V0RGF0YSh7Y3VycmVudERhdGV9KTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE1haW5Db250YWluZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBNYWluQ29udGFpbmVyO1xuIiwiaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vLi4vbGlzdC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db2xvcnNMaXN0XG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5CYXNlXG4gKi9cbmNsYXNzIENvbG9yc0xpc3QgZXh0ZW5kcyBMaXN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db2xvcnNMaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29sb3JzTGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhcnMtY29sb3JzLWxpc3QnLCduZW8tbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhcnMtY29sb3JzLWxpc3QnLCAnbmVvLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgc3RvcmU6ICdzdG9yZXMuY29sb3JzJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlV3JhcHBlck5vZGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHVzZVdyYXBwZXJOb2RlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdldHMgdXNlZCBhcyBhIGZvcm0gZmllbGQsIHNvIHdlIGFyZSBhZGp1c3RpbmcgdGhlIHNlbGVjdGlvbiBiYXNlZCBvbiB0aGlzIGNvbmZpZ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHZhbHVlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRlZCBhIHRhYkluZGV4IHRvIGVuYWJsZSB0YWJiaW5nIHRocm91Z2ggdGhlIGZvcm1cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17dGFnOid1bCcsY246W10sdGFiSW5kZXg6JzAnfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICd1bCcsIGNuOiBbXSwgdGFiSW5kZXg6ICcwJ31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhbWUuZGlzYWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmVjb3JkID0gbWUuc3RvcmUuZmluZCgnbmFtZScsIHZhbHVlKVswXTtcbiAgICAgICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5zZWxlY3QobWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgZm9yIGN1c3RvbSByZW5kZXJlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXXxTdHJpbmd9IEVpdGhlciBhIGNvbmZpZyBvYmplY3QgdG8gYXNzaWduIHRvIHRoZSBpdGVtLCBhIHZkb20gY24gYXJyYXkgb3IgYSBodG1sIHN0cmluZ1xuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1Db250ZW50KHJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtzdHlsZToge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBgdmFyKC0tZXZlbnQtJHtyZWNvcmQubmFtZX0tY29sb3IpYCxcbiAgICAgICAgICAgIGNvbG9yICAgICAgICAgIDogYHZhcigtLWV2ZW50LSR7cmVjb3JkLm5hbWV9LWNvbG9yKWAgLy8gbmVlZGVkIGZvciB0aGUgYm94LXNoYWRvdyAoQ1NTIGN1cnJlbnRDb2xvcilcbiAgICAgICAgfX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZhbHVlID0gbWUudmFsdWU7XG5cbiAgICAgICAgdmFsdWUgJiYgbWUuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgZnJvbSBzZWxlY3Rpb24uTW9kZWw6IHNlbGVjdCgpXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkSWQgPSBtZS5nZXRJdGVtUmVjb3JkSWQoaXRlbXNbMF0pO1xuXG4gICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgIHJlY29yZDogbWUuc3RvcmUuZ2V0KHJlY29yZElkKVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbG9yc0xpc3QpO1xuXG5leHBvcnQgZGVmYXVsdCBDb2xvcnNMaXN0O1xuIiwiaW1wb3J0IEJhc2VDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMaXN0ICAgICAgICAgIGZyb20gJy4vTGlzdC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLWNhbGVuZGFyc2NvbnRhaW5lcicsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItY2FsZW5kYXJzY29udGFpbmVyJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZTogJ3N0b3Jlcy5jYWxlbmRhcnMnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IGNhbGVuZGFyU3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBMaXN0LFxuICAgICAgICAgICAgb3duZXIgOiAnQGNvbmZpZzpvd25lcicgLy8gcGFzc2luZyB0aGUgb3duZXIgY29uZmlnIGRvd253YXJkc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudHlwZSAgICAgICA6ICdidXR0b24nLFxuICAgICAgICAgICAgY2xzICAgICAgICAgOiBbJ25lby1hZGQtY2FsZW5kYXItYnV0dG9uJ10sXG4gICAgICAgICAgICBmbGV4ICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGhhbmRsZXIgICAgIDogJ29uQWRkQ2FsZW5kYXJCdXR0b25DbGljaycsXG4gICAgICAgICAgICBoYW5kbGVyU2NvcGU6ICd0aGlzJyxcbiAgICAgICAgICAgIHN0eWxlICAgICAgIDoge21hcmdpblRvcDogJ2F1dG8nfSxcbiAgICAgICAgICAgIHRleHQgICAgICAgIDogJ0FkZCBDYWxlbmRhcidcbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J3Zib3gnLGFsaWduOidzdHJldGNoJ31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQWRkQ2FsZW5kYXJCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdG9yZS5hZGQoe1xuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgY29sb3IgOiAncmVkJyxcbiAgICAgICAgICAgIG5hbWUgIDogJ05ldyBDYWxlbmRhcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb250YWluZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCJpbXBvcnQgQnV0dG9uICAgICAgICBmcm9tICcuLi8uLi8uLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbG9yc0xpc3QgICAgZnJvbSAnLi9Db2xvcnNMaXN0Lm1qcyc7XG5pbXBvcnQgRm9ybUNvbnRhaW5lciBmcm9tICcuLi8uLi8uLi9mb3JtL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCAgICAgZnJvbSAnLi4vLi4vLi4vZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5Db250YWluZXJcbiAqL1xuY2xhc3MgRWRpdENvbnRhaW5lciBleHRlbmRzIEZvcm1Db250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLWVkaXQtY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLWVkaXQtY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29sb3JzTGlzdHxudWxsfSBjb2xvcnNMaXN0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yc0xpc3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY29sb3JzTGlzdENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvcnNMaXN0Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IG5hbWVGaWVsZENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lRmllbGRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLm1vZGVsLkNhbGVuZGFyfG51bGx9IHJlY29yZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB1bk1vdW50VGltZW91dElkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdW5Nb3VudFRpbWVvdXRJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIC8vIGZvY3VzIHRyYXAsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIzMDZcbiAgICAgICAgdGhpcy52ZG9tLnRhYkluZGV4ID0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy5nZXRGaWVsZCgnbmFtZScpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZWNvcmQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVjb3JkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUucmVzZXQoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0LnZhbHVlID0gdmFsdWUuY29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSByZWNvcmQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIFdlIG5lZWQgdGhlIGJlZm9yZSBtZXRob2QgdG8gYWxzbyBnZXQgY2xpY2tzIG9uIHRoZSBzYW1lIGVkaXQgaWNvbixcbiAgICAgKiBzaW5jZSBpdCBkb2VzIHRyaWdnZXIgZm9yIG5vdCBjaGFuZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5DYWxlbmRhcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5DYWxlbmRhcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UmVjb3JkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS51bk1vdW50VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWUudW5Nb3VudFRpbWVvdXRJZCk7XG4gICAgICAgICAgICBtZS51bk1vdW50VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLnJlY29yZDtcblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0ID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgOiBDb2xvcnNMaXN0LFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICA6IHtjaGFuZ2U6IG1lLm9uQ29sb3JDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgICAgOiBtZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA6IHJlY29yZC5jb2xvcixcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGU6IHttYXJnaW5Ub3A6ICcwLjJlbSd9LFxuICAgICAgICAgICAgICAgIC4uLm1lLmNvbG9yc0xpc3RDb25maWdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgICAgICBjbGVhclRvT3JpZ2luYWxWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gICAgICAgOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQgICAgICAgICAgIDogJ0NhbGVuZGFyIE5hbWUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vbk5hbWVGaWVsZENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgIDogJ25hbWUnLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgICAgOiByZWNvcmQubmFtZSxcbiAgICAgICAgICAgICAgICAuLi5tZS5uYW1lRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGNscyAgICA6IFsnbmVvLXJlZCddLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uRGVsZXRlQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhcyBmYS10cmFzaC1hbHQnLFxuICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5Ub3A6ICczZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnRGVsZXRlJ1xuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uQ29sb3JDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnJlY29yZC5jb2xvciA9IGRhdGEucmVjb3JkLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRlbGV0ZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvOiB3ZSBjb3VsZCBhZGQgYSBjb25maXJtIGRpYWxvZ1xuXG4gICAgICAgIG1lLmdldE1vZGVsKCkuZ2V0U3RvcmUoJ2NhbGVuZGFycycpLnJlbW92ZShtZS5yZWNvcmQpO1xuICAgICAgICBtZS51bm1vdW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXVxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIGdldCByZWNvcmQtY2hhbmdlcyAoY2xpY2tpbmcgb24gYW5vdGhlciBlZGl0IGljb24pXG4gICAgICAgIG1lLnVuTW91bnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG1lLnVuTW91bnRUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgbWUubW91bnRlZCAmJiBtZS51bm1vdW50KCk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk5hbWVGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkLm5hbWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhFZGl0Q29udGFpbmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgRWRpdENvbnRhaW5lcjtcbiIsImltcG9ydCBDaGVja0JveEZpZWxkIGZyb20gJy4uLy4uLy4uL2Zvcm0vZmllbGQvQ2hlY2tCb3gubWpzJztcbmltcG9ydCBDb21wb25lbnRMaXN0IGZyb20gJy4uLy4uLy4uL2xpc3QvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5MaXN0XG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5Db21wb25lbnRcbiAqL1xuY2xhc3MgTGlzdCBleHRlbmRzIENvbXBvbmVudExpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5MaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFycy1saXN0JywnbmVvLWxpc3QnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXJzLWxpc3QnLCAnbmVvLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgc3RvcmU6ICdzdG9yZXMuY2FsZW5kYXJzJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94RmllbGQsXG4gICAgICAgICAgICBmbGV4ICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IHRydWUsXG4gICAgICAgICAgICBpY29uQ2xzICAgICAgIDogWydmYXMnLCAnZmEtc3F1YXJlJ10sXG4gICAgICAgICAgICBpY29uQ2xzQ2hlY2tlZDogWydmYXMnLCAnZmEtY2hlY2stc3F1YXJlJ11cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXJ8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICA9IHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSxcbiAgICAgICAgICAgIGl0ZW1zICAgID0gbWUuaXRlbXMgfHwgW10sXG4gICAgICAgICAgICBjaGVja0JveCA9IGl0ZW1zW2luZGV4XSxcblxuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICBjaGVja2VkICAgICAgIDogcmVjb3JkLmFjdGl2ZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgOiBbYG5lby1jb2xvci0ke3JlY29yZC5jb2xvcn1gXSxcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgICAgOiBpZCxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgOiBtZS5nZXRDb21wb25lbnRJZChpbmRleCksXG4gICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogcmVjb3JkLm5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY2hlY2tCb3gpIHtcbiAgICAgICAgICAgIGNoZWNrQm94LnNldFNpbGVudChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbXNbaW5kZXhdID0gY2hlY2tCb3ggPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNoZWNrYm94Q2hhbmdlLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgLi4ubWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pdGVtcyA9IGl0ZW1zO1xuXG4gICAgICAgIHJldHVybiBbY2hlY2tCb3gudmRvbSwge3RhZzogJ2knLCBjbHM6IFsnbmVvLWVkaXQtaWNvbicsICdmYXMgZmEtZWRpdCddLCBpZDogbWUuZ2V0RWRpdEljb25JZChpbmRleCl9XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEVkaXRJY29uSWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke2luZGV4fV9fZWRpdC1pY29uYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2hlY2tib3hDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmdldChkYXRhLmNvbXBvbmVudC5maWVsZFZhbHVlKS5hY3RpdmUgPSBkYXRhLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIC8vIFRoZSBjbGljayBldmVuIGFycml2ZXMgYmVmb3JlIHRoZSBDaGVja0JveCBvbklucHV0VmFsdWVDaGFuZ2UoKSBnZXRzIHRyaWdnZXJlZC5cbiAgICAgICAgLy8gV2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIGVuc3VyZSB0aGUgdmRvbSBvZiB0aGUgbGlzdCBpdGVtIGNvbnRhaW5zIHRoZSBuZXcgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHN1cGVyLm9uQ2xpY2soZGF0YSk7XG4gICAgICAgIH0sIDIwKTtcblxuICAgICAgICBpZiAoZGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWVkaXQtaWNvbicpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBsaXN0SXRlbVJlY3QgICAgICAgICAgPSBkYXRhLnBhdGhbMV0ucmVjdCxcbiAgICAgICAgICAgICAgICBtYWluQ29udGFpbmVyICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIgPSBtYWluQ29udGFpbmVyLmVkaXRDYWxlbmRhckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBtb3VudGVkICAgICAgICAgICAgICAgPSBlZGl0Q2FsZW5kYXJDb250YWluZXIubW91bnRlZCxcbiAgICAgICAgICAgICAgICByZWNvcmQgICAgICAgICAgICAgICAgPSBtZS5zdG9yZS5nZXQobWUuZ2V0SXRlbVJlY29yZElkKGRhdGEucGF0aFsxXS5pZCkpLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgICAgICA9IGVkaXRDYWxlbmRhckNvbnRhaW5lci5zdHlsZTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGAke2xpc3RJdGVtUmVjdC5yaWdodCArIDEzfXB4YCxcbiAgICAgICAgICAgICAgICB0b3AgOiBgJHtsaXN0SXRlbVJlY3QudG9wICAgLSAxMH1weGBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJbbW91bnRlZCA/ICdzZXQnIDogJ3NldFNpbGVudCddKHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogbWFpbkNvbnRhaW5lci5pZCxcbiAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgc3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIucmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIuYWZ0ZXJTZXRNb3VudGVkKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKi9cbiAgICBvbktleURvd25FbnRlcihpdGVtSWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZElkID0gbWUuZ2V0SXRlbVJlY29yZElkKGl0ZW1JZCksXG4gICAgICAgICAgICBjaGVja0JveCA9IG1lLml0ZW1zW21lLnN0b3JlLmluZGV4T2YocmVjb3JkSWQpXTtcblxuICAgICAgICBjaGVja0JveC5jaGVja2VkID0gIWNoZWNrQm94LmNoZWNrZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICB0aGlzLmdldE1vZGVsKCkuc2V0RGF0YSgnYWN0aXZlQ2FsZW5kYXJJZCcsIHRoaXMuZ2V0SXRlbVJlY29yZElkKGl0ZW1zWzBdKSk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhMaXN0KTtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0ZXh0Xz0nJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dF86ICcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17dGFnOiAnbGFiZWwnfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdsYWJlbCcsIGRyYWdnYWJsZTogZmFsc2V9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0ZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5odG1sID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhMYWJlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IExhYmVsO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IERvbUV2ZW50TWFuYWdlciAgZnJvbSAnLi4vbWFuYWdlci9Eb21FdmVudC5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlZmVyZW5jZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWZlcmVuY2VzOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5jb21wb25lbnQsXG4gICAgICAgICAgICBsaXN0ZW5lcklkO1xuXG4gICAgICAgIG1lLnJlZmVyZW5jZXMgPSB7fTtcblxuICAgICAgICBpZiAoY29tcG9uZW50LmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVySWQgPSBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bignY29uc3RydWN0ZWQnLCBsaXN0ZW5lcklkKTtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBhcmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlIDogdGhpcy5nZXRQYXJlbnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlck5hbWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50ID0gbWUucGFyZW50O1xuXG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbihtZVtoYW5kbGVyTmFtZV0pID9cbiAgICAgICAgICAgIG1lIDogcGFyZW50ID9cbiAgICAgICAgICAgIHBhcmVudC5nZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFZNIGluc2lkZSB0aGUgY29tcG9uZW50IHBhcmVudCB0cmVlLFxuICAgICAqIGluIGNhc2UgdGhlcmUgaXMgbm9uZSBvbiB0aGUgc2FtZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW1lTGV2ZWxPbmx5PWZhbHNlXVxuICAgICAqL1xuICAgIGdldE1vZGVsKHNhbWVMZXZlbE9ubHk9ZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gc2FtZUxldmVsT25seSA/IGNvbXBvbmVudC5tb2RlbCA6IGNvbXBvbmVudC5nZXRNb2RlbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBjb250cm9sbGVyIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsIHBhcmVudElkO1xuXG4gICAgICAgIGlmIChtZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRJZCAgICAgICAgPSBtZS5jb21wb25lbnQucGFyZW50SWQ7XG4gICAgICAgIHBhcmVudENvbXBvbmVudCA9IHBhcmVudElkICYmIE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQ/LmdldENvbnRyb2xsZXIoKSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHVwZGF0ZSBjaGFuZ2VkIHJlZmVyZW5jZXMgKGUuZy4gY29udGFpbmVyLnJlbW92ZSgpIHRoZW4gY29udGFpbmVyLmFkZCgpIHVzaW5nIHRoZSBzYW1lIGtleSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUucmVmZXJlbmNlc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LmRvd24oe3JlZmVyZW5jZTogbmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb25lbnQgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgeW91ciB2aWV3IGNvbnRyb2xsZXJzIGFzIGEgc3RhcnRpbmcgcG9pbnQgaW4gY2FzZSB5b3UgbmVlZCByZWZlcmVuY2VzXG4gICAgICogKGluc3RlYWQgb2YgdXNpbmcgb25Db25zdHJ1Y3RlZCgpIGluc2lkZSB5b3VyIGNvbnRyb2xsZXIpXG4gICAgICovXG4gICAgb25Db21wb25lbnRDb25zdHJ1Y3RlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VDb25maWcoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gY29tcG9uZW50Lmxpc3RlbmVycyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IGNvbXBvbmVudC5yZWZlcmVuY2UsXG4gICAgICAgICAgICBldmVudEhhbmRsZXIsIGhhbmRsZXJTY29wZTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhsaXN0ZW5lcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScgJiYga2V5ICE9PSAnZGVsZWdhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJTY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIGZvcicsIGV2ZW50SGFuZGxlciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5mbiA9IGhhbmRsZXJTY29wZVtldmVudEhhbmRsZXJdLmJpbmQoaGFuZGxlclNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QobGlzdGVuZXIpICYmIGxpc3RlbmVyLmhhc093blByb3BlcnR5KCdmbicpICYmIE5lby5pc1N0cmluZyhsaXN0ZW5lci5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbGlzdGVuZXIuZm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJTY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbiA9IGhhbmRsZXJTY29wZVtldmVudEhhbmRsZXJdLmJpbmQoaGFuZGxlclNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBtZS5yZWZlcmVuY2VzW3JlZmVyZW5jZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VEb21MaXN0ZW5lcnMoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gY29tcG9uZW50LmRvbUxpc3RlbmVycyxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgc2NvcGU7XG5cbiAgICAgICAgaWYgKGRvbUxpc3RlbmVycykge1xuICAgICAgICAgICAgZG9tTGlzdGVuZXJzLmZvckVhY2goZG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRvbUxpc3RlbmVyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnICYmIGtleSAhPT0gJ2RlbGVnYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZm4nKSAmJiBOZW8uaXNTdHJpbmcodmFsdWUuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gdmFsdWUuZm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ1Vua25vd24gZG9tRXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJba2V5XSA9IHNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZXMgPSBtZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09IHJlZmVyZW5jZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWZlcmVuY2VzW2tleV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudCk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciAgICBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IEJhc2VGaWVsZCAgICAgICAgZnJvbSAnLi4vZm9ybS9maWVsZC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Zvcm0tY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Zvcm0tY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWZvcm0tY29udGFpbmVyJ10sXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWZvcm0tY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e3RhZzogJ2Zvcm0nLGNuOltdLG9uc3VibWl0OidyZXR1cm4gZmFsc2U7J31cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHt0YWc6ICdmb3JtJywgY246IFtdLCBvbnN1Ym1pdDogJ3JldHVybiBmYWxzZTsnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBwYXNzIGEgZmllbGQgaWQgb3IgbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge05lby5mb3JtLmZpZWxkLkJhc2V8bnVsbH0gZmllbGRzXG4gICAgICovXG4gICAgZ2V0RmllbGQobmFtZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZHJlbih0aGlzKSxcbiAgICAgICAgICAgIGZpZWxkO1xuXG4gICAgICAgIGZvciAoZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBCYXNlRmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuaWQgPT09IG5hbWUgfHwgZmllbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5mb3JtLmZpZWxkLkJhc2VbXX0gZmllbGRzXG4gICAgICovXG4gICAgZ2V0RmllbGRzKCkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZHJlbih0aGlzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIEJhc2VGaWVsZCAmJiBmaWVsZHMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFN1Ym1pdFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuZ2V0RmllbGRzKCkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHZhbHVlc1tpdGVtLm5hbWUgfHwgaXRlbS5pZF0gPSBpdGVtLmdldFN1Ym1pdFZhbHVlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZXMoKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSB7fTtcblxuICAgICAgICB0aGlzLmdldEZpZWxkcygpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXNbaXRlbS5uYW1lIHx8IGl0ZW0uaWRdID0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaW4gY2FzZSBubyBmb3JtIGZpZWxkIGlzVmFsaWQoKSBjYWxsIHJldHVybnMgZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICBsZXQgZmllbGRzID0gdGhpcy5nZXRGaWVsZHMoKSxcbiAgICAgICAgICAgIGkgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgPSBmaWVsZHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZmllbGRzW2ldLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBmaWVsZCB2YWx1ZXMgYnkgZmllbGQgbmFtZSBvciBmaWVsZCBpZC5cbiAgICAgKiBGaWVsZHMgbm90IGluY2x1ZGVkIHdpdGggYSB2YWx1ZSB3aWxsIGdldCByZXNldCB0byBudWxsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVzXVxuICAgICAqL1xuICAgIHJlc2V0KHZhbHVlcz17fSkge1xuICAgICAgICBsZXQga2V5cyA9IHZhbHVlcyA/IE9iamVjdC5rZXlzKHZhbHVlcykgOiBbXSxcbiAgICAgICAgICAgIGluZGV4O1xuXG4gICAgICAgIHRoaXMuZ2V0RmllbGRzKCkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGluZGV4ID0ga2V5cy5pbmRleE9mKGl0ZW0ubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGtleXMuaW5kZXhPZihpdGVtLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5yZXNldChpbmRleCA+IC0xID8gdmFsdWVzW2tleXNbaW5kZXhdXSA6IG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZmllbGQgdmFsdWVzIGJ5IGZpZWxkIG5hbWUgb3IgZmllbGQgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICovXG4gICAgc2V0VmFsdWVzKHZhbHVlcz17fSkge1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyksXG4gICAgICAgICAgICBpbmRleDtcblxuICAgICAgICB0aGlzLmdldEZpZWxkcygpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpbmRleCA9IGtleXMuaW5kZXhPZihpdGVtLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBrZXlzLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlc1trZXlzW2luZGV4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludmFsaWQgc3RhdGUgZm9yIGFsbCBmaWVsZHMsIHdoaWNoIGhhdmUgdXBkYXRlVmFsaWRhdGlvbkluZGljYXRvcnMoKSBpbXBsZW1lbnRlZC5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGNyZWF0ZSBlbnRpdHkgZm9ybXMgd2hpY2ggc2hvdyB1cCBcImNsZWFuXCIsIHdoZW4gcHJlc3NpbmcgYSBzdWJtaXQgYnV0dG9uLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHZhbGlkYXRlKCkge1xuICAgICAgICB0aGlzLmdldEZpZWxkcygpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLnZhbGlkYXRlPy4oZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb250YWluZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCJpbXBvcnQgQ29sb3JMaXN0IGZyb20gJy4uLy4uL2xpc3QvQ29sb3IubWpzJ1xuaW1wb3J0IFNlbGVjdCAgICBmcm9tICcuL1NlbGVjdC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLlNlbGVjdFxuICovXG5jbGFzcyBDb2xvciBleHRlbmRzIFNlbGVjdCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5Db2xvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQ29sb3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29sb3JmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb2xvcmZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvbG9yZmllbGQnLCduZW8tc2VsZWN0ZmllbGQnLCduZW8tcGlja2VyZmllbGQnLCduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvbG9yZmllbGQnLCAnbmVvLXNlbGVjdGZpZWxkJywgJ25lby1waWNrZXJmaWVsZCcsICduZW8tdGV4dGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YS5Nb2RlbCBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgY29sb3IgdmFsdWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb2xvckZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgdGhlIGZvcm1hdHRlciB0byBhcHBseSBhIGN1c3RvbSBiYWNrZ3JvdW5kLWNvbG9yIHN0eWxpbmcuXG4gICAgICAgICAqIEUuZy4gdXNpbmcgQ1NTIHZhcnMgZm9yIGRpZmZlcmVudCB0aGVtZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGNvbG9yRmllbGQ9KHNjb3BlLGRhdGEpPT5kYXRhW3Njb3BlLmNvbG9yRmllbGRdXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZvcm1hdHRlcjogKHNjb3BlLGRhdGEpID0+IGRhdGFbc2NvcGUuY29sb3JGaWVsZF0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbGlzdENvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbmZpZzoge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgOiBDb2xvckxpc3QsXG4gICAgICAgICAgICBjb2xvckZpZWxkICAgICAgICA6ICdAY29uZmlnOmNvbG9yRmllbGQnLFxuICAgICAgICAgICAgY29sb3JGb3JtYXR0ZXIgICAgOiAnQGNvbmZpZzpjb2xvckZvcm1hdHRlcicsXG4gICAgICAgICAgICBzaWxlbnRTZWxlY3RVcGRhdGU6IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRXcmFwcGVyID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCB7aWQ6IG1lLmdldElucHV0V3JhcHBlcklkKCl9KTtcblxuICAgICAgICBpbnB1dFdyYXBwZXIudmRvbS5jbi51bnNoaWZ0KHtcbiAgICAgICAgICAgIGNscyAgOiAnbmVvLWNvbG9yJyxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRDb2xvckluZGljYXRvcklkKCksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbWUuZ2V0Q29sb3IoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRGaWx0ZXI9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwcmV2ZW50RmlsdGVyPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb2xvckluZGljYXRvciA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUudmRvbSwge2lkOiBtZS5nZXRDb2xvckluZGljYXRvcklkKCl9KT8udmRvbSxcbiAgICAgICAgICAgIGxpc3QgICAgICAgICAgID0gbWUubGlzdCxcbiAgICAgICAgICAgIHJlY29yZCAgICAgICAgID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwgPSBtZS5saXN0Py5zZWxlY3Rpb25Nb2RlbDtcblxuICAgICAgICBpZiAoY29sb3JJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGNvbG9ySW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1lLmdldENvbG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0KGxpc3QuZ2V0SXRlbUlkKHJlY29yZFttZS5zdG9yZS5rZXlQcm9wZXJ0eV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBzdXBlciBjYWxsIHdpbGwgdHJpZ2dlciB0aGUgdmRvbSB1cGRhdGVcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByZXZlbnRGaWx0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29sb3IoKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgdmFsdWUgID0gbWUudmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZCA/IG1lLmNvbG9yRm9ybWF0dGVyKG1lLCByZWNvcmQpIDogbWUuZm9yY2VTZWxlY3Rpb24gPyBudWxsIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2xvckluZGljYXRvcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2NvbG9yLWluZGljYXRvcmA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UG9zdExhc3RJdGVtKCkge1xuICAgICAgICBsZXQgbGlzdCAgPSB0aGlzLmxpc3QsXG4gICAgICAgICAgICBpbmRleCA9IGxpc3Quc3RvcmUuZ2V0Q291bnQoKSAtIDE7XG5cbiAgICAgICAgbGlzdC52ZG9tLmNuW2luZGV4XSA9IGxpc3QuY3JlYXRlSXRlbShsaXN0LnN0b3JlLmdldEF0KGluZGV4KSwgaW5kZXgpO1xuXG4gICAgICAgIHN1cGVyLm9uU2VsZWN0UG9zdExhc3RJdGVtKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UHJlRmlyc3RJdGVtKCkge1xuICAgICAgICBsZXQgbGlzdCA9IHRoaXMubGlzdDtcblxuICAgICAgICBsaXN0LnZkb20uY25bMF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdCgwKSwgMCk7XG5cbiAgICAgICAgc3VwZXIub25TZWxlY3RQcmVGaXJzdEl0ZW0oKTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbG9yKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29sb3I7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxpc3QuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqL1xuY2xhc3MgQ29sb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBmb3JtLmZpZWxkLkNvbG9yIG5lZWRzIHRvIHRyaWdnZXIgYSBzaWxlbnQgdmRvbSB1cGRhdGVcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRTZWxlY3RVcGRhdGU9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2lsZW50U2VsZWN0VXBkYXRlID0gZmFsc2VcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxpc3QuQ29sb3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5saXN0LkNvbG9yJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbG9ybGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb2xvcmxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY29sb3ItbGlzdCcsJ25lby1saXN0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvbG9yLWxpc3QnLCAnbmVvLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhLk1vZGVsIGZpZWxkIHdoaWNoIGNvbnRhaW5zIHRoZSBjb2xvciB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbG9yRmllbGQ9J25hbWUnXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZpZWxkOiAnbmFtZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSB0aGUgZm9ybWF0dGVyIHRvIGFwcGx5IGEgY3VzdG9tIGJhY2tncm91bmQtY29sb3Igc3R5bGluZy5cbiAgICAgICAgICogRS5nLiB1c2luZyBDU1MgdmFycyBmb3IgZGlmZmVyZW50IHRoZW1lc1xuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gY29sb3JGaWVsZD0oc2NvcGUsZGF0YSk9PmRhdGFbc2NvcGUuY29sb3JGaWVsZF1cbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRm9ybWF0dGVyOiAoc2NvcGUsZGF0YSkgPT4gZGF0YVtzY29wZS5jb2xvckZpZWxkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICAgICAgPSByZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldLFxuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IG1lLnNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQobWUuZ2V0SXRlbUlkKGlkKSk7XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICB0YWcgIDogJ2knLFxuICAgICAgICAgICAgY2xzICA6IFsnbmVvLWljb24nLCAnZmFzJywgYGZhLSR7aXNTZWxlY3RlZCA/ICdjaGVjay0nIDogJyd9c3F1YXJlYF0sXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0TGlzdEl0ZW1JY29uSWQoaWQpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbWUuY29sb3JGb3JtYXR0ZXIobWUsIHJlY29yZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdnR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGh0bWwgOiByZWNvcmRbbWUuZGlzcGxheUZpZWxkXSxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRMaXN0SXRlbVZ0ZXh0SWQoaWQpXG4gICAgICAgIH1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcmVjb3JkSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtSWNvbklkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9faWNvbl9fJHtyZWNvcmRJZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcmVjb3JkSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtVnRleHRJZChyZWNvcmRJZCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3Z0ZXh0X18ke3JlY29yZElkfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG1lLnNpbGVudFNlbGVjdFVwZGF0ZSk7XG5cbiAgICAgICAgIW1lLnNpbGVudFNlbGVjdCAmJiBtZS5mb2N1cyhpdGVtc1swXSk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb2xvcik7XG5cbmV4cG9ydCBkZWZhdWx0IENvbG9yO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBsaXN0cyB3aGljaCB3aWxsIHVzZSBjb21wb25lbnQgYmFzZWQgbGlzdCBpdGVtc1xuICogQGNsYXNzIE5lby5saXN0LkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmxpc3QuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxpc3QuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1saXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1saXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZVtdfG51bGx9IGl0ZW1zPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICB2YWx1ZSAmJiB0aGlzLml0ZW1zPy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5hcHBOYW1lID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uZGVzdHJveSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50SWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke2luZGV4fV9fY29tcG9uZW50YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJdGVtSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke3RoaXMuc3RvcmUuaW5kZXhPZihyZWNvcmRJZCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdm5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfSBpdGVtSWRcbiAgICAgKi9cbiAgICBnZXRJdGVtUmVjb3JkSWQodm5vZGVJZCkge1xuICAgICAgICBsZXQgaXRlbUlkID0gdm5vZGVJZC5zcGxpdCgnX18nKVsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0QXQocGFyc2VJbnQoaXRlbUlkKSlbdGhpcy5nZXRLZXlQcm9wZXJ0eSgpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnByZXZpb3VzSXRlbXNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBkYXRhLnNjb3BlXG4gICAgICovXG4gICAgb25TdG9yZVNvcnQoZGF0YSkge1xuICAgICAgICB0aGlzLnNvcnRJdGVtcyhkYXRhKTtcbiAgICAgICAgc3VwZXIub25TdG9yZVNvcnQoZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIHNvcnRJdGVtcyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuZXdJdGVtcyA9IFtdLFxuICAgICAgICAgICAgZnJvbUluZGV4LCBrZXksIHByZXZpb3VzS2V5cztcblxuICAgICAgICBpZiAobWUuaXRlbXMpIHtcbiAgICAgICAgICAgIGtleSAgICAgICAgICA9IG1lLmdldEtleVByb3BlcnR5KCk7XG4gICAgICAgICAgICBwcmV2aW91c0tleXMgPSBkYXRhLnByZXZpb3VzSXRlbXMubWFwKGUgPT4gZVtrZXldKTtcblxuICAgICAgICAgICAgZGF0YS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IHByZXZpb3VzS2V5cy5pbmRleE9mKGl0ZW1ba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChtZS5pdGVtc1tmcm9tSW5kZXhdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IG5ld0l0ZW1zO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4iLCJpbXBvcnQgQnV0dG9uICAgIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgTGFiZWwgICAgIGZyb20gJy4uL2NvbXBvbmVudC9MYWJlbC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby50b29sYmFyLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGRvY2tcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZG9ja1Bvc2l0aW9ucz1bJ3RvcCcsJ3JpZ2h0JywnYm90dG9tJywnbGVmdCddXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkb2NrUG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udG9vbGJhci5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udG9vbGJhci5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3Rvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10b29sYmFyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRvb2xiYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZG9ja189J3RvcCdcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tfOiAndG9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZTonYnV0dG9uJ31cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF9sYXlvdXQ9e250eXBlOiAnaGJveCcsIGFsaWduOiAnY2VudGVyJywgcGFjayA6ICdzdGFydCd9XG4gICAgICAgICAqL1xuICAgICAgICBfbGF5b3V0OiB7XG4gICAgICAgICAgICBudHlwZTogJ2hib3gnLFxuICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgcGFjayA6ICdzdGFydCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUudG9vbGJhci5Tb3J0Wm9uZXxudWxsfSBzb3J0Wm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc29ydFpvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmVDb25maWc6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnNvcnRab25lKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRab25lLmFwcE5hbWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZG9jayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgID0gbWUuY2xzLFxuICAgICAgICAgICAgZG9ja1Bvc2l0aW9ucyA9IG1lLmdldFN0YXRpY0NvbmZpZygnZG9ja1Bvc2l0aW9ucycpO1xuXG4gICAgICAgIGRvY2tQb3NpdGlvbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgTmVvQXJyYXlba2V5ID09PSB2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1kb2NrLScgKyBrZXkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5jbHMgICAgPSBjbHM7XG4gICAgICAgIG1lLmxheW91dCA9IG1lLmdldExheW91dENvbmZpZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLnNvcnRab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS90b29sYmFyL1NvcnRab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zb3J0Wm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5zb3J0Wm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyBkb2NrIHBvc2l0aW9uIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIGRvY2tQb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RvY2snLCAnZG9ja1Bvc2l0aW9ucycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gJy0+Jykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpbmRleF0gPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleCAgOiAxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxheW91dCBjb25maWcgZGVwZW5kaW5nIG9uIHRoaXMuZG9ja1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGxheW91dENvbmZpZ1xuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IGxheW91dENvbmZpZztcblxuICAgICAgICBzd2l0Y2godGhpcy5kb2NrKSB7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlOiAnaGJveCcsXG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcGFjayA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICA6ICd2Ym94JyxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uLXJldmVyc2UnLFxuICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgOiAndmJveCcsXG4gICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5b3V0Q29uZmlnO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQmFzZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=