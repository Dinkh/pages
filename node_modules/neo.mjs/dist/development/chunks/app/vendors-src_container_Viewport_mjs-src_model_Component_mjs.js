(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_container_Viewport_mjs-src_model_Component_mjs"],{

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Viewport)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * @member {String[]} cls=['neo-viewport']
         */
        cls: ['neo-viewport']
    }}

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        if (this.applyBodyCls) {
            Neo.main.DomAccess.applyBodyCls({
                appName: this.appName,
                cls    : ['neo-body-viewport']
            });
        }
    }
}

Neo.applyClassConfig(Viewport);



/***/ }),

/***/ "./src/model/Component.mjs":
/*!*********************************!*\
  !*** ./src/model/Component.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");





const dataVariableRegex = /data((?!(\.[a-z_]\w*\(\)))\.[a-z_]\w*)+/gi,
      variableNameRegex = /^\w*/;

/**
 * An optional component (view) model for adding bindings to configs
 * @class Neo.model.Component
 * @extends Neo.core.Base
 */
class Component extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getStaticConfig() {return {
        /**
         * True automatically applies the core/Observable.mjs mixin
         * @member {Boolean} observable=true
         * @static
         */
        observable: true
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.model.Component'
         * @protected
         */
        className: 'Neo.model.Component',
        /**
         * @member {String} ntype='component-model'
         * @protected
         */
        ntype: 'component-model',
        /**
         * @member {Object|null} bindings_=null
         * @protected
         */
        bindings_: null,
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Object|null} data_=null
         */
        data_: null,
        /**
         * @member {Neo.model.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object|null} stores_=null
         */
        stores_: null
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        Neo.currentWorker.isUsingViewModels = true;
        super(config);
        this.bindings = {};
    }

    /**
     * Adds a given key/value combination on this model level.
     * The method is used by setData() & setDataAtSameLevel()
     * in case the  data property does not exist yet.
     * @param {String} key
     * @param {*} value
     * @private
     */
    addDataProperty(key, value) {
        let me = this,
            data, scope;

        Neo.ns(key, true, me.data);

        data  = me.getDataScope(key);
        scope = data.scope;

        scope[data.key] = value;

        me.createDataProperties(me.data, 'data');
    }

    /**
     * Triggered after the data config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        if (value) {
            this.createDataProperties(value, 'data');
        }
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return value || {};
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.model.Component|null} value
     * @param {Neo.model.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent();
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        if (value) {
            Object.entries(value).forEach(([key, storeValue]) => {
                value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__.default.beforeSetInstance(storeValue);
            });
        }

        return value;
    }

    /**
     *
     * @param {Function} formatter
     * @param {Object} [data=null] optionally pass this.getHierarchyData() for performance reasons
     * @returns {String}
     */
    callFormatter(formatter, data=null) {
        if (!data) {
            data = this.getHierarchyData();
        }

        return formatter.call(this, data);
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} key
     * @param {String} value
     * @param {String} formatter
     */
    createBinding(componentId, key, value, formatter) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            bindingScope, parentModel;

        if (scope && scope.hasOwnProperty(keyLeaf)) {
            bindingScope = Neo.ns(`${key}.${componentId}`, true, me.bindings);
            bindingScope[value] = formatter;
        } else {
            parentModel = me.getParent();

            if (parentModel) {
                parentModel.createBinding(componentId, key, value, formatter);
            } else {
                console.error('No model.Component found with the specified data property', componentId, keyLeaf, value);
            }
        }
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} formatter
     * @param {String} value
     */
    createBindingByFormatter(componentId, formatter, value) {
        let me            = this,
            formatterVars = me.getFormatterVariables(formatter);

        formatterVars.forEach(key => {
            me.createBinding(componentId, key, value, formatter);
        });
    }

    /**
     *
     * @param {Neo.component.Base} component
     */
    createBindings(component) {
        Object.entries(component.bind).forEach(([key, value]) => {
            if (Neo.isObject(value)) {
                value = value.value;
            }

            if (!this.isStoreValue(value)) {
                this.createBindingByFormatter(component.id, value, key);
            }
        });
    }

    /**
     *
     * @param {Object} config
     * @param {String} path
     */
    createDataProperties(config, path) {
        let me   = this,
            root = Neo.ns(path, false, me),
            descriptor, keyValue, newPath;

        Object.entries(config).forEach(([key, value]) => {
            if (!key.startsWith('_')) {
                descriptor = Object.getOwnPropertyDescriptor(root, key);
                newPath    = `${path}.${key}`

                if (!(typeof descriptor === 'object' && typeof descriptor.set === 'function')) {
                    keyValue = config[key];
                    me.createDataProperty(key, newPath, root);
                    root[key] = keyValue;
                }

                if (Neo.isObject(value)) {
                    me.createDataProperties(config[key], newPath);
                }
            }
        });
    }

    /**
     *
     * @param {String} key
     * @param {String} path
     * @param {Object} [root=this.data]
     */
    createDataProperty(key, path, root=this.data) {
        let me = this;

        if (path && path.startsWith('data.')) {
            path = path.substring(5);
        }

        Object.defineProperty(root, key, {
            get() {
                return root['_' + key];
            },

            set(value) {
                let _key     = `_${key}`,
                    oldValue = root[_key];

                if (!root[_key]) {
                    Object.defineProperty(root, _key, {
                        enumerable: false,
                        value     : value,
                        writable  : true
                    });
                } else {
                    root[_key] = value;
                }

                if (!Neo.isEqual(value, oldValue)) {
                    me.onDataPropertyChange(path ? path : key, value, oldValue);
                }
            }
        });
    }

    /**
     * Access the closest data property inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} [originModel=this] for internal usage only
     * @returns {*} value
     */
    getData(key, originModel=this) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            parentModel;

        if (scope && scope.hasOwnProperty(keyLeaf)) {
            return scope[keyLeaf];
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`data property '${key}' does not exist.`, originModel);
        }

        return parentModel.getData(key, originModel);
    }

    /**
     * Helper method to get the scope for a nested data property via Neo.ns() if needed.
     *
     * Example: passing the value 'foo.bar.baz' will return the bar object as the scope
     * and 'baz' as the key.
     * @param key
     * @returns {Object}
     */
    getDataScope(key) {
        let me      = this,
            keyLeaf = key,
            data    = me.data;

        if (key.includes('.')) {
            key     = key.split('.');
            keyLeaf = key.pop();
            data    = Neo.ns(key.join('.'), false, data);
        }

        return {
            key  : keyLeaf,
            scope: data
        };
    }

    /**
     * Extracts data variables from a given formatter string
     * @param {String} value
     */
    getFormatterVariables(value) {
        if (Neo.isFunction(value)) {
            value = value.toString();
        }

        if (Neo.config.environment === 'dist/production') {
            // see: https://github.com/neomjs/neo/issues/2371
            // inside dist/prod the formatter:
            // data => DateUtil.convertToyyyymmdd(data.currentDate)
            // will get minified to:
            // e=>s.Z.convertToyyyymmdd(e.currentDate)
            // the new strategy: find the first variable name => "e"
            // replace it with "data":
            // data=>s.Z.convertToyyyymmdd(data.currentDate)
            // from there we can use the dev mode regex again.

            let dataName       = value.match(variableNameRegex)[0],
                variableRegExp = new RegExp(`(^|[^\\w.])(${dataName})(?!\\w)`, 'g');

            value = value.replace(variableRegExp, '$1data');
        }

        let dataVars = value.match(dataVariableRegex) || [],
            result   = [];

        dataVars.forEach(variable => {
            // remove the "data." at the start
            variable = variable.substr(5);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.add(result, variable);
        });

        result.sort();

        return result;
    }

    /**
     * Returns the merged data
     * @param {Object} data=this.getPlainData()
     * @returns {Object} data
     */
    getHierarchyData(data=this.getPlainData()) {
        let me     = this,
            parent = me.getParent();

        if (parent) {
            return {
                ...parent.getHierarchyData(data),
                ...me.getPlainData()
            };
        }

        return me.getPlainData();
    }

    /**
     * Returns a plain version of this.data.
     * This excludes the property getters & setters.
     * @param {Object} [data=this.data]
     * @returns {Object}
     */
    getPlainData(data=this.data) {
        let plainData = {};

        Object.entries(data).forEach(([key, value]) => {
            if (Neo.typeOf(value) === 'Object') {
                plainData[key] = this.getPlainData(value);
            } else {
                plainData[key] = value;
            }
        });

        return plainData;
    }

    /**
     * Get the closest model inside the components parent tree
     * @returns {Neo.model.Component|null}
     */
    getParent() {
        let me = this,
            parentComponent, parentId;

        if (me.parent) {
            return me.parent;
        }

        parentId        = me.component.parentId;
        parentComponent = parentId && Neo.getComponent(parentId);

        return parentComponent && parentComponent.getModel() || null;
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.model.Component} [originModel=this] for internal usage only
     * @returns {*} value
     */
    getStore(key, originModel=this) {
        let me     = this,
            stores = me.stores,
            parentModel;

        if (stores && stores.hasOwnProperty(key)) {
            return stores[key];
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`store '${key}' found inside this model or parents.`, originModel);
        }

        return parentModel.getStore(key, originModel);
    }

    /**
     * Internal method to avoid code redundancy.
     * Use setData() or setDataAtSameLevel() instead.
     *
     * Passing an originModel param will try to set each key on the closest property match
     * inside the parent model chain => setData()
     * Not passing it will set all values on the model where the method gets called => setDataAtSameLevel()
     * @param {Object|String} key
     * @param {*} value
     * @param {Neo.model.Component} [originModel]
     * @protected
     */
    internalSetData(key, value, originModel) {
        let me = this,
            data, keyLeaf, parentModel, scope;

        if (Neo.isObject(key)) {console.log(key);
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originModel);
            });
        } else {
            data    = me.getDataScope(key);
            scope   = data.scope;
            keyLeaf = data.key;

            if (scope && scope.hasOwnProperty(keyLeaf)) {
                scope[keyLeaf] = value;
            } else {
                if (originModel) {
                    parentModel = me.getParent();

                    if (parentModel) {
                        parentModel.internalSetData(key, value, originModel);
                    } else {
                        originModel.addDataProperty(key, value);
                    }
                } else {
                    me.addDataProperty(key, value);
                }
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.');
    }

    /**
     *
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        let me      = this,
            binding = me.bindings && Neo.ns(key, false, me.bindings),
            component, config, hierarchyData, model;

        if (binding) {
            hierarchyData = {};

            Object.entries(binding).forEach(([componentId, configObject]) => {
                component = Neo.getComponent(componentId) || Neo.get(componentId); // timing issue: the cmp might not be registered inside manager.Component yet
                config    = {};
                model     = component.getModel();

                if (!hierarchyData[model.id]) {
                    hierarchyData[model.id] = model.getHierarchyData();
                }

                Object.entries(configObject).forEach(([configField, formatter]) => {
                    // we can not call me.callFormatter(), since a data property inside a parent model
                    // could have changed which is relying on data properties inside a closer model
                    config[configField] = model.callFormatter(formatter, hierarchyData[model.id]);
                });

                if (component) {
                    component.set(config);
                }
            });
        }

        me.fire('dataPropertyChange', {
            key     : key,
            id      : me.id,
            oldValue: oldValue,
            value   : value
        });
    }

    /**
     * This method will assign binding values at the earliest possible point inside the component lifecycle.
     * It can not store bindings though, since child component ids most likely do not exist yet.
     * @param {Neo.component.Base} [component=this.component]
     */
    parseConfig(component=this.component) {
        let me     = this,
            config = {};

        if (component.bind) {
            me.createBindings(component);

            Object.entries(component.bind).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    value = value.value;
                }

                if (me.isStoreValue(value)) {
                    me.resolveStore(component, key, value.substring(7)); // remove the "stores." at the start
                } else {
                    config[key] = me.callFormatter(value);
                }
            });

            component.set(config);
        }
    }

    /**
     * Removes all bindings for a given component id inside this model
     * as well as inside all parent models.
     * @param {String} componentId
     */
    removeBindings(componentId) {
        let me          = this,
            parentModel = me.getParent();

        Object.entries(me.bindings).forEach(([dataProperty, binding]) => {
            delete binding[componentId];
        });

        if (parentModel) {
            parentModel.removeBindings(componentId);
        }
    }

    /**
     *
     * @param {Neo.component.Base} component
     * @param {String} configName
     * @param {String} storeName
     * @param {Neo.model.Component} [originModel=this] for internal usage only
     */
    resolveStore(component, configName, storeName, originModel=this) {
        component[configName] = this.getStore(storeName);
    }

    /**
     * The method will assign all values to the closest model where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     * @param {Object|String} key
     * @param {*} value
     */
    setData(key, value) {
        this.internalSetData(key, value, this);
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent models.
     * @param {Object|String} key
     * @param {*} value
     */
    setDataAtSameLevel(key, value) {
        this.internalSetData(key, value);
    }
}

Neo.applyClassConfig(Component);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tb2RlbC9Db21wb25lbnQubWpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBUztBQUNoQyx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVDK0M7QUFDTztBQUNOO0FBQ0s7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBSTtBQUM1Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFB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QU87QUFDdEIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0U7QUFDeEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRThCIiwiZmlsZSI6ImNodW5rcy9hcHAvdmVuZG9ycy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qcy1zcmNfbW9kZWxfQ29tcG9uZW50X21qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzICduZW8tYm9keS12aWV3cG9ydCcgdG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXBwbHlCb2R5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8tdmlld3BvcnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ25lby12aWV3cG9ydCddXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmFwcGx5Qm9keUNscykge1xuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGNscyAgICA6IFsnbmVvLWJvZHktdmlld3BvcnQnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFZpZXdwb3J0KTtcblxuZXhwb3J0IHtWaWV3cG9ydCBhcyBkZWZhdWx0fTsiLCJpbXBvcnQgQmFzZSAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbmNvbnN0IGRhdGFWYXJpYWJsZVJlZ2V4ID0gL2RhdGEoKD8hKFxcLlthLXpfXVxcdypcXChcXCkpKVxcLlthLXpfXVxcdyopKy9naSxcbiAgICAgIHZhcmlhYmxlTmFtZVJlZ2V4ID0gL15cXHcqLztcblxuLyoqXG4gKiBBbiBvcHRpb25hbCBjb21wb25lbnQgKHZpZXcpIG1vZGVsIGZvciBhZGRpbmcgYmluZGluZ3MgdG8gY29uZmlnc1xuICogQGNsYXNzIE5lby5tb2RlbC5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGdldFN0YXRpY0NvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUvT2JzZXJ2YWJsZS5tanMgbWl4aW5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIG9ic2VydmFibGU6IHRydWVcbiAgICB9fVxuXG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tb2RlbC5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tb2RlbC5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LW1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1tb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gYmluZGluZ3NfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZGluZ3NfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXRhXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHN0b3Jlc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVzXzogbnVsbFxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIuaXNVc2luZ1ZpZXdNb2RlbHMgPSB0cnVlO1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGdpdmVuIGtleS92YWx1ZSBjb21iaW5hdGlvbiBvbiB0aGlzIG1vZGVsIGxldmVsLlxuICAgICAqIFRoZSBtZXRob2QgaXMgdXNlZCBieSBzZXREYXRhKCkgJiBzZXREYXRhQXRTYW1lTGV2ZWwoKVxuICAgICAqIGluIGNhc2UgdGhlICBkYXRhIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkRGF0YVByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEsIHNjb3BlO1xuXG4gICAgICAgIE5lby5ucyhrZXksIHRydWUsIG1lLmRhdGEpO1xuXG4gICAgICAgIGRhdGEgID0gbWUuZ2V0RGF0YVNjb3BlKGtleSk7XG4gICAgICAgIHNjb3BlID0gZGF0YS5zY29wZTtcblxuICAgICAgICBzY29wZVtkYXRhLmtleV0gPSB2YWx1ZTtcblxuICAgICAgICBtZS5jcmVhdGVEYXRhUHJvcGVydGllcyhtZS5kYXRhLCAnZGF0YScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZGF0YSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKHZhbHVlLCAnZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkYXRhIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXREYXRhKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlIDogdGhpcy5nZXRQYXJlbnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZXMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHN0b3JlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZShzdG9yZVZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9ybWF0dGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhPW51bGxdIG9wdGlvbmFsbHkgcGFzcyB0aGlzLmdldEhpZXJhcmNoeURhdGEoKSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgY2FsbEZvcm1hdHRlcihmb3JtYXR0ZXIsIGRhdGE9bnVsbCkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldEhpZXJhcmNoeURhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYmluZGluZyBpbiBjYXNlIGEgbWF0Y2hpbmcgZGF0YSBwcm9wZXJ0eSBkb2VzIGV4aXN0LlxuICAgICAqIE90aGVyd2lzZSBpdCB3aWxsIHVzZSB0aGUgY2xvc2VzdCBtb2RlbCB3aXRoIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXR0ZXJcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nKGNvbXBvbmVudElkLCBrZXksIHZhbHVlLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpLFxuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGUsXG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXksXG4gICAgICAgICAgICBiaW5kaW5nU2NvcGUsIHBhcmVudE1vZGVsO1xuXG4gICAgICAgIGlmIChzY29wZSAmJiBzY29wZS5oYXNPd25Qcm9wZXJ0eShrZXlMZWFmKSkge1xuICAgICAgICAgICAgYmluZGluZ1Njb3BlID0gTmVvLm5zKGAke2tleX0uJHtjb21wb25lbnRJZH1gLCB0cnVlLCBtZS5iaW5kaW5ncyk7XG4gICAgICAgICAgICBiaW5kaW5nU2NvcGVbdmFsdWVdID0gZm9ybWF0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50TW9kZWwuY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gbW9kZWwuQ29tcG9uZW50IGZvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBkYXRhIHByb3BlcnR5JywgY29tcG9uZW50SWQsIGtleUxlYWYsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBiaW5kaW5nIGluIGNhc2UgYSBtYXRjaGluZyBkYXRhIHByb3BlcnR5IGRvZXMgZXhpc3QuXG4gICAgICogT3RoZXJ3aXNlIGl0IHdpbGwgdXNlIHRoZSBjbG9zZXN0IG1vZGVsIHdpdGggYSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0dGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgY3JlYXRlQmluZGluZ0J5Rm9ybWF0dGVyKGNvbXBvbmVudElkLCBmb3JtYXR0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZvcm1hdHRlclZhcnMgPSBtZS5nZXRGb3JtYXR0ZXJWYXJpYWJsZXMoZm9ybWF0dGVyKTtcblxuICAgICAgICBmb3JtYXR0ZXJWYXJzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUJpbmRpbmcoY29tcG9uZW50SWQsIGtleSwgdmFsdWUsIGZvcm1hdHRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmdzKGNvbXBvbmVudCkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnQuYmluZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1N0b3JlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCaW5kaW5nQnlGb3JtYXR0ZXIoY29tcG9uZW50LmlkLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhUHJvcGVydGllcyhjb25maWcsIHBhdGgpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgcm9vdCA9IE5lby5ucyhwYXRoLCBmYWxzZSwgbWUpLFxuICAgICAgICAgICAgZGVzY3JpcHRvciwga2V5VmFsdWUsIG5ld1BhdGg7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJvb3QsIGtleSk7XG4gICAgICAgICAgICAgICAgbmV3UGF0aCAgICA9IGAke3BhdGh9LiR7a2V5fWBcblxuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleVZhbHVlID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0eShrZXksIG5ld1BhdGgsIHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICByb290W2tleV0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVEYXRhUHJvcGVydGllcyhjb25maWdba2V5XSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcm9vdD10aGlzLmRhdGFdXG4gICAgICovXG4gICAgY3JlYXRlRGF0YVByb3BlcnR5KGtleSwgcGF0aCwgcm9vdD10aGlzLmRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAocGF0aCAmJiBwYXRoLnN0YXJ0c1dpdGgoJ2RhdGEuJykpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyg1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb290LCBrZXksIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFsnXycgKyBrZXldO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IF9rZXkgICAgID0gYF8ke2tleX1gLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJvb3RbX2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RbX2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvb3QsIF9rZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZSAgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RbX2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUub25EYXRhUHJvcGVydHlDaGFuZ2UocGF0aCA/IHBhdGggOiBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdGhlIGNsb3Nlc3QgZGF0YSBwcm9wZXJ0eSBpbnNpZGUgdGhlIFZNIHBhcmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtOZW8ubW9kZWwuQ29tcG9uZW50fSBbb3JpZ2luTW9kZWw9dGhpc10gZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXREYXRhKGtleSwgb3JpZ2luTW9kZWw9dGhpcykge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhICAgID0gbWUuZ2V0RGF0YVNjb3BlKGtleSksXG4gICAgICAgICAgICBzY29wZSAgID0gZGF0YS5zY29wZSxcbiAgICAgICAgICAgIGtleUxlYWYgPSBkYXRhLmtleSxcbiAgICAgICAgICAgIHBhcmVudE1vZGVsO1xuXG4gICAgICAgIGlmIChzY29wZSAmJiBzY29wZS5oYXNPd25Qcm9wZXJ0eShrZXlMZWFmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlW2tleUxlYWZdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAoIXBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBkYXRhIHByb3BlcnR5ICcke2tleX0nIGRvZXMgbm90IGV4aXN0LmAsIG9yaWdpbk1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRNb2RlbC5nZXREYXRhKGtleSwgb3JpZ2luTW9kZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZ2V0IHRoZSBzY29wZSBmb3IgYSBuZXN0ZWQgZGF0YSBwcm9wZXJ0eSB2aWEgTmVvLm5zKCkgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTogcGFzc2luZyB0aGUgdmFsdWUgJ2Zvby5iYXIuYmF6JyB3aWxsIHJldHVybiB0aGUgYmFyIG9iamVjdCBhcyB0aGUgc2NvcGVcbiAgICAgKiBhbmQgJ2JheicgYXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREYXRhU2NvcGUoa2V5KSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleUxlYWYgPSBrZXksXG4gICAgICAgICAgICBkYXRhICAgID0gbWUuZGF0YTtcblxuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGtleSAgICAgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGtleUxlYWYgPSBrZXkucG9wKCk7XG4gICAgICAgICAgICBkYXRhICAgID0gTmVvLm5zKGtleS5qb2luKCcuJyksIGZhbHNlLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXkgIDoga2V5TGVhZixcbiAgICAgICAgICAgIHNjb3BlOiBkYXRhXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgZGF0YSB2YXJpYWJsZXMgZnJvbSBhIGdpdmVuIGZvcm1hdHRlciBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZXJWYXJpYWJsZXModmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5jb25maWcuZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMzcxXG4gICAgICAgICAgICAvLyBpbnNpZGUgZGlzdC9wcm9kIHRoZSBmb3JtYXR0ZXI6XG4gICAgICAgICAgICAvLyBkYXRhID0+IERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGEuY3VycmVudERhdGUpXG4gICAgICAgICAgICAvLyB3aWxsIGdldCBtaW5pZmllZCB0bzpcbiAgICAgICAgICAgIC8vIGU9PnMuWi5jb252ZXJ0VG95eXl5bW1kZChlLmN1cnJlbnREYXRlKVxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdHJhdGVneTogZmluZCB0aGUgZmlyc3QgdmFyaWFibGUgbmFtZSA9PiBcImVcIlxuICAgICAgICAgICAgLy8gcmVwbGFjZSBpdCB3aXRoIFwiZGF0YVwiOlxuICAgICAgICAgICAgLy8gZGF0YT0+cy5aLmNvbnZlcnRUb3l5eXltbWRkKGRhdGEuY3VycmVudERhdGUpXG4gICAgICAgICAgICAvLyBmcm9tIHRoZXJlIHdlIGNhbiB1c2UgdGhlIGRldiBtb2RlIHJlZ2V4IGFnYWluLlxuXG4gICAgICAgICAgICBsZXQgZGF0YU5hbWUgICAgICAgPSB2YWx1ZS5tYXRjaCh2YXJpYWJsZU5hbWVSZWdleClbMF0sXG4gICAgICAgICAgICAgICAgdmFyaWFibGVSZWdFeHAgPSBuZXcgUmVnRXhwKGAoXnxbXlxcXFx3Ll0pKCR7ZGF0YU5hbWV9KSg/IVxcXFx3KWAsICdnJyk7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSh2YXJpYWJsZVJlZ0V4cCwgJyQxZGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGFWYXJzID0gdmFsdWUubWF0Y2goZGF0YVZhcmlhYmxlUmVnZXgpIHx8IFtdLFxuICAgICAgICAgICAgcmVzdWx0ICAgPSBbXTtcblxuICAgICAgICBkYXRhVmFycy5mb3JFYWNoKHZhcmlhYmxlID0+IHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgXCJkYXRhLlwiIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5zdWJzdHIoNSk7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQocmVzdWx0LCB2YXJpYWJsZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC5zb3J0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXJnZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhPXRoaXMuZ2V0UGxhaW5EYXRhKClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZ2V0SGllcmFyY2h5RGF0YShkYXRhPXRoaXMuZ2V0UGxhaW5EYXRhKCkpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnQgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBhcmVudC5nZXRIaWVyYXJjaHlEYXRhKGRhdGEpLFxuICAgICAgICAgICAgICAgIC4uLm1lLmdldFBsYWluRGF0YSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmdldFBsYWluRGF0YSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwbGFpbiB2ZXJzaW9uIG9mIHRoaXMuZGF0YS5cbiAgICAgKiBUaGlzIGV4Y2x1ZGVzIHRoZSBwcm9wZXJ0eSBnZXR0ZXJzICYgc2V0dGVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGE9dGhpcy5kYXRhXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0UGxhaW5EYXRhKGRhdGE9dGhpcy5kYXRhKSB7XG4gICAgICAgIGxldCBwbGFpbkRhdGEgPSB7fTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKHZhbHVlKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBwbGFpbkRhdGFba2V5XSA9IHRoaXMuZ2V0UGxhaW5EYXRhKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBsYWluRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3QgbW9kZWwgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsIHBhcmVudElkO1xuXG4gICAgICAgIGlmIChtZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRJZCAgICAgICAgPSBtZS5jb21wb25lbnQucGFyZW50SWQ7XG4gICAgICAgIHBhcmVudENvbXBvbmVudCA9IHBhcmVudElkICYmIE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LmdldE1vZGVsKCkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdGhlIGNsb3Nlc3Qgc3RvcmUgaW5zaWRlIHRoZSBWTSBwYXJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudH0gW29yaWdpbk1vZGVsPXRoaXNdIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5LCBvcmlnaW5Nb2RlbD10aGlzKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RvcmVzID0gbWUuc3RvcmVzLFxuICAgICAgICAgICAgcGFyZW50TW9kZWw7XG5cbiAgICAgICAgaWYgKHN0b3JlcyAmJiBzdG9yZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3Jlc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAoIXBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBzdG9yZSAnJHtrZXl9JyBmb3VuZCBpbnNpZGUgdGhpcyBtb2RlbCBvciBwYXJlbnRzLmAsIG9yaWdpbk1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRNb2RlbC5nZXRTdG9yZShrZXksIG9yaWdpbk1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gYXZvaWQgY29kZSByZWR1bmRhbmN5LlxuICAgICAqIFVzZSBzZXREYXRhKCkgb3Igc2V0RGF0YUF0U2FtZUxldmVsKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIFBhc3NpbmcgYW4gb3JpZ2luTW9kZWwgcGFyYW0gd2lsbCB0cnkgdG8gc2V0IGVhY2gga2V5IG9uIHRoZSBjbG9zZXN0IHByb3BlcnR5IG1hdGNoXG4gICAgICogaW5zaWRlIHRoZSBwYXJlbnQgbW9kZWwgY2hhaW4gPT4gc2V0RGF0YSgpXG4gICAgICogTm90IHBhc3NpbmcgaXQgd2lsbCBzZXQgYWxsIHZhbHVlcyBvbiB0aGUgbW9kZWwgd2hlcmUgdGhlIG1ldGhvZCBnZXRzIGNhbGxlZCA9PiBzZXREYXRhQXRTYW1lTGV2ZWwoKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudH0gW29yaWdpbk1vZGVsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSwgb3JpZ2luTW9kZWwpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEsIGtleUxlYWYsIHBhcmVudE1vZGVsLCBzY29wZTtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGtleSkpIHtjb25zb2xlLmxvZyhrZXkpO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoa2V5KS5mb3JFYWNoKChbZGF0YUtleSwgZGF0YVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmludGVybmFsU2V0RGF0YShkYXRhS2V5LCBkYXRhVmFsdWUsIG9yaWdpbk1vZGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpO1xuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGU7XG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXk7XG5cbiAgICAgICAgICAgIGlmIChzY29wZSAmJiBzY29wZS5oYXNPd25Qcm9wZXJ0eShrZXlMZWFmKSkge1xuICAgICAgICAgICAgICAgIHNjb3BlW2tleUxlYWZdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5Nb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50TW9kZWwuaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUsIG9yaWdpbk1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbk1vZGVsLmFkZERhdGFQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZERhdGFQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb252ZW5pZW5jZSBtZXRob2QgdG8gY2hlY2sgaWYgYSBiaW5kaW5nIHZhbHVlIGlzIHN1cHBvc2VkIHRvIG1hdGNoIGEgc3RvcmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1N0b3JlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lby5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aCgnc3RvcmVzLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgb25EYXRhUHJvcGVydHlDaGFuZ2Uoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYmluZGluZyA9IG1lLmJpbmRpbmdzICYmIE5lby5ucyhrZXksIGZhbHNlLCBtZS5iaW5kaW5ncyksXG4gICAgICAgICAgICBjb21wb25lbnQsIGNvbmZpZywgaGllcmFyY2h5RGF0YSwgbW9kZWw7XG5cbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGhpZXJhcmNoeURhdGEgPSB7fTtcblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoYmluZGluZykuZm9yRWFjaCgoW2NvbXBvbmVudElkLCBjb25maWdPYmplY3RdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjb21wb25lbnRJZCkgfHwgTmVvLmdldChjb21wb25lbnRJZCk7IC8vIHRpbWluZyBpc3N1ZTogdGhlIGNtcCBtaWdodCBub3QgYmUgcmVnaXN0ZXJlZCBpbnNpZGUgbWFuYWdlci5Db21wb25lbnQgeWV0XG4gICAgICAgICAgICAgICAgY29uZmlnICAgID0ge307XG4gICAgICAgICAgICAgICAgbW9kZWwgICAgID0gY29tcG9uZW50LmdldE1vZGVsKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhpZXJhcmNoeURhdGFbbW9kZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeURhdGFbbW9kZWwuaWRdID0gbW9kZWwuZ2V0SGllcmFyY2h5RGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZ09iamVjdCkuZm9yRWFjaCgoW2NvbmZpZ0ZpZWxkLCBmb3JtYXR0ZXJdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBub3QgY2FsbCBtZS5jYWxsRm9ybWF0dGVyKCksIHNpbmNlIGEgZGF0YSBwcm9wZXJ0eSBpbnNpZGUgYSBwYXJlbnQgbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBjaGFuZ2VkIHdoaWNoIGlzIHJlbHlpbmcgb24gZGF0YSBwcm9wZXJ0aWVzIGluc2lkZSBhIGNsb3NlciBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25maWdbY29uZmlnRmllbGRdID0gbW9kZWwuY2FsbEZvcm1hdHRlcihmb3JtYXR0ZXIsIGhpZXJhcmNoeURhdGFbbW9kZWwuaWRdKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnNldChjb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZSgnZGF0YVByb3BlcnR5Q2hhbmdlJywge1xuICAgICAgICAgICAga2V5ICAgICA6IGtleSxcbiAgICAgICAgICAgIGlkICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIHZhbHVlICAgOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFzc2lnbiBiaW5kaW5nIHZhbHVlcyBhdCB0aGUgZWFybGllc3QgcG9zc2libGUgcG9pbnQgaW5zaWRlIHRoZSBjb21wb25lbnQgbGlmZWN5Y2xlLlxuICAgICAqIEl0IGNhbiBub3Qgc3RvcmUgYmluZGluZ3MgdGhvdWdoLCBzaW5jZSBjaGlsZCBjb21wb25lbnQgaWRzIG1vc3QgbGlrZWx5IGRvIG5vdCBleGlzdCB5ZXQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IFtjb21wb25lbnQ9dGhpcy5jb21wb25lbnRdXG4gICAgICovXG4gICAgcGFyc2VDb25maWcoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5iaW5kKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnQuYmluZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuaXNTdG9yZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5yZXNvbHZlU3RvcmUoY29tcG9uZW50LCBrZXksIHZhbHVlLnN1YnN0cmluZyg3KSk7IC8vIHJlbW92ZSB0aGUgXCJzdG9yZXMuXCIgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2tleV0gPSBtZS5jYWxsRm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29tcG9uZW50LnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgYmluZGluZ3MgZm9yIGEgZ2l2ZW4gY29tcG9uZW50IGlkIGluc2lkZSB0aGlzIG1vZGVsXG4gICAgICogYXMgd2VsbCBhcyBpbnNpZGUgYWxsIHBhcmVudCBtb2RlbHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICovXG4gICAgcmVtb3ZlQmluZGluZ3MoY29tcG9uZW50SWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWUuYmluZGluZ3MpLmZvckVhY2goKFtkYXRhUHJvcGVydHksIGJpbmRpbmddKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgYmluZGluZ1tjb21wb25lbnRJZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgcGFyZW50TW9kZWwucmVtb3ZlQmluZGluZ3MoY29tcG9uZW50SWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmVOYW1lXG4gICAgICogQHBhcmFtIHtOZW8ubW9kZWwuQ29tcG9uZW50fSBbb3JpZ2luTW9kZWw9dGhpc10gZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgKi9cbiAgICByZXNvbHZlU3RvcmUoY29tcG9uZW50LCBjb25maWdOYW1lLCBzdG9yZU5hbWUsIG9yaWdpbk1vZGVsPXRoaXMpIHtcbiAgICAgICAgY29tcG9uZW50W2NvbmZpZ05hbWVdID0gdGhpcy5nZXRTdG9yZShzdG9yZU5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCBhc3NpZ24gYWxsIHZhbHVlcyB0byB0aGUgY2xvc2VzdCBtb2RlbCB3aGVyZSBpdCBmaW5kcyBhbiBleGlzdGluZyBrZXkuXG4gICAgICogSW4gY2FzZSBubyBtYXRjaCBpcyBmb3VuZCBpbnNpZGUgdGhlIHBhcmVudCBjaGFpbiwgYSBuZXcgZGF0YSBwcm9wZXJ0eSB3aWxsIGdldCBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHNldERhdGEoKSBpbiBjYXNlIHlvdSB3YW50IHRvIGVuZm9yY2VcbiAgICAgKiBzZXR0aW5nIGFsbCBrZXlzIG9uIHRoaXMgaW5zdGFuY2UgaW5zdGVhZCBvZiBsb29raW5nIGZvciBtYXRjaGVzIGluc2lkZSBwYXJlbnQgbW9kZWxzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldERhdGFBdFNhbWVMZXZlbChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUpO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ29tcG9uZW50KTtcblxuZXhwb3J0IHtDb21wb25lbnQgYXMgZGVmYXVsdH07XG4iXSwic291cmNlUm9vdCI6IiJ9