(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_container_Viewport_mjs-src_model_Component_mjs"],{

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Viewport)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * @member {String[]} cls=['neo-viewport']
         */
        cls: ['neo-viewport']
    }}

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        if (this.applyBodyCls) {
            Neo.main.DomAccess.applyBodyCls({
                appName: this.appName,
                cls    : ['neo-body-viewport']
            });
        }
    }
}

Neo.applyClassConfig(Viewport);



/***/ }),

/***/ "./src/model/Component.mjs":
/*!*********************************!*\
  !*** ./src/model/Component.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");





const expressionContentRegex = /\${(.+?)}/g,
      dataVariableRegex      = /data((?!(\.[a-z_]\w*\(\)))\.[a-z_]\w*)+/gi,
      formatterCache         = {};

/**
 * An optional component (view) model for adding bindings to configs
 * @class Neo.model.Component
 * @extends Neo.core.Base
 */
class Component extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getStaticConfig() {return {
        /**
         * True automatically applies the core/Observable.mjs mixin
         * @member {Boolean} observable=true
         * @static
         */
        observable: true
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.model.Component'
         * @protected
         */
        className: 'Neo.model.Component',
        /**
         * @member {String} ntype='component-model'
         * @protected
         */
        ntype: 'component-model',
        /**
         * @member {Object|null} bindings_=null
         * @protected
         */
        bindings_: null,
        /**
         * @member {Boolean} cacheFormatterFunctions=true
         */
        cacheFormatterFunctions: true,
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Object|null} data_=null
         */
        data_: null,
        /**
         * @member {Object|null} stores_=null
         */
        stores_: null
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        Neo.currentWorker.isUsingViewModels = true;
        super(config);
        this.bindings = {};
    }

    /**
     * Adds a given key/value combination on this model level.
     * The method is used by setData() & setDataAtSameLevel()
     * in case the  data property does not exist yet.
     * @param {String} key
     * @param {*} value
     * @private
     */
    addDataProperty(key, value) {
        let me = this,
            data, scope;

        Neo.ns(key, true, me.data);

        data  = me.getDataScope(key);
        scope = data.scope;

        scope[data.key] = value;

        me.createDataProperties(me.data, 'data');
    }

    /**
     * Triggered after the data config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        if (value) {
            this.createDataProperties(value, 'data');
        }
    }

    /**
     * Triggered after the stores config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetStores(value, oldValue) {
        if (value) {
            console.log('afterSetStores', value);
        }
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return value || {};
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        if (value) {
            Object.entries(value).forEach(([key, storeValue]) => {
                value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__.default.beforeSetInstance(storeValue);
            });
        }

        return value;
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} key
     * @param {String} value
     * @param {String} formatter
     */
    createBinding(componentId, key, value, formatter) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            bindingScope, parentModel;

        if (scope[keyLeaf]) {
            bindingScope = Neo.ns(`${key}.${componentId}`, true, me.bindings);
            bindingScope[value] = formatter;
        } else {
            parentModel = me.getParent();

            if (parentModel) {
                parentModel.createBinding(componentId, key, value, formatter);
            } else {
                console.error('No model.Component found with the specified data property', value);
            }
        }
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise it will use the closest model with a match.
     * @param {String} componentId
     * @param {String} formatter
     * @param {String} value
     */
    createBindingByFormatter(componentId, formatter, value) {
        let me            = this,
            formatterVars = me.getFormatterVariables(formatter),
            data, keyLeaf, parentModel, scope;

        formatterVars.forEach(key => {
            data    = me.getDataScope(key);
            scope   = data.scope;
            keyLeaf = data.key;

            if (scope[keyLeaf]) {
                me.createBinding(componentId, key, value, formatter);
            } else {
                parentModel = me.getParent();

                if (parentModel) {
                    parentModel.createBinding(componentId, key, value, formatter);
                } else {
                    console.error('No model.Component found with the specified data property', value);
                }
            }
        });
    }

    /**
     *
     * @param {Neo.component.Base} component
     */
    createBindings(component) {
        Object.entries(component.bind).forEach(([key, value]) => {
            if (!this.isStoreValue(value)) {
                this.createBindingByFormatter(component.id, value, key);
            }
        });
    }

    /**
     *
     * @param {Object} config
     * @param {String} path
     */
    createDataProperties(config, path) {
        let me   = this,
            root = Neo.ns(path, false, me),
            descriptor, keyValue, newPath;

        Object.entries(config).forEach(([key, value]) => {
            if (!key.startsWith('_')) {
                descriptor = Object.getOwnPropertyDescriptor(root, key);
                newPath    = `${path}.${key}`

                if (!(typeof descriptor === 'object' && typeof descriptor.set === 'function')) {
                    keyValue = config[key];
                    me.createDataProperty(key, newPath, root);
                    root[key] = keyValue;
                }

                if (Neo.isObject(value)) {
                    me.createDataProperties(config[key], newPath);
                }
            }
        });
    }

    /**
     *
     * @param {String} key
     * @param {String} path
     * @param {Object} [root=this.data]
     */
    createDataProperty(key, path, root=this.data) {
        let me = this;

        if (path && path.startsWith('data.')) {
            path = path.substring(5);
        }

        Object.defineProperty(root, key, {
            get() {
                return root['_' + key];
            },

            set(value) {
                let _key     = `_${key}`,
                    oldValue = root[_key];

                if (!root[_key]) {
                    Object.defineProperty(root, _key, {
                        enumerable: false,
                        value     : value,
                        writable  : true
                    });
                } else {
                    root[_key] = value;
                }

                if (value !== oldValue) {
                    me.onDataPropertyChange(path ? path : key, value, oldValue);
                }
            }
        });
    }

    /**
     *
     * @param {String} key
     * @param {Neo.model.Component} [originModel=this] for internal usage only
     * @returns {*} value
     */
    getData(key, originModel=this) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            parentModel;

        if (scope.hasOwnProperty(keyLeaf)) {
            return scope[keyLeaf];
        }

        parentModel = me.getParent();

        if (!parentModel) {
            console.error(`data property '${key}' does not exist.`, originModel);
        }

        return parentModel.getData(key, originModel);
    }

    /**
     * Helper method to get the scope for a nested data property via Neo.ns() if needed.
     *
     * Example: passing the value 'foo.bar.baz' will return the bar object as the scope
     * and 'baz' as the key.
     * @param key
     * @returns {Object}
     */
    getDataScope(key) {
        let me      = this,
            keyLeaf = key,
            data    = me.data;

        if (key.includes('.')) {
            key     = key.split('.');
            keyLeaf = key.pop();
            data    = Neo.ns(key.join('.'), false, data);
        }

        return {
            key  : keyLeaf,
            scope: data
        };
    }

    /**
     * Extracts data variables from a given formatter string
     * @param {String} value
     */
    getFormatterVariables(value) {
        let parts  = value.match(expressionContentRegex) || [],
            result = [],
            dataVars;

        parts.forEach(part => {
            dataVars = part.match(dataVariableRegex) || [];

            dataVars.forEach(variable => {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.add(result, variable.substr(5)); // remove the "data." at the start
            })
        });

        result.sort();

        return result;
    }

    /**
     * Returns the merged data
     * @param {Object} data=this.getPlainData()
     * @returns {Object} data
     */
    getHierarchyData(data=this.getPlainData()) {
        let me     = this,
            parent = me.getParent();

        if (parent) {
            return {
                ...parent.getHierarchyData(data),
                ...me.getPlainData()
            };
        } else {
            return me.getPlainData();
        }
    }

    /**
     * Returns a plain version of this.data.
     * This excludes the property getters & setters.
     * @returns {Object}
     */
    getPlainData() {
        return JSON.parse(JSON.stringify(this.data));
    }

    /**
     * Get the closest model inside the components parent tree
     * @returns {Neo.model.Component|null}
     */
    getParent() {
        let parentId        = this.component.parentId,
            parentComponent = parentId && Neo.getComponent(parentId);

        return parentComponent && parentComponent.getModel() || null;
    }

    /**
     * Internal method to avoid code redundancy.
     * Use setData() or setDataAtSameLevel() instead.
     *
     * Passing an originModel param will try to set each key on the closest property match
     * inside the parent model chain => setData()
     * Not passing it will set all values on the model where the method gets called => setDataAtSameLevel()
     * @param {Object|String} key
     * @param {*} value
     * @param {Neo.model.Component} [originModel]
     * @protected
     */
    internalSetData(key, value, originModel) {
        let me = this,
            data, keyLeaf, parentModel, scope;

        if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originModel);
            });
        } else {
            data    = me.getDataScope(key);
            scope   = data.scope;
            keyLeaf = data.key;

            if (scope && scope.hasOwnProperty(keyLeaf)) {
                scope[keyLeaf] = value;
            } else {
                if (originModel) {
                    parentModel = me.getParent();

                    if (parentModel) {
                        parentModel.internalSetData(key, value, originModel);
                    } else {
                        originModel.addDataProperty(key, value);
                    }
                } else {
                    me.addDataProperty(key, value);
                }
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return value.startsWith('stores.');
    }

    /**
     *
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        let me      = this,
            binding = me.bindings && Neo.ns(key, false, me.bindings),
            component, config, hierarchyData, model;

        if (binding) {
            hierarchyData = {};

            Object.entries(binding).forEach(([componentId, configObject]) => {
                component = Neo.getComponent(componentId);
                config    = {};
                model     = component.getModel();

                if (!hierarchyData[model.id]) {
                    hierarchyData[model.id] = model.getHierarchyData();
                }

                Object.entries(configObject).forEach(([configField, formatter]) => {
                    // we can not call me.resolveFormatter(), since a data property inside a parent model
                    // could have changed which is relying on data properties inside a closer model
                    config[configField] = model.resolveFormatter(formatter, hierarchyData[model.id]);
                });

                if (component) {
                    component.set(config);
                }
            });
        }

        me.fire('dataPropertyChange', {
            key     : key,
            id      : me.id,
            oldValue: oldValue,
            value   : value
        });
    }

    /**
     * This method will assign binding values at the earliest possible point inside the component lifecycle.
     * It can not store bindings though, since child component ids most likely do not exist yet.
     * @param {Neo.component.Base} [component=this.component]
     */
    parseConfig(component=this.component) {
        let me = this;

        if (component.bind) {
            Object.entries(component.bind).forEach(([key, value]) => {
                if (me.isStoreValue(value)) {
                    me.resolveStore(component, key, value.substring(7)); // remove the "stores." at the start
                } else {
                    component[key] = me.resolveFormatter(value);
                }
            });
        }
    }

    /**
     * Removes all bindings for a given component id inside this model
     * as well as inside all parent models.
     * @param {String} componentId
     */
    removeBindings(componentId) {
        let me          = this,
            parentModel = me.getParent();

        Object.entries(me.bindings).forEach(([dataProperty, binding]) => {
            delete binding[componentId];
        });

        if (parentModel) {
            parentModel.removeBindings(componentId);
        }
    }

    /**
     *
     * @param {Neo.component.Base} [component=this.component]
     */
    resolveBindings(component=this.component) {
        let me = this;

        if (component.bind) {
            me.createBindings(component);

            Object.entries(component.bind).forEach(([key, value]) => {
                if (!me.isStoreValue(value)) { // bound stores already got resolved inside parseConfig()
                    component[key] = me.resolveFormatter(value);
                }
            });
        }
    }

    /**
     *
     * @param {String} formatter
     * @param {Object} [data=null] optionally pass this.getHierarchyData() for performance reasons
     */
    resolveFormatter(formatter, data=null) {
        let me = this,
            fn;

        if (!data) {
            data = this.getHierarchyData();
        }

        if (me.cacheFormatterFunctions && formatterCache[formatter]) {
            return formatterCache[formatter].call(me, data);
        }

        fn = new Function('data', 'return `' + formatter + '`;');

        if (me.cacheFormatterFunctions) {
            formatterCache[formatter] = fn;
        }

        return fn.call(me, data);
    }

    /**
     *
     * @param {Neo.component.Base} component
     * @param {String} configName
     * @param {String} storeName
     * @param {Neo.model.Component} [originModel=this] for internal usage only
     */
    resolveStore(component, configName, storeName, originModel=this) {
        let me = this,
            parentModel;

        if (!me.stores || !me.stores.hasOwnProperty(storeName)) {
            parentModel = me.getParent();

            if (parentModel) {
                parentModel.resolveStore(component, configName, storeName);
            } else {
                console.error('bound store not found inside this model or parents:', storeName, originModel);
            }
        } else {
            component[configName] = me.stores[storeName];
        }
    }

    /**
     * The method will assign all values to the closest model where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     * @param {Object|String} key
     * @param {*} value
     */
    setData(key, value) {
        this.internalSetData(key, value, this);
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent models.
     * @param {Object|String} key
     * @param {*} value
     */
    setDataAtSameLevel(key, value) {
        this.internalSetData(key, value);
    }
}

Neo.applyClassConfig(Component);



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tb2RlbC9Db21wb25lbnQubWpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBUztBQUNoQyx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVDK0M7QUFDTztBQUNOO0FBQ0s7O0FBRXJELG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBSTtBQUM1Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FB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QUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJjaHVua3MvYXBwL3ZlbmRvcnMtc3JjX2NvbnRhaW5lcl9WaWV3cG9ydF9tanMtc3JjX21vZGVsX0NvbXBvbmVudF9tanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udGFpbmVyLlZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLlZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3ZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3ZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyAnbmVvLWJvZHktdmlld3BvcnQnIHRvIHRoZSBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFwcGx5Qm9keUNscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsnbmVvLXZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8tdmlld3BvcnQnXVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBpZiAodGhpcy5hcHBseUJvZHlDbHMpIHtcbiAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5hcHBseUJvZHlDbHMoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWU6IHRoaXMuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjbHMgICAgOiBbJ25lby1ib2R5LXZpZXdwb3J0J11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhWaWV3cG9ydCk7XG5cbmV4cG9ydCB7Vmlld3BvcnQgYXMgZGVmYXVsdH07IiwiaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG5jb25zdCBleHByZXNzaW9uQ29udGVudFJlZ2V4ID0gL1xcJHsoLis/KX0vZyxcbiAgICAgIGRhdGFWYXJpYWJsZVJlZ2V4ICAgICAgPSAvZGF0YSgoPyEoXFwuW2Etel9dXFx3KlxcKFxcKSkpXFwuW2Etel9dXFx3KikrL2dpLFxuICAgICAgZm9ybWF0dGVyQ2FjaGUgICAgICAgICA9IHt9O1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIGNvbXBvbmVudCAodmlldykgbW9kZWwgZm9yIGFkZGluZyBiaW5kaW5ncyB0byBjb25maWdzXG4gKiBAY2xhc3MgTmVvLm1vZGVsLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS9PYnNlcnZhYmxlLm1qcyBtaXhpblxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgb2JzZXJ2YWJsZTogdHJ1ZVxuICAgIH19XG5cbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1vZGVsLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1vZGVsLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb21wb25lbnQtbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LW1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBiaW5kaW5nc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kaW5nc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjYWNoZUZvcm1hdHRlckZ1bmN0aW9ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBjYWNoZUZvcm1hdHRlckZ1bmN0aW9uczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF0YV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RvcmVzXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXNfOiBudWxsXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5pc1VzaW5nVmlld01vZGVscyA9IHRydWU7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZ2l2ZW4ga2V5L3ZhbHVlIGNvbWJpbmF0aW9uIG9uIHRoaXMgbW9kZWwgbGV2ZWwuXG4gICAgICogVGhlIG1ldGhvZCBpcyB1c2VkIGJ5IHNldERhdGEoKSAmIHNldERhdGFBdFNhbWVMZXZlbCgpXG4gICAgICogaW4gY2FzZSB0aGUgIGRhdGEgcHJvcGVydHkgZG9lcyBub3QgZXhpc3QgeWV0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSwgc2NvcGU7XG5cbiAgICAgICAgTmVvLm5zKGtleSwgdHJ1ZSwgbWUuZGF0YSk7XG5cbiAgICAgICAgZGF0YSAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KTtcbiAgICAgICAgc2NvcGUgPSBkYXRhLnNjb3BlO1xuXG4gICAgICAgIHNjb3BlW2RhdGEua2V5XSA9IHZhbHVlO1xuXG4gICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKG1lLmRhdGEsICdkYXRhJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXRhIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXRhKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRGF0YVByb3BlcnRpZXModmFsdWUsICdkYXRhJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0b3JlcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmVzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZnRlclNldFN0b3JlcycsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZGF0YSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RGF0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmVzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmVzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCBzdG9yZVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2Uoc3RvcmVWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYmluZGluZyBpbiBjYXNlIGEgbWF0Y2hpbmcgZGF0YSBwcm9wZXJ0eSBkb2VzIGV4aXN0LlxuICAgICAqIE90aGVyd2lzZSBpdCB3aWxsIHVzZSB0aGUgY2xvc2VzdCBtb2RlbCB3aXRoIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXR0ZXJcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nKGNvbXBvbmVudElkLCBrZXksIHZhbHVlLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpLFxuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGUsXG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXksXG4gICAgICAgICAgICBiaW5kaW5nU2NvcGUsIHBhcmVudE1vZGVsO1xuXG4gICAgICAgIGlmIChzY29wZVtrZXlMZWFmXSkge1xuICAgICAgICAgICAgYmluZGluZ1Njb3BlID0gTmVvLm5zKGAke2tleX0uJHtjb21wb25lbnRJZH1gLCB0cnVlLCBtZS5iaW5kaW5ncyk7XG4gICAgICAgICAgICBiaW5kaW5nU2NvcGVbdmFsdWVdID0gZm9ybWF0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50TW9kZWwuY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gbW9kZWwuQ29tcG9uZW50IGZvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBkYXRhIHByb3BlcnR5JywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGJpbmRpbmcgaW4gY2FzZSBhIG1hdGNoaW5nIGRhdGEgcHJvcGVydHkgZG9lcyBleGlzdC5cbiAgICAgKiBPdGhlcndpc2UgaXQgd2lsbCB1c2UgdGhlIGNsb3Nlc3QgbW9kZWwgd2l0aCBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXR0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nQnlGb3JtYXR0ZXIoY29tcG9uZW50SWQsIGZvcm1hdHRlciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZm9ybWF0dGVyVmFycyA9IG1lLmdldEZvcm1hdHRlclZhcmlhYmxlcyhmb3JtYXR0ZXIpLFxuICAgICAgICAgICAgZGF0YSwga2V5TGVhZiwgcGFyZW50TW9kZWwsIHNjb3BlO1xuXG4gICAgICAgIGZvcm1hdHRlclZhcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgZGF0YSAgICA9IG1lLmdldERhdGFTY29wZShrZXkpO1xuICAgICAgICAgICAgc2NvcGUgICA9IGRhdGEuc2NvcGU7XG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXk7XG5cbiAgICAgICAgICAgIGlmIChzY29wZVtrZXlMZWFmXSkge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUJpbmRpbmcoY29tcG9uZW50SWQsIGtleSwgdmFsdWUsIGZvcm1hdHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50TW9kZWwuY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBtb2RlbC5Db21wb25lbnQgZm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgcHJvcGVydHknLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LmJpbmQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU3RvcmVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJpbmRpbmdCeUZvcm1hdHRlcihjb21wb25lbnQuaWQsIHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqL1xuICAgIGNyZWF0ZURhdGFQcm9wZXJ0aWVzKGNvbmZpZywgcGF0aCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICByb290ID0gTmVvLm5zKHBhdGgsIGZhbHNlLCBtZSksXG4gICAgICAgICAgICBkZXNjcmlwdG9yLCBrZXlWYWx1ZSwgbmV3UGF0aDtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnXycpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocm9vdCwga2V5KTtcbiAgICAgICAgICAgICAgICBuZXdQYXRoICAgID0gYCR7cGF0aH0uJHtrZXl9YFxuXG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZXNjcmlwdG9yLnNldCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5VmFsdWUgPSBjb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlRGF0YVByb3BlcnR5KGtleSwgbmV3UGF0aCwgcm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3Rba2V5XSA9IGtleVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKGNvbmZpZ1trZXldLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtyb290PXRoaXMuZGF0YV1cbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhUHJvcGVydHkoa2V5LCBwYXRoLCByb290PXRoaXMuZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChwYXRoICYmIHBhdGguc3RhcnRzV2l0aCgnZGF0YS4nKSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDUpO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvb3QsIGtleSwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290WydfJyArIGtleV07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgX2tleSAgICAgPSBgXyR7a2V5fWAsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcm9vdFtfa2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICghcm9vdFtfa2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm9vdCwgX2tleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlICA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFtfa2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUub25EYXRhUHJvcGVydHlDaGFuZ2UocGF0aCA/IHBhdGggOiBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge05lby5tb2RlbC5Db21wb25lbnR9IFtvcmlnaW5Nb2RlbD10aGlzXSBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldERhdGEoa2V5LCBvcmlnaW5Nb2RlbD10aGlzKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KSxcbiAgICAgICAgICAgIHNjb3BlICAgPSBkYXRhLnNjb3BlLFxuICAgICAgICAgICAga2V5TGVhZiA9IGRhdGEua2V5LFxuICAgICAgICAgICAgcGFyZW50TW9kZWw7XG5cbiAgICAgICAgaWYgKHNjb3BlLmhhc093blByb3BlcnR5KGtleUxlYWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVba2V5TGVhZl07XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmICghcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRhdGEgcHJvcGVydHkgJyR7a2V5fScgZG9lcyBub3QgZXhpc3QuYCwgb3JpZ2luTW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudE1vZGVsLmdldERhdGEoa2V5LCBvcmlnaW5Nb2RlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBnZXQgdGhlIHNjb3BlIGZvciBhIG5lc3RlZCBkYXRhIHByb3BlcnR5IHZpYSBOZW8ubnMoKSBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOiBwYXNzaW5nIHRoZSB2YWx1ZSAnZm9vLmJhci5iYXonIHdpbGwgcmV0dXJuIHRoZSBiYXIgb2JqZWN0IGFzIHRoZSBzY29wZVxuICAgICAqIGFuZCAnYmF6JyBhcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERhdGFTY29wZShrZXkpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAga2V5TGVhZiA9IGtleSxcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5kYXRhO1xuXG4gICAgICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAga2V5ICAgICA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAga2V5TGVhZiA9IGtleS5wb3AoKTtcbiAgICAgICAgICAgIGRhdGEgICAgPSBOZW8ubnMoa2V5LmpvaW4oJy4nKSwgZmFsc2UsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSAgOiBrZXlMZWFmLFxuICAgICAgICAgICAgc2NvcGU6IGRhdGFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBkYXRhIHZhcmlhYmxlcyBmcm9tIGEgZ2l2ZW4gZm9ybWF0dGVyIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZvcm1hdHRlclZhcmlhYmxlcyh2YWx1ZSkge1xuICAgICAgICBsZXQgcGFydHMgID0gdmFsdWUubWF0Y2goZXhwcmVzc2lvbkNvbnRlbnRSZWdleCkgfHwgW10sXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGRhdGFWYXJzO1xuXG4gICAgICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICBkYXRhVmFycyA9IHBhcnQubWF0Y2goZGF0YVZhcmlhYmxlUmVnZXgpIHx8IFtdO1xuXG4gICAgICAgICAgICBkYXRhVmFycy5mb3JFYWNoKHZhcmlhYmxlID0+IHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQocmVzdWx0LCB2YXJpYWJsZS5zdWJzdHIoNSkpOyAvLyByZW1vdmUgdGhlIFwiZGF0YS5cIiBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC5zb3J0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXJnZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhPXRoaXMuZ2V0UGxhaW5EYXRhKClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZ2V0SGllcmFyY2h5RGF0YShkYXRhPXRoaXMuZ2V0UGxhaW5EYXRhKCkpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnQgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBhcmVudC5nZXRIaWVyYXJjaHlEYXRhKGRhdGEpLFxuICAgICAgICAgICAgICAgIC4uLm1lLmdldFBsYWluRGF0YSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmdldFBsYWluRGF0YSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBsYWluIHZlcnNpb24gb2YgdGhpcy5kYXRhLlxuICAgICAqIFRoaXMgZXhjbHVkZXMgdGhlIHByb3BlcnR5IGdldHRlcnMgJiBzZXR0ZXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0UGxhaW5EYXRhKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3QgbW9kZWwgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5tb2RlbC5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnRJZCAgICAgICAgPSB0aGlzLmNvbXBvbmVudC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCA9IHBhcmVudElkICYmIE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LmdldE1vZGVsKCkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gYXZvaWQgY29kZSByZWR1bmRhbmN5LlxuICAgICAqIFVzZSBzZXREYXRhKCkgb3Igc2V0RGF0YUF0U2FtZUxldmVsKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIFBhc3NpbmcgYW4gb3JpZ2luTW9kZWwgcGFyYW0gd2lsbCB0cnkgdG8gc2V0IGVhY2gga2V5IG9uIHRoZSBjbG9zZXN0IHByb3BlcnR5IG1hdGNoXG4gICAgICogaW5zaWRlIHRoZSBwYXJlbnQgbW9kZWwgY2hhaW4gPT4gc2V0RGF0YSgpXG4gICAgICogTm90IHBhc3NpbmcgaXQgd2lsbCBzZXQgYWxsIHZhbHVlcyBvbiB0aGUgbW9kZWwgd2hlcmUgdGhlIG1ldGhvZCBnZXRzIGNhbGxlZCA9PiBzZXREYXRhQXRTYW1lTGV2ZWwoKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudH0gW29yaWdpbk1vZGVsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSwgb3JpZ2luTW9kZWwpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEsIGtleUxlYWYsIHBhcmVudE1vZGVsLCBzY29wZTtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGtleSkuZm9yRWFjaCgoW2RhdGFLZXksIGRhdGFWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBtZS5pbnRlcm5hbFNldERhdGEoZGF0YUtleSwgZGF0YVZhbHVlLCBvcmlnaW5Nb2RlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KTtcbiAgICAgICAgICAgIHNjb3BlICAgPSBkYXRhLnNjb3BlO1xuICAgICAgICAgICAga2V5TGVhZiA9IGRhdGEua2V5O1xuXG4gICAgICAgICAgICBpZiAoc2NvcGUgJiYgc2NvcGUuaGFzT3duUHJvcGVydHkoa2V5TGVhZikpIHtcbiAgICAgICAgICAgICAgICBzY29wZVtrZXlMZWFmXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1vZGVsLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5Nb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5Nb2RlbC5hZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5hZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIGlmIGEgYmluZGluZyB2YWx1ZSBpcyBzdXBwb3NlZCB0byBtYXRjaCBhIHN0b3JlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdG9yZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zdGFydHNXaXRoKCdzdG9yZXMuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBiaW5kaW5nID0gbWUuYmluZGluZ3MgJiYgTmVvLm5zKGtleSwgZmFsc2UsIG1lLmJpbmRpbmdzKSxcbiAgICAgICAgICAgIGNvbXBvbmVudCwgY29uZmlnLCBoaWVyYXJjaHlEYXRhLCBtb2RlbDtcblxuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgaGllcmFyY2h5RGF0YSA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhiaW5kaW5nKS5mb3JFYWNoKChbY29tcG9uZW50SWQsIGNvbmZpZ09iamVjdF0pID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgICAgICBjb25maWcgICAgPSB7fTtcbiAgICAgICAgICAgICAgICBtb2RlbCAgICAgPSBjb21wb25lbnQuZ2V0TW9kZWwoKTtcblxuICAgICAgICAgICAgICAgIGlmICghaGllcmFyY2h5RGF0YVttb2RlbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5RGF0YVttb2RlbC5pZF0gPSBtb2RlbC5nZXRIaWVyYXJjaHlEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnT2JqZWN0KS5mb3JFYWNoKChbY29uZmlnRmllbGQsIGZvcm1hdHRlcl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIG5vdCBjYWxsIG1lLnJlc29sdmVGb3JtYXR0ZXIoKSwgc2luY2UgYSBkYXRhIHByb3BlcnR5IGluc2lkZSBhIHBhcmVudCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGNoYW5nZWQgd2hpY2ggaXMgcmVseWluZyBvbiBkYXRhIHByb3BlcnRpZXMgaW5zaWRlIGEgY2xvc2VyIG1vZGVsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tjb25maWdGaWVsZF0gPSBtb2RlbC5yZXNvbHZlRm9ybWF0dGVyKGZvcm1hdHRlciwgaGllcmFyY2h5RGF0YVttb2RlbC5pZF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuc2V0KGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5maXJlKCdkYXRhUHJvcGVydHlDaGFuZ2UnLCB7XG4gICAgICAgICAgICBrZXkgICAgIDoga2V5LFxuICAgICAgICAgICAgaWQgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgdmFsdWUgICA6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYXNzaWduIGJpbmRpbmcgdmFsdWVzIGF0IHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBwb2ludCBpbnNpZGUgdGhlIGNvbXBvbmVudCBsaWZlY3ljbGUuXG4gICAgICogSXQgY2FuIG5vdCBzdG9yZSBiaW5kaW5ncyB0aG91Z2gsIHNpbmNlIGNoaWxkIGNvbXBvbmVudCBpZHMgbW9zdCBsaWtlbHkgZG8gbm90IGV4aXN0IHlldC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gW2NvbXBvbmVudD10aGlzLmNvbXBvbmVudF1cbiAgICAgKi9cbiAgICBwYXJzZUNvbmZpZyhjb21wb25lbnQ9dGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoY29tcG9uZW50LmJpbmQpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbXBvbmVudC5iaW5kKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWUuaXNTdG9yZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5yZXNvbHZlU3RvcmUoY29tcG9uZW50LCBrZXksIHZhbHVlLnN1YnN0cmluZyg3KSk7IC8vIHJlbW92ZSB0aGUgXCJzdG9yZXMuXCIgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50W2tleV0gPSBtZS5yZXNvbHZlRm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGJpbmRpbmdzIGZvciBhIGdpdmVuIGNvbXBvbmVudCBpZCBpbnNpZGUgdGhpcyBtb2RlbFxuICAgICAqIGFzIHdlbGwgYXMgaW5zaWRlIGFsbCBwYXJlbnQgbW9kZWxzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqL1xuICAgIHJlbW92ZUJpbmRpbmdzKGNvbXBvbmVudElkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRNb2RlbCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1lLmJpbmRpbmdzKS5mb3JFYWNoKChbZGF0YVByb3BlcnR5LCBiaW5kaW5nXSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGJpbmRpbmdbY29tcG9uZW50SWRdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgIHBhcmVudE1vZGVsLnJlbW92ZUJpbmRpbmdzKGNvbXBvbmVudElkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IFtjb21wb25lbnQ9dGhpcy5jb21wb25lbnRdXG4gICAgICovXG4gICAgcmVzb2x2ZUJpbmRpbmdzKGNvbXBvbmVudD10aGlzLmNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQuYmluZCkge1xuICAgICAgICAgICAgbWUuY3JlYXRlQmluZGluZ3MoY29tcG9uZW50KTtcblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LmJpbmQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbWUuaXNTdG9yZVZhbHVlKHZhbHVlKSkgeyAvLyBib3VuZCBzdG9yZXMgYWxyZWFkeSBnb3QgcmVzb2x2ZWQgaW5zaWRlIHBhcnNlQ29uZmlnKClcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50W2tleV0gPSBtZS5yZXNvbHZlRm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YT1udWxsXSBvcHRpb25hbGx5IHBhc3MgdGhpcy5nZXRIaWVyYXJjaHlEYXRhKCkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICAgKi9cbiAgICByZXNvbHZlRm9ybWF0dGVyKGZvcm1hdHRlciwgZGF0YT1udWxsKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBmbjtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldEhpZXJhcmNoeURhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5jYWNoZUZvcm1hdHRlckZ1bmN0aW9ucyAmJiBmb3JtYXR0ZXJDYWNoZVtmb3JtYXR0ZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyQ2FjaGVbZm9ybWF0dGVyXS5jYWxsKG1lLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuID0gbmV3IEZ1bmN0aW9uKCdkYXRhJywgJ3JldHVybiBgJyArIGZvcm1hdHRlciArICdgOycpO1xuXG4gICAgICAgIGlmIChtZS5jYWNoZUZvcm1hdHRlckZ1bmN0aW9ucykge1xuICAgICAgICAgICAgZm9ybWF0dGVyQ2FjaGVbZm9ybWF0dGVyXSA9IGZuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZuLmNhbGwobWUsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWdOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLm1vZGVsLkNvbXBvbmVudH0gW29yaWdpbk1vZGVsPXRoaXNdIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICovXG4gICAgcmVzb2x2ZVN0b3JlKGNvbXBvbmVudCwgY29uZmlnTmFtZSwgc3RvcmVOYW1lLCBvcmlnaW5Nb2RlbD10aGlzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRNb2RlbDtcblxuICAgICAgICBpZiAoIW1lLnN0b3JlcyB8fCAhbWUuc3RvcmVzLmhhc093blByb3BlcnR5KHN0b3JlTmFtZSkpIHtcbiAgICAgICAgICAgIHBhcmVudE1vZGVsID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE1vZGVsLnJlc29sdmVTdG9yZShjb21wb25lbnQsIGNvbmZpZ05hbWUsIHN0b3JlTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2JvdW5kIHN0b3JlIG5vdCBmb3VuZCBpbnNpZGUgdGhpcyBtb2RlbCBvciBwYXJlbnRzOicsIHN0b3JlTmFtZSwgb3JpZ2luTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50W2NvbmZpZ05hbWVdID0gbWUuc3RvcmVzW3N0b3JlTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHdpbGwgYXNzaWduIGFsbCB2YWx1ZXMgdG8gdGhlIGNsb3Nlc3QgbW9kZWwgd2hlcmUgaXQgZmluZHMgYW4gZXhpc3Rpbmcga2V5LlxuICAgICAqIEluIGNhc2Ugbm8gbWF0Y2ggaXMgZm91bmQgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4sIGEgbmV3IGRhdGEgcHJvcGVydHkgd2lsbCBnZXQgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldERhdGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiBzZXREYXRhKCkgaW4gY2FzZSB5b3Ugd2FudCB0byBlbmZvcmNlXG4gICAgICogc2V0dGluZyBhbGwga2V5cyBvbiB0aGlzIGluc3RhbmNlIGluc3RlYWQgb2YgbG9va2luZyBmb3IgbWF0Y2hlcyBpbnNpZGUgcGFyZW50IG1vZGVscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXREYXRhQXRTYW1lTGV2ZWwoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlKTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbXBvbmVudCk7XG5cbmV4cG9ydCB7Q29tcG9uZW50IGFzIGRlZmF1bHR9OyJdLCJzb3VyY2VSb290IjoiIn0=