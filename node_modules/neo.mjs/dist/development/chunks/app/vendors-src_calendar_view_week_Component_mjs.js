(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_week_Component_mjs"],{

/***/ "./src/calendar/view/week/Component.mjs":
/*!**********************************************!*\
  !*** ./src/calendar/view/week/Component.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventDragZone.mjs */ "./src/calendar/view/week/EventDragZone.mjs");
/* harmony import */ var _EventResizable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventResizable.mjs */ "./src/calendar/view/week/EventResizable.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TimeAxisComponent.mjs */ "./src/calendar/view/week/TimeAxisComponent.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");








const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.week.Component
 * @extends Neo.component.Base
 */
class Component extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getStaticConfig() {return {
        /**
         * Valid values for timeAxisPosition
         * @member {String[]} timeAxisPositions=['end', 'start']
         * @protected
         * @static
         */
        timeAxisPositions: ['end', 'start']
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.Component'
         * @protected
         */
        className: 'Neo.calendar.view.week.Component',
        /**
         * @member {String} ntype='calendar-view-weekcomponent'
         * @protected
         */
        ntype: 'calendar-view-weekcomponent',
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            endTime             : data => data.endTime,
            eventBorder         : data => data.events.border,
            eventStore          : 'stores.events',
            intlFormat_time     : data => data.intlFormat_time,
            locale              : data => data.locale,
            minimumEventDuration: data => data.minimumEventDuration,
            showWeekends        : data => data.showWeekends,
            startTime           : data => data.startTime,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore_: null,
        /**
         * @member {String[]} cls=['neo-calendar-weekcomponent']
         */
        cls: ['neo-calendar-weekcomponent'],
        /**
         * Bound to the view model.
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='short'
         */
        dayNameFormat_: 'short',
        /**
         * Bound to the view model
         * @member {String|null} eventBorder_=null
         */
        eventBorder_: null,
        /**
         * @member {Neo.draggable.DragZone|null} eventDragZone=null
         */
        eventDragZone: null,
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         */
        eventStore_: null,
        /**
         * Will get passed from updateHeader()
         * @member {Date|null} firstColumnDate=null
         * @protected
         */
        firstColumnDate: null,
        /**
         * Internal flag to check if updateHeader(true) has already run
         * @member {Boolean} headerCreated=false
         * @protected
         */
        headerCreated: false,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * Bound to the view model.
         * @member {Intl.DateTimeFormat|null} intlFormat_time_=null
         * @protected
         */
        intlFormat_time_: null,
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false,
        /**
         * @member {Boolean} isUpdating=false
         * @protected
         */
        isUpdating: false,
        /**
         * Bound to the view model.
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * Time in minutes. Bound to the view model.
         * @member {Number} minimumEventDuration=30
         * @protected
         */
        minimumEventDuration: 30,
        /**
         * Internal flag to store if updateEvents() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Object} resizablePluginConfig=null
         */
        resizablePluginConfig: null,
        /**
         * @member {Boolean} showEventEndTime_=false
         */
        showEventEndTime_: false,
        /**
         * Bound to the view model.
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * @member {Object} timeAxis=null
         */
        timeAxis: null,
        /**
         * @member {Object} timeAxisConfig=null
         */
        timeAxisConfig: null,
        /**
         * Position the timeAxis at the left or right side.
         * Valid values are start & end.
         * start => left, end => right in LTR mode.
         * @member {String} timeAxisPosition_='start'
         */
        timeAxisPosition_: 'start',
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-scroll-overlay']},
            {cls: ['neo-c-w-scrollcontainer'], flag: 'neo-c-w-scrollcontainer', cn: [
                {cls: ['neo-header-row'], flag: 'neo-header-row', cn: []},
                {cls: ['neo-c-w-column-timeaxis-container'], flag: 'neo-c-w-column-timeaxis-container', cn: [
                    {cls: ['neo-c-w-column-container'], flag: 'neo-c-w-column-container', style: {}, cn: []}
                ]}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the view model.
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me               = this,
            domListeners     = me.domListeners,
            columnOpts       = {scope: me, delegate: '.neo-c-w-column'},
            eventOpts        = {scope: me, delegate: '.neo-event'},
            needsEventUpdate = false,
            plugins          = me.plugins || [];

        domListeners.push(
            {dblclick    : me.onEventDoubleClick, ...eventOpts},
            {'drag:end'  : me.onColumnDragEnd,    ...columnOpts},
            {'drag:end'  : me.onEventDragEnd,     ...eventOpts},
            {'drag:move' : me.onColumnDragMove,   ...columnOpts},
            {'drag:move' : me.onEventDragMove,    ...eventOpts},
            {'drag:start': me.onColumnDragStart,  ...columnOpts},
            {'drag:start': me.onEventDragStart,   ...eventOpts},
            {wheel       : me.onWheel,            scope: me}
        );

        me.domListeners = domListeners;

        plugins.push({
            module       : _EventResizable_mjs__WEBPACK_IMPORTED_MODULE_3__.default,
            appName      : me.appName,
            delegationCls: 'neo-event',
            directions   : ['b', 't'],
            flag         : 'resizable',
            ...me.resizablePluginConfig
        });

        me.plugins = plugins;

        me.timeAxis = Neo.create(_TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_5__.default, {
            appName  : me.appName,
            parentId : me.id,
            listeners: {
                change: me.onTimeAxisChange,
                scope : me
            },
            ...me.timeAxisConfig
        });

        me.getColumnTimeAxisContainer().cn[me.timeAxisPosition === 'start' ? 'unshift' : 'push'](me.timeAxis.vdom);

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {console.log('mehhhhh');
            needsEventUpdate = true
        }

        me.updateHeader(true, needsEventUpdate);

        needsEventUpdate && me.updateEvents(false);

        me.headerCreated = true;
    }

    /**
     * Adjusts drag events which start on an event resize handle
     * @param {Object} data
     * @returns {Object}
     */
    adjustResizeEvent(data) {
        data.path.shift();
        data.targetPath.shift();
        data.target = data.path[0];

        return data;
    }

    /**
     *
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     * @param {Boolean} [silent=false]
     */
    adjustTotalHeight(data, silent=false) {
        let me          = this,
            rowHeight   = data.rowHeight,
            rowsPerItem = data.rowsPerItem,
            height      = data.totalHeight - rowHeight,
            vdom        = me.vdom,
            i           = 0,
            gradient    = [];

        for (; i < rowsPerItem; i++) {
            gradient.push(
                `var(--c-w-background-color) ${i * rowHeight + i}px`,
                `var(--c-w-background-color) ${(i + 1) * rowHeight + i}px`,
                'var(--c-w-border-color) 0'
            );
        }

        Object.assign(me.getColumnContainer().style, {
            backgroundImage: `linear-gradient(${gradient.join(',')})`,
            backgroundSize : `1px ${rowsPerItem * rowHeight + rowsPerItem}px`,
            height         : `${height}px`,
            maxHeight      : `${height}px`
        });

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this;

        oldValue?.un({
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        });

        value?.on({
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        });
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        if (this.isConstructed) {
            this.updateHeader(false, true);
            this.updateEvents();
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});

        if (oldValue) {
            me.updateHeader();
        }
    }

    /**
     * Triggered after the eventBorder config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetEventBorder(value, oldValue) {
        let me  = this,
            cls = me.cls;

        oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__.default.remove(cls, `neo-event-border-${oldValue}`);
        value    && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__.default.add(   cls, `neo-event-border-${value}`);

        me.cls = cls;
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this;

        oldValue?.un('load', me.onEventStoreLoad, me);
        value   ?.on('load', me.onEventStoreLoad, me);
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.intlFormat_day  = new Intl.DateTimeFormat(value, {weekday: me.dayNameFormat});

            me.updateHeader();
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (me.needsEventUpdate) {
            me.updateEvents();
        }

        if (value) {
            setTimeout(() => {
                Neo.main.DomAccess.getBoundingClientRect({
                    id: me.getColumnContainer().id
                }).then(data => {
                    Neo.main.DomAccess.scrollBy({
                        direction: 'left',
                        id       : me.getScrollContainer().id,
                        value    : data.width / 3
                    });
                });
            }, 20);
        }
    }

    /**
     * Triggered after the showEventEndTime config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowEventEndTime(value, oldValue) {
        if (oldValue !== undefined) {
            this.updateEvents();
        }
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__.default[value ? 'add' : 'remove'](cls, 'neo-show-weekends');

        me._cls = cls; // silent update

        if (oldValue !== undefined) {
            me.updateHeader(false, true);
            me.updateEvents();
        }
    }

    /**
     * Triggered after the timeAxisPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTimeAxisPosition(value, oldValue) {
        let me                = this,
            cls               = me.cls,
            vdom              = me.vdom,
            timeAxisContainer = me.getColumnTimeAxisContainer();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__.default[value === 'end' ? 'add' : 'remove'](cls, 'neo-timeaxis-end');

        if (oldValue !== undefined) {
            timeAxisContainer.cn.unshift(timeAxisContainer.cn.pop()); // switch the order of the 2 items
        }

        me._cls = cls;
        me.vdom = vdom;
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        if (oldValue !== undefined) {
            this.updateHeader(false, true);
            this.updateEvents();
        }
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.prototype.dayNameFormats);
    }

    /**
     * Triggered before the timeAxisPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTimeAxisPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'timeAxisPosition');
    }

    /**
     * Triggered before the weekStartDay config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetWeekStartDay(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'weekStartDay', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.prototype.weekStartDays);
    }

    /**
     *
     * @param {Date} date
     * @returns {Object}
     */
    createColumnAndHeader(date) {
        let me          = this,
            columnCls   = ['neo-c-w-column', 'neo-draggable'],
            currentDate = date.getDate(),
            currentDay  = date.getDay(),
            dateCls     = ['neo-date'],
            removeDom   = false,
            column, header;

        if (currentDay === 0 || currentDay === 6) {
            columnCls.push('neo-weekend');

            if (!me.showWeekends) {
                removeDom = true;
            }
        }

        if (currentDate        === today.day   &&
            date.getMonth()    === today.month &&
            date.getFullYear() === today.year) {
            dateCls.push('neo-today');
        }

        column = {
            cls      : columnCls,
            flag     : _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.convertToyyyymmdd(date),
            removeDom: removeDom
        };

        header =
        {cls: ['neo-header-row-item'], removeDom: removeDom, cn: [
            {cls: ['neo-day'], html: me.intlFormat_day.format(date)},
            {cls: dateCls,     html: currentDate}
        ]};

        return {
            column: column,
            header: header
        };
    }

    /**
     *
     */
    destroy(...args) {
        this.timeAxis = null;

        super.destroy(...args);
    }

    /**
     *
     */
    getColumnContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__.default.getByFlag(this.vdom, 'neo-c-w-column-container');
    }

    /**
     *
     * @param {Date} date
     * @returns {String}
     */
    getColumnId(date) {
        return `${this.id}_col_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.convertToyyyymmdd(date)}`;
    }

    /**
     *
     * @param {Date} date
     * @returns {String}
     */
    getColumnHeaderId(date) {
        return `${this.id}_ch_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.convertToyyyymmdd(date)}`;
    }

    /**
     *
     */
    getColumnTimeAxisContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__.default.getByFlag(this.vdom, 'neo-c-w-column-timeaxis-container');
    }

    /**
     *
     */
    getHeaderContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__.default.getByFlag(this.vdom, 'neo-header-row');
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * @returns {String}
     */
    getIdKey() {
        return 'c-w';
    }

    /**
     *
     */
    getScrollContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__.default.getByFlag(this.vdom, 'neo-c-w-scrollcontainer');
    }

    /**
     *
     * @param {Object} eventData
     * @returns {Boolean}
     */
    isTopLevelColumn(eventData) {
        return eventData.path[0].cls.includes('neo-c-w-column');
    }

    /**
     *
     * @param {Object} eventData
     * @returns {Boolean}
     */
    isTopLevelEvent(eventData) {
        return eventData.path[0].cls.includes('neo-event');
    }

    /**
     *
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.updateEvents();
    }

    /**
     *
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.updateEvents();
    }

    /**
     *
     * @param {Object} data
     */
    onColumnDragEnd(data) {
        if (this.isTopLevelColumn(data)) {
            console.log('onColumnDragEnd', data);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onColumnDragMove(data) {
        if (this.isTopLevelColumn(data)) {
            console.log('onColumnDragMove', data);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onColumnDragStart(data) {
        if (this.isTopLevelColumn(data)) {
            console.log('onColumnDragStart', data);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onEventDoubleClick(data) {
        if (this.data.events.enableEdit) {
            if (!data.path[0].cls.includes('neo-event')) {
                data.path.shift();
            }

            let me                 = this,
                editEventContainer = me.owner.editEventContainer,
                eventNode          = data.path[0],
                eventVdom          = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__.default.findVdomChild(me.vdom, eventNode.id).vdom,
                record             = me.eventStore.get(eventVdom.flag),
                style              = editEventContainer.style;

            Object.assign(style, {
                left: `${eventNode.rect.width + 15}px`,
                top : eventVdom.style.top
            });

            editEventContainer.setSilent({
                currentView: me,
                parentId   : data.path[1].id,
                record     : record,
                style      : style
            });

            editEventContainer.render(true);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onEventDragEnd(data) {
        if (this.data.events.enableDrag) {
            let me = this;

            me.eventDragZone.dragEnd();

            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data);
                me.getPlugin({flag:'resizable'}).onDragEnd(data);
            } else {
                me.eventDragZone.removeBodyCursorCls();
            }

            me.isDragging = false;
        }
    }

    /**
     *
     * @param {Object} data
     */
    onEventDragMove(data) {
        if (this.data.events.enableDrag) {
            let me = this;

            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data);
            }

            me.eventDragZone.dragMove(data);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onEventDragStart(data) {
        if (this.data.events.enableDrag) {
            let me              = this,
                eventDragZone   = me.eventDragZone,
                isTopLevelEvent = me.isTopLevelEvent(data),
                dragElement, timeAxis;

            if (!isTopLevelEvent) {
                data = me.adjustResizeEvent(data);
            }

            dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__.default.findVdomChild(me.vdom, data.path[0].id).vdom;
            timeAxis    = me.timeAxis;

            me.isDragging = true;

            const config = {
                axisEndTime                     : timeAxis.getTime(me.endTime),
                axisStartTime                   : timeAxis.getTime(me.startTime),
                dragElement                     : dragElement,
                enableResizingAcrossOppositeEdge: me.data.events.enableResizingAcrossOppositeEdge,
                eventRecord                     : me.eventStore.get(dragElement.flag),
                proxyParentId                   : data.path[1].id
            };

            if (!eventDragZone) {
                me.eventDragZone = eventDragZone = Neo.create({
                    module           : _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__.default,
                    appName          : me.appName,
                    owner            : me,
                    scrollContainerId: me.getScrollContainer().id,
                    ...config,

                    dragProxyConfig: {
                        style: {
                            transition: 'none',
                            willChange: 'height'
                        }
                    }
                });
            } else {
                eventDragZone.set(config);
            }

            if (isTopLevelEvent) {
                eventDragZone.addBodyCursorCls();
            } else {
                me.getPlugin({flag:'resizable'}).onDragStart(data);
            }

            eventDragZone.dragStart(data);
        }
    }

    /**
     *
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.updateEvents();
    }

    /**
     *
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @param {Object[]} data.path
     */
    onFocusChange(data) {
        let oldPath = data.oldPath,
            path    = data.path;

        if (oldPath) {
            if (oldPath[0]?.cls.includes('neo-event')) {
                Neo.applyDeltas(this.appName, {id: oldPath[0].id, cls: {remove: ['neo-focus']}});
            }
        }

        if (path) {
            if (path[0]?.cls.includes('neo-event')) {
                Neo.applyDeltas(this.appName, {id: path[0].id, cls: {add: ['neo-focus']}});
            }
        }
    }

    /**
     *
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     */
    onTimeAxisChange(data) {
        let me = this;

        me.adjustTotalHeight(data, me.headerCreated);

        if (me.headerCreated) {
            me.updateEvents();
        }
    }

    /**
     *
     * @param {Object} data
     */
    onWheel(data) {
        if (!this.isUpdating && Math.abs(data.deltaX) > Math.abs(data.deltaY)) {
            let me              = this,
                columns         = me.getColumnContainer(),
                firstColumnDate = me.firstColumnDate,
                header          = me.getHeaderContainer(),
                i               = 0,
                timeAxisWidth   = 50,
                width           = data.clientWidth - timeAxisWidth,
                config, date, scrollValue;

            // console.log(data.scrollLeft, Math.round(data.scrollLeft / (data.clientWidth - timeAxisWidth) * 7));

            if (data.deltaX > 0 && Math.round(data.scrollLeft / width * 7) > 13) {
                date = new Date(columns.cn[columns.cn.length - 1].flag);

                columns.cn.splice(0, 7);
                header .cn.splice(0, 7);

                for (; i < 7; i++) {
                    date.setDate(date.getDate() + 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.push(config.column);
                    header .cn.push(config.header);
                }

                firstColumnDate.setDate(firstColumnDate.getDate() + 7);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                setTimeout(() => {
                    me.updateEvents(false, 14, 21);
                }, 50);

                scrollValue = -width;
            }

            else if (data.deltaX < 0 && Math.round(data.scrollLeft / width * 7) < 1) {
                date = new Date(columns.cn[0].flag);

                columns.cn.length = 14;
                header .cn.length = 14;

                for (; i < 7; i++) {
                    date.setDate(date.getDate() - 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.unshift(config.column);
                    header .cn.unshift(config.header);
                }

                firstColumnDate.setDate(firstColumnDate.getDate() - 7);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                setTimeout(() => {
                    me.updateEvents(false, 0, 7);
                }, 50);

                scrollValue = width;
            }

            if (scrollValue) {
                me.isUpdating = true;

                me.promiseVdomUpdate().then(() => {
                    Neo.main.DomAccess.scrollBy({
                        direction: 'left',
                        id       : me.getScrollContainer().id,
                        value    : scrollValue
                    }).then(() => {
                        me.isUpdating = false;
                    });
                });
            }
        }
    }

    /**
     * The algorithm relies on the eventStore being sorted by startDate ASC
     * @param {Boolean} [silent=false]
     * @param {Number} [startIndex=0]
     * @param {Number} [endIndex=21]
     */
    updateEvents(silent=false, startIndex=0, endIndex=21) {
        let me                = this,
            calendarStore     = me.calendarStore,
            eventStore        = me.eventStore,
            timeAxis          = me.timeAxis,
            endTime           = timeAxis.getTime(me.endTime),
            startTime         = timeAxis.getTime(me.startTime),
            totalTime         = endTime - startTime,
            date              = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.clone(me.firstColumnDate),
            vdom              = me.vdom,
            content           = me.getColumnContainer(),
            j                 = startIndex,
            showEventEndTime  = me.showEventEndTime,
            calendarRecord, column, dayRecords, duration, endDate, eventCls, eventIntervals, hasOverflow, height, i,
            len, record, recordKey, startDate, startHours, top;

        me.needsEventUpdate = !me.mounted;

        date.setDate(date.getDate() + startIndex);

        for (; j < endIndex; j++) {
            column = content.cn[j];

            column.cn = []; // remove previous events from the vdom

            dayRecords = eventStore.getDayRecords(date);
            len        = dayRecords.length;

            for (i = 0; i < len; i++) {
                record         = dayRecords[i];
                calendarRecord = calendarStore.get(record.calendarId);

                if (calendarRecord?.active) {
                    endDate   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.clone(record.endDate);
                    startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.clone(record.startDate);

                    if (endTime <= startDate.getHours()) {
                        continue;
                    }

                    if (startTime >= endDate.getHours()) {
                        continue;
                    }

                    if (endTime < endDate.getHours()) {
                        endDate.setHours(endTime);
                        endDate.setMinutes(0);
                    }

                    if (startTime > startDate.getHours()) {
                        startDate.setHours(startTime);
                        startDate.setMinutes(0);
                    }

                    duration       = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                    eventCls       = ['neo-event', 'neo-draggable', `neo-${calendarRecord.color}`];
                    eventIntervals = duration * 60 / timeAxis.interval;
                    hasOverflow    = false;
                    height         = Math.round(duration / totalTime * 100 * 1000) / 1000;
                    recordKey      = record[eventStore.keyProperty];
                    startHours     = (startDate.getHours() * 60 + startDate.getMinutes()) / 60;
                    top            = Math.round((startHours - startTime) / totalTime * 100 * 1000) / 1000;

                    if (eventIntervals <= 2) {
                        hasOverflow = timeAxis.rowHeight * eventIntervals < (showEventEndTime ? 50 : 34);

                        if (hasOverflow && !(showEventEndTime && (timeAxis.rowHeight / eventIntervals >= 34))) {
                            eventCls.push('neo-overflow');
                        }
                    }

                    showEventEndTime = !(hasOverflow && eventIntervals === 1 || !showEventEndTime);

                    showEventEndTime && eventCls.push('neo-show-end-time');

                    column.cn.push({
                        cls     : eventCls,
                        flag    : recordKey,
                        id      : me.id + '__' + recordKey,
                        tabIndex: -1,

                        cn: [{
                            cls : ['neo-event-time'],
                            html: me.intlFormat_time.format(record.startDate),
                            id  : me.id + '__time__' + recordKey
                        }, {
                            cls : ['neo-event-title'],
                            html: record.title,
                            id  : me.id + '__title__' + recordKey
                        }, {
                            cls      : ['neo-event-time', 'neo-event-end-time'],
                            html     : me.intlFormat_time.format(record.endDate),
                            id       : me.id + '__enddate__' + recordKey,
                            removeDom: !showEventEndTime
                        }],

                        style: {
                            height: `calc(${height}% - 2px)`,
                            top   : `calc(${top}% + 1px)`,
                            width : 'calc(100% - 1px)'
                        }
                    });
                }
            }

            date.setDate(date.getDate() + 1);
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     *
     * @param {Boolean} [create=false]
     * @param {Boolean} [silent=false]
     */
    updateHeader(create=false, silent=false) {
        let me           = this,
            date         = me.currentDate, // cloned
            vdom         = me.vdom,
            content      = me.getColumnContainer(),
            header       = me.getHeaderContainer(),
            i            = 0,
            showWeekends = me.showWeekends,
            columnCls, currentDate, currentDay, dateCls, headerId, removeDom;

        date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay - 7);

        me.firstColumnDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.clone(date);

        for (; i < 21; i++) {
            columnCls   = ['neo-c-w-column', 'neo-draggable'];
            currentDate = date.getDate();
            currentDay  = date.getDay();
            dateCls     = ['neo-date'];
            removeDom   = false;

            if (currentDay === 0 || currentDay === 6) {
                columnCls.push('neo-weekend');

                if (!showWeekends) {
                    removeDom = true;
                }
            }

            if (currentDate        === today.day   &&
                date.getMonth()    === today.month &&
                date.getFullYear() === today.year) {
                dateCls.push('neo-today');
            }

            headerId = me.getColumnHeaderId(date);

            if (create) {
                content.cn.push({
                    cls      : columnCls,
                    flag     : _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.convertToyyyymmdd(date),
                    id       : me.getColumnId(date),
                    removeDom: removeDom
                });

                header.cn.push({
                    cls      : ['neo-header-row-item'],
                    id       : headerId,
                    removeDom: removeDom,

                    cn: [{
                        cls : ['neo-day'],
                        html: me.intlFormat_day.format(date),
                        id  : `${headerId}_day`
                    }, {
                        cls : dateCls,
                        html: currentDate,
                        id  : `${headerId}_date`
                    }]
                });
            } else {
                Object.assign(content.cn[i], {
                    cls      : columnCls,
                    flag     : _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.convertToyyyymmdd(date),
                    id       : me.getColumnId(date),
                    removeDom: removeDom
                });

                Object.assign(header.cn[i], {
                    id       : headerId,
                    removeDom: removeDom
                });

                Object.assign(header.cn[i].cn[0], {
                    html: me.intlFormat_day.format(date),
                    id  : `${headerId}_day`
                });

                Object.assign(header.cn[i].cn[1], {
                    cls : dateCls,
                    html: currentDate,
                    id  : `${headerId}_date`
                });
            }

            date.setDate(date.getDate() + 1);
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }
}

Neo.applyClassConfig(Component);




/***/ }),

/***/ "./src/calendar/view/week/EventDragZone.mjs":
/*!**************************************************!*\
  !*** ./src/calendar/view/week/EventDragZone.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventDragZone)
/* harmony export */ });
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../draggable/DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.calendar.view.week.EventDragZone
 * @extends Neo.draggable.DragZone
 */
class EventDragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.EventDragZone'
         * @protected
         */
        className: 'Neo.calendar.view.week.EventDragZone',
        /**
         * @member {String} ntype='calendar-week-event-dragzone'
         * @protected
         */
        ntype: 'calendar-week-event-dragzone',
        /**
         * @member {Boolean} addDragProxyCls=false
         */
        addDragProxyCls: false,
        /**
         * @member {Boolean} enableResizingAcrossOppositeEdge=true
         */
        enableResizingAcrossOppositeEdge: true,
        /**
         * @member {Number} axisEndTime=0
         */
        axisEndTime: 0,
        /**
         * @member {Number} axisStartTime=0
         */
        axisStartTime: 0,
        /**
         * @member {Number} columnHeight=0
         */
        columnHeight: 0,
        /**
         * @member {Number} columnTop=0
         */
        columnTop: 0,
        /**
         * @member {Number} currentInterval=0
         */
        currentInterval: 0,
        /**
         * time in minutes
         * @member {Number} eventDuration=0
         */
        eventDuration: 0,
        /**
         * @member {Object} eventRecord=null
         */
        eventRecord: null,
        /**
         * Internal flag.
         * If we resize across the opposite edge and then back, we need to update the related edge position once.
         * @member {Boolean} forceUpdate=false
         * @protected
         */
        forceUpdate: false,
        /**
         * Internal flag
         * @member {Boolean} hasOverflow=false
         * @protected
         */
        hasOverflow: false,
        /**
         * time in minutes
         * @member {Number} intervalSize=15
         */
        intervalSize: 15,
        /**
         * @member {Boolean} keepEndDate=false
         */
        keepEndDate: false,
        /**
         * @member {Boolean} keepStartDate=false
         */
        keepStartDate: false,
        /**
         * @member {Boolean} moveHorizontal=false
         */
        moveHorizontal: false,
        /**
         * @member {Boolean} moveInMainThread=false
         */
        moveInMainThread: false,
        /**
         * Internal flag.
         * @member {Date} newEndDate=null
         * @protected
         */
        newEndDate: null,
        /**
         * Internal flag.
         * @member {Date} newStartDate=null
         * @protected
         */
        newStartDate: null,
        /**
         * @member {Number} scrollFactorLeft=3
         */
        scrollFactorLeft: 3,
        /**
         * @member {Boolean} useProxyWrapper=false
         */
        useProxyWrapper: false
    }}

    /**
     *
     */
    addBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {add: ['neo-cursor-move']}});
    }

    /**
     * Resolves the 24:00 issue, where an event would end on the next day
     * @param {Date} date
     * @returns {Date}
     */
    adjustEndDate(date) {
        if (date.getHours() === 0 && date.getMinutes() === 0) {
            // if an event ends at 24:00, change it to 23:59 => otherwise the day increases by 1
            date.setMinutes(date.getMinutes() - 1);
        } else if (!(date.getHours() === 23 && date.getMinutes() === 59) && date.getMinutes() % this.intervalSize !== 0) {
            // otherwise switch non interval based values back
            date.setMinutes(date.getMinutes() + 1);
        }

        return date;
    }

    /**
     * Triggered after the proxyParentId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetProxyParentId(value, oldValue) {
        if (value && oldValue !== undefined) {
            let me = this;

            // check if the node did not get removed yet
            if (me.dragProxy?.vdom.cn[0].id) {
                Neo.applyDeltas(me.appName, {
                    action  : 'moveNode',
                    id      : me.dragProxy.id,
                    index   : 0,
                    parentId: value
                });
            }
        }
    }

    /**
     *
     * @param {Object} data
     */
    createDragProxy(data) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            vdom      = me.dragProxyConfig?.vdom,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__.default.clone(vdom ? vdom : me.dragElement);

            clone.cn[2].removeDom = false;

        const config = {
            module          : _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.default,
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,

            ...me.dragProxyConfig,

            vdom: me.useProxyWrapper ? {cn: [clone]} : clone // we want to override dragProxyConfig.vdom if needed
        };

        config.cls = config.cls || [];

        config.cls.push('neo-focus');

        if (component) {
            config.cls.push(component.getTheme());
        }

        if (clone.cls && !me.useProxyWrapper) {
            config.cls.push(...clone.cls);
        }

        if (me.addDragProxyCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__.default.add(config.cls, me.dragProxyCls);
        }

        Object.assign(config.style, {
            height: `${data.height}px`,
            top   : `${data.y - me.columnTop}px`,
            width : `${data.width}px`
        });

        me.dragProxy = Neo.create(config);
    }

    /**
     * DragEnd equals drop, since we can only drag to valid positions
     * todo: ESC key
     * @param {Object} data
     */
    dragEnd(data) {
        super.dragEnd(data);

        let me     = this,
            owner  = me.owner,
            record = me.eventRecord,
            endDate, startDate;

        if (me.keepStartDate) {
            endDate   = me.newEndDate;
            startDate = me.newStartDate || record.startDate;
        } else {
            startDate = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__.default.findVdomChild(owner.vdom, me.proxyParentId).vdom.flag + 'T00:00:00');
            startDate.setHours(me.axisStartTime);
            startDate.setMinutes(me.currentInterval * me.intervalSize);

            if (me.keepEndDate) {
                endDate   = me.newEndDate   || record.endDate;
                startDate = me.newStartDate || startDate;
            } else {
                endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(startDate);
                endDate.setMinutes(endDate.getMinutes() + me.eventDuration);
            }
        }

        endDate = me.adjustEndDate(endDate);

        record.endDate   = endDate;
        record.startDate = startDate;

        Object.assign(me, {
            hasOverflow  : false,
            keepEndDate  : false,
            keepStartDate: false,
            newEndDate   : null,
            newStartDate : null,
            proxyParentId: null
        });

        // todo: updating a record field which is included inside a sorter should trigger collection.doSort()
        // see: https://github.com/neomjs/neo/issues/2392

        owner.getModel().getStore('events').doSort();
        owner.updateEvents();
    }

    /**
     *
     * @param {Object} data
     */
    dragMove(data) {
        let me              = this,
            axisEndTime     = me.axisEndTime,
            axisStartTime   = me.axisStartTime,
            columnHeight    = me.columnHeight,
            eventDuration   = me.eventDuration,
            i               = 0,
            intervalSize    = me.intervalSize,
            keepEndDate     = me.keepEndDate,
            keepStartDate   = me.keepStartDate,
            path            = data.targetPath,
            len             = path.length,
            owner           = me.owner,
            record          = me.eventRecord,
            switchDirection = false,
            timeAxis        = owner.timeAxis,
            axisStartDate, currentInterval, deltas, duration, endDate, eventIntervals, hasOverflow, height, intervalHeight,
            intervals, limitInterval, minimumEventIntervals, position, startDate, startInterval;

        if (me.dragProxy) {
            if (!keepEndDate && !keepStartDate) {
                for (; i < len; i++) {
                    if (path[i].cls.includes('neo-c-w-column')) {
                        me.proxyParentId = path[i].id;
                        break;
                    }
                }
            }

            intervals      = (axisEndTime - axisStartTime) * 60 / intervalSize; // 15 minutes each
            intervalHeight = columnHeight / intervals;

            position = Math.min(columnHeight, data.clientY - me.offsetY - me.columnTop);

            currentInterval = Math.floor(position / intervalHeight);

            endDate   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(record.endDate);
            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(record.startDate);

            // events can have a smaller start time than the axis min value.
            // resizing via the north handle needs to adjust the duration to honor this.
            if (keepEndDate) {
                if (axisStartTime > startDate.getHours()) {
                    startDate.setHours(axisStartTime);
                    startDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000; // duration in minutes
                }
            }

            // events can have a bigger end time than the axis max value.
            // resizing via the south handle needs to adjust the duration to honor this.
            if (keepStartDate) {
                if (axisEndTime < endDate.getHours()) {
                    endDate.setHours(axisEndTime);
                    endDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000; // duration in minutes
                }
            }

            if (!keepEndDate) {
                // events must not end after the last visible interval
                currentInterval = Math.min(currentInterval, intervals - (eventDuration / intervalSize));
            }

            deltas = [{
                id   : me.dragProxy.id,
                style: {}
            }];

            if (keepEndDate || keepStartDate) {
                axisStartDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(record.startDate);
                axisStartDate.setHours(axisStartTime);
                axisStartDate.setMinutes(0);

                minimumEventIntervals = owner.minimumEventDuration / intervalSize;
                startInterval         = (record.startDate - axisStartDate) / intervalSize / 60 / 1000;

                if (keepEndDate) {
                    limitInterval = startInterval + (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        if (me.forceUpdate && currentInterval > limitInterval -minimumEventIntervals && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return;
                        } else if (currentInterval >= limitInterval + minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(currentInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(limitInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                            deltas[0].style.top = `calc(${limitInterval * intervalHeight / columnHeight * 100}% + 1px)`;
                        } else {
                            me.forceUpdate  = false;
                            me.newStartDate = null;
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.min(currentInterval, limitInterval - minimumEventIntervals);
                    }

                } else if (keepStartDate) {
                    limitInterval = startInterval - (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        // events must not start before the first visible interval
                        currentInterval = Math.max(-(eventDuration / intervalSize), currentInterval);

                        if (currentInterval <= limitInterval - minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(eventDuration + limitInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(eventDuration + currentInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours

                            position = (eventDuration / intervalSize + currentInterval) * intervalHeight; // snap to valid intervals
                            position = position / columnHeight * 100;

                            deltas[0].style.top = `calc(${position}% + 1px)`;
                        } else if (me.forceUpdate && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return;
                        } else if (me.forceUpdate && currentInterval >= limitInterval + minimumEventIntervals) {
                            if (me.currentInterval !== currentInterval) {
                                me.forceUpdate  = false;
                                me.newStartDate = null;
                                deltas[0].style.top = `calc(${startInterval * intervalHeight / columnHeight * 100}% + 1px)`;
                            }
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.max(currentInterval, limitInterval + minimumEventIntervals);
                    }
                }
            }

            if (!keepStartDate) {
                // events must not start before the first visible interval
                currentInterval = Math.max(0, currentInterval);
            }

            if (me.currentInterval !== currentInterval) {
                if (!switchDirection) {
                    if (!keepEndDate) {
                        endDate.setHours(axisStartTime);
                        endDate.setMinutes(eventDuration + currentInterval * intervalSize);
                    }

                    if (keepStartDate) {
                        me.newEndDate = endDate;
                        duration = (endDate - record.startDate) / 60 / 60 / 1000; // duration in hours
                    } else {
                        startDate.setHours(axisStartTime);
                        startDate.setMinutes(currentInterval * intervalSize);

                        position = currentInterval * intervalHeight; // snap to valid intervals
                        position = position / columnHeight * 100;

                        deltas[0].style.top = `calc(${position}% + 1px)`;
                    }

                    if (keepEndDate) {
                        duration = (record.endDate - startDate) / 60 / 60 / 1000; // duration in hours
                    }
                }

                endDate = me.adjustEndDate(endDate);

                deltas.push({
                    id       : me.dragProxy.vdom.cn[2].id,
                    innerHTML: owner.intlFormat_time.format(endDate)
                });

                if (keepEndDate || keepStartDate) {
                    height = Math.round(duration / (axisEndTime - axisStartTime) * 100 * 1000) / 1000;
                    deltas[0].style.height = `calc(${height}% - 2px)`;
                }

                deltas.push({
                    id       : me.dragProxy.vdom.cn[0].id,
                    innerHTML: owner.intlFormat_time.format(startDate)
                });

                // check if the node got added yet
                if (me.dragProxy.vdom.cn[0].id) {
                    eventIntervals = (duration && duration * 60 || eventDuration) / timeAxis.interval;

                    if (eventIntervals <= 2) {
                        hasOverflow = timeAxis.rowHeight / eventIntervals < 25;

                        if (hasOverflow) {
                            if (!me.hasOverflow) {
                                deltas.push({
                                    id : me.dragProxy.id,
                                    cls: {add: ['neo-overflow']}
                                });

                                me.hasOverflow = true;
                            }
                        }
                    } else {
                        if (me.hasOverflow) {
                            deltas.push({
                                id : me.dragProxy.id,
                                cls: {remove: ['neo-overflow']}
                            });

                            me.hasOverflow = false;
                        }
                    }

                    Neo.applyDeltas(me.appName, deltas);
                }
            }

            me.currentInterval = currentInterval;
        }
    }

    /**
     *
     * @param {Object} data
     */
    dragStart(data) {
        let me = this,
            eventDuration, offsetX, offsetY;

        Neo.main.DomAccess.getBoundingClientRect({
            id: [me.getDragElementRoot().id, data.path[1].id]
        }).then(rects => {
            eventDuration = (me.eventRecord.endDate - me.eventRecord.startDate) / 60 / 1000;
            offsetX       = data.clientX - rects[0].left;
            offsetY       = data.clientY - rects[0].top;

            Object.assign(me, {
                columnHeight   : rects[1].height,
                columnTop      : rects[1].top,
                dragElementRect: rects[0],
                eventDuration  : Math.round(eventDuration / me.intervalSize) * me.intervalSize,
                offsetX        : offsetX,
                offsetY        : offsetY
            });

            me.createDragProxy(rects[0]);

            me.fire('dragStart', {
                dragElementRect: rects[0],
                id             : me.id,
                offsetX        : offsetX,
                offsetY        : offsetY
            });

            me.dragMove(data);
        });
    }

    /**
     *
     */
    removeBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {remove: ['neo-cursor-move']}});
    }
}

Neo.applyClassConfig(EventDragZone);




/***/ }),

/***/ "./src/calendar/view/week/EventResizable.mjs":
/*!***************************************************!*\
  !*** ./src/calendar/view/week/EventResizable.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventResizable)
/* harmony export */ });
/* harmony import */ var _plugin_Resizable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../plugin/Resizable.mjs */ "./src/plugin/Resizable.mjs");


/**
 * @class Neo.calendar.view.week.EventResizable
 * @extends Neo.container.Base
 */
class EventResizable extends _plugin_Resizable_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.EventResizable'
         * @protected
         */
        className: 'Neo.calendar.view.week.EventResizable'
    }}

    /**
     *
     * @param {Object} data
     */
    onDragEnd(data) {
        let me = this;

        me.isDragging = false;
        me.removeBodyCursorCls();
        me.removeAllNodes();
    }

    /**
     *
     * @param {Object} data
     */
    onDragMove(data) {

    }

    /**
     *
     * @param {Object} data
     */
    onDragStart(data) {
        let me = this;

        me.isDragging = true;
        me.addBodyCursorCls();
        me.owner.eventDragZone[me.currentNodeName === 'top' ? 'keepEndDate' : 'keepStartDate'] = true;
    }

    /**
     * Only show the resize handles in case dragging is enabled.
     * @param {Object} data
     */
    onMouseMove(data) {
        if (this.owner.data.events.enableDrag) {
            super.onMouseMove(data);
        }
    }
}

Neo.applyClassConfig(EventResizable);




/***/ }),

/***/ "./src/calendar/view/week/TimeAxisComponent.mjs":
/*!******************************************************!*\
  !*** ./src/calendar/view/week/TimeAxisComponent.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TimeAxisComponent)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.calendar.view.week.TimeAxisComponent
 * @extends Neo.container.Base
 */
class TimeAxisComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getStaticConfig() {return {
        /**
         * Valid values for interval
         * @member {Number[]} intervals=[15, 30, 60]
         * @protected
         * @static
         */
        intervals: [15, 30, 60]
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.TimeAxisComponent'
         * @protected
         */
        className: 'Neo.calendar.view.week.TimeAxisComponent',
        /**
         * @member {String} ntype='calendar-timeaxis'
         * @protected
         */
        ntype: 'calendar-timeaxis',
        /**
         * @member {Object} bind
         */
        bind: {
            endTime  : data => data.endTime,
            startTime: data => data.startTime
        },
        /**
         * @member {String[]} cls=['neo-calendar-timeaxis']
         */
        cls: ['neo-calendar-timeaxis'],
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         */
        endTime_: '24:00',
        /**
         * The time interval in minutes to display as rows.
         * Valid values: 15, 30, 60
         * @member {Number} interval_=30
         */
        interval_: 30,
        /**
         * @member {Number} rowHeight_=20
         */
        rowHeight_: 20,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         */
        startTime_: '00:00',
        /**
         * @member {Object} vdom
         */
        vdom:
        {style: {}}
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me = this;

        me.createItems();
        me.afterSetRowHeight(me.rowHeight, 0);
    }

    /**
     * Triggered after the endTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetEndTime(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            // todo: handle 24:00 as 23:59
            if (!value) {
                me._endTime = '24:00';
            }

            me.afterSetRowHeight(me.rowHeight, 0);
        }
    }

    /**
     * Triggered after the interval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInterval(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0);
        }
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (oldValue !== undefined && this.vdom.cn) {
            let me          = this,
                endTime     = me.getTime(me.endTime),
                startTime   = me.getTime(me.startTime),
                vdom        = me.vdom,
                rowHeight   = me.rowHeight,
                rowsPerItem = me.getRowsPerItem(),
                itemHeight  = rowsPerItem * rowHeight + rowsPerItem, // rowsPerItem * 1px borders
                totalHeight = rowHeight + ((endTime - startTime) * itemHeight),
                i, itemStyle;

            Object.assign(vdom.style, {
                backgroundImage    : `linear-gradient(var(--c-w-background-color) ${itemHeight - 1}px, var(--c-w-border-color) 1px)`,
                backgroundPositionY: `${-itemHeight + 1}px`,
                backgroundSize     : `0.4em ${itemHeight}px`,
                height             : `${totalHeight - rowHeight + 1}px`,
                maxHeight          : `${totalHeight - rowHeight + 1}px`
            });

            for (i=0; i < 25; i++) {
                itemStyle = {
                    height: `${itemHeight}px`
                };

                if (i === startTime) {
                    itemStyle.marginTop = `${-2 - rowHeight * (rowsPerItem === 1 ? 0.5 : rowsPerItem === 2 ? 1 : 2)}px`;
                } else {
                    delete itemStyle.marginTop;
                }

                vdom.cn[i].style = itemStyle;

                vdom.cn[i].removeDom = (i < startTime || i - 1 >= endTime);
            }

            // silent update: the view containing this component will trigger the vdom update
            me._vdom = vdom;

            me.fire('change', {
                component  : me,
                rowHeight  : rowHeight,
                rowsPerItem: rowsPerItem,
                totalHeight: totalHeight
            });
        }
    }

    /**
     * Triggered after the startTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetStartTime(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0);
        }
    }

    /**
     * Triggered before the interval config gets changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    beforeSetInterval(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'interval');
    }

    /**
     *
     */
    createItems() {
        let vdom = this.vdom,
            html, i;

        vdom.cn = [];

        for (i=0; i < 25; i++) {
            html = i === 24 ? '00:00' : (i < 10 ? '0' : '') + i + ':00';

            vdom.cn.push({
                cls  : ['neo-c-w-timeaxis-item'],
                cn   : [{html: html}]
            });
        }
    }

    /**
     * Calculates the amount of rows related to the interval config
     * @returns {Number}
     */
    getRowsPerItem() {
        return this.interval === 60 ? 1 : this.interval === 30 ? 2 : 4;
    }

    /**
     * Calculates the time for the end- or startTime
     * @param {String} value
     * @returns {Number}
     */
    getTime(value) {
        return value.split(':').map(Number)[0];
    }
}

Neo.applyClassConfig(TimeAxisComponent);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy93ZWVrL0V2ZW50RHJhZ1pvbmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy93ZWVrL0V2ZW50UmVzaXphYmxlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9UaW1lQXhpc0NvbXBvbmVudC5tanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDTDtBQUNIO0FBQ0M7QUFDRztBQUNBO0FBQ0Q7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQWE7QUFDckMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRC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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRixlQUFlO0FBQ25HLHdDQUF3QyxnQkFBZ0I7QUFDeEQsOENBQThDLFdBQVc7QUFDekQsd0NBQXdDLDRCQUE0QjtBQUNwRSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLGFBQWE7O0FBRWIscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSwrQkFBK0IsV0FBVztBQUMxQzs7QUFFQTtBQUNBLDZDQUE2Qyx1RUFBdUU7QUFDcEgsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVzQyIsImZpbGUiOiJjaHVua3MvYXBwL3ZlbmRvcnMtc3JjX2NhbGVuZGFyX3ZpZXdfd2Vla19Db21wb25lbnRfbWpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VDb21wb25lbnQgICAgIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgRGF0ZVV0aWwgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgRXZlbnREcmFnWm9uZSAgICAgZnJvbSAnLi9FdmVudERyYWdab25lLm1qcyc7XG5pbXBvcnQgRXZlbnRSZXNpemFibGUgICAgZnJvbSAnLi9FdmVudFJlc2l6YWJsZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUaW1lQXhpc0NvbXBvbmVudCBmcm9tICcuL1RpbWVBeGlzQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbmNvbnN0IHRvZGF5RGF0ZSA9IG5ldyBEYXRlKCk7XG5cbmNvbnN0IHRvZGF5ID0ge1xuICAgIGRheSAgOiB0b2RheURhdGUuZ2V0RGF0ZSgpLFxuICAgIG1vbnRoOiB0b2RheURhdGUuZ2V0TW9udGgoKSxcbiAgICB5ZWFyIDogdG9kYXlEYXRlLmdldEZ1bGxZZWFyKClcbn07XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgc3RhdGljIGdldFN0YXRpY0NvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGZvciB0aW1lQXhpc1Bvc2l0aW9uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB0aW1lQXhpc1Bvc2l0aW9ucz1bJ2VuZCcsICdzdGFydCddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGltZUF4aXNQb3NpdGlvbnM6IFsnZW5kJywgJ3N0YXJ0J11cbiAgICB9fVxuXG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjYWxlbmRhci12aWV3LXdlZWtjb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2FsZW5kYXItdmlldy13ZWVrY29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZSAgICAgICA6ICdzdG9yZXMuY2FsZW5kYXJzJyxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlICAgICAgICAgOiBkYXRhID0+IGRhdGEuY3VycmVudERhdGUsXG4gICAgICAgICAgICBlbmRUaW1lICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmVuZFRpbWUsXG4gICAgICAgICAgICBldmVudEJvcmRlciAgICAgICAgIDogZGF0YSA9PiBkYXRhLmV2ZW50cy5ib3JkZXIsXG4gICAgICAgICAgICBldmVudFN0b3JlICAgICAgICAgIDogJ3N0b3Jlcy5ldmVudHMnLFxuICAgICAgICAgICAgaW50bEZvcm1hdF90aW1lICAgICA6IGRhdGEgPT4gZGF0YS5pbnRsRm9ybWF0X3RpbWUsXG4gICAgICAgICAgICBsb2NhbGUgICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmxvY2FsZSxcbiAgICAgICAgICAgIG1pbmltdW1FdmVudER1cmF0aW9uOiBkYXRhID0+IGRhdGEubWluaW11bUV2ZW50RHVyYXRpb24sXG4gICAgICAgICAgICBzaG93V2Vla2VuZHMgICAgICAgIDogZGF0YSA9PiBkYXRhLnNob3dXZWVrZW5kcyxcbiAgICAgICAgICAgIHN0YXJ0VGltZSAgICAgICAgICAgOiBkYXRhID0+IGRhdGEuc3RhcnRUaW1lLFxuICAgICAgICAgICAgd2Vla1N0YXJ0RGF5ICAgICAgICA6IGRhdGEgPT4gZGF0YS53ZWVrU3RhcnREYXlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gY2FsZW5kYXJTdG9yZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY2FsZW5kYXJTdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsnbmVvLWNhbGVuZGFyLXdlZWtjb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ25lby1jYWxlbmRhci13ZWVrY29tcG9uZW50J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBjdXJyZW50RGF0ZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50RGF0ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBjb2x1bW4gaGVhZGVycy5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZTogbmFycm93LCBzaG9ydCAmIGxvbmdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkYXlOYW1lRm9ybWF0Xz0nc2hvcnQnXG4gICAgICAgICAqL1xuICAgICAgICBkYXlOYW1lRm9ybWF0XzogJ3Nob3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBldmVudEJvcmRlcl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRCb3JkZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS5EcmFnWm9uZXxudWxsfSBldmVudERyYWdab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50RHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IGV2ZW50U3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50U3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgcGFzc2VkIGZyb20gdXBkYXRlSGVhZGVyKClcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBmaXJzdENvbHVtbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmaXJzdENvbHVtbkRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIGNoZWNrIGlmIHVwZGF0ZUhlYWRlcih0cnVlKSBoYXMgYWxyZWFkeSBydW5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGVhZGVyQ3JlYXRlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJDcmVhdGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gaW50bEZvcm1hdF9kYXk9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X2RheTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfdGltZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X3RpbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNEcmFnZ2luZz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVXBkYXRpbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNVcGRhdGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsb2NhbGVfPU5lby5jb25maWcubG9jYWxlXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGVfOiBOZW8uY29uZmlnLmxvY2FsZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgaW4gbWludXRlcy4gQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWluaW11bUV2ZW50RHVyYXRpb249MzBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWluaW11bUV2ZW50RHVyYXRpb246IDMwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBzdG9yZSBpZiB1cGRhdGVFdmVudHMoKSBnb3QgY2FsbGVkIHdoaWxlIG5vdCBiZWluZyBtb3VudGVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG5lZWRzRXZlbnRVcGRhdGU9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmVlZHNFdmVudFVwZGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlc2l6YWJsZVBsdWdpbkNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemFibGVQbHVnaW5Db25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93RXZlbnRFbmRUaW1lXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0V2ZW50RW5kVGltZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dXZWVrZW5kc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1dlZWtlbmRzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdGltZUF4aXM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGltZUF4aXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRpbWVBeGlzQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVBeGlzQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gdGhlIHRpbWVBeGlzIGF0IHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmUgc3RhcnQgJiBlbmQuXG4gICAgICAgICAqIHN0YXJ0ID0+IGxlZnQsIGVuZCA9PiByaWdodCBpbiBMVFIgbW9kZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aW1lQXhpc1Bvc2l0aW9uXz0nc3RhcnQnXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lQXhpc1Bvc2l0aW9uXzogJ3N0YXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1zY3JvbGwtb3ZlcmxheSddfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWMtdy1zY3JvbGxjb250YWluZXInXSwgZmxhZzogJ25lby1jLXctc2Nyb2xsY29udGFpbmVyJywgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1oZWFkZXItcm93J10sIGZsYWc6ICduZW8taGVhZGVyLXJvdycsIGNuOiBbXX0sXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tYy13LWNvbHVtbi10aW1lYXhpcy1jb250YWluZXInXSwgZmxhZzogJ25lby1jLXctY29sdW1uLXRpbWVheGlzLWNvbnRhaW5lcicsIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWMtdy1jb2x1bW4tY29udGFpbmVyJ10sIGZsYWc6ICduZW8tYy13LWNvbHVtbi1jb250YWluZXInLCBzdHlsZToge30sIGNuOiBbXX1cbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwLTYgPT4gU3VuLVNhdFxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWVrU3RhcnREYXlfPTBcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtTdGFydERheV86IDBcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzICAgICA9IG1lLmRvbUxpc3RlbmVycyxcbiAgICAgICAgICAgIGNvbHVtbk9wdHMgICAgICAgPSB7c2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tYy13LWNvbHVtbid9LFxuICAgICAgICAgICAgZXZlbnRPcHRzICAgICAgICA9IHtzY29wZTogbWUsIGRlbGVnYXRlOiAnLm5lby1ldmVudCd9LFxuICAgICAgICAgICAgbmVlZHNFdmVudFVwZGF0ZSA9IGZhbHNlLFxuICAgICAgICAgICAgcGx1Z2lucyAgICAgICAgICA9IG1lLnBsdWdpbnMgfHwgW107XG5cbiAgICAgICAgZG9tTGlzdGVuZXJzLnB1c2goXG4gICAgICAgICAgICB7ZGJsY2xpY2sgICAgOiBtZS5vbkV2ZW50RG91YmxlQ2xpY2ssIC4uLmV2ZW50T3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkNvbHVtbkRyYWdFbmQsICAgIC4uLmNvbHVtbk9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25FdmVudERyYWdFbmQsICAgICAuLi5ldmVudE9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25Db2x1bW5EcmFnTW92ZSwgICAuLi5jb2x1bW5PcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzptb3ZlJyA6IG1lLm9uRXZlbnREcmFnTW92ZSwgICAgLi4uZXZlbnRPcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uQ29sdW1uRHJhZ1N0YXJ0LCAgLi4uY29sdW1uT3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkV2ZW50RHJhZ1N0YXJ0LCAgIC4uLmV2ZW50T3B0c30sXG4gICAgICAgICAgICB7d2hlZWwgICAgICAgOiBtZS5vbldoZWVsLCAgICAgICAgICAgIHNjb3BlOiBtZX1cbiAgICAgICAgKTtcblxuICAgICAgICBtZS5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnM7XG5cbiAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IEV2ZW50UmVzaXphYmxlLFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGRlbGVnYXRpb25DbHM6ICduZW8tZXZlbnQnLFxuICAgICAgICAgICAgZGlyZWN0aW9ucyAgIDogWydiJywgJ3QnXSxcbiAgICAgICAgICAgIGZsYWcgICAgICAgICA6ICdyZXNpemFibGUnLFxuICAgICAgICAgICAgLi4ubWUucmVzaXphYmxlUGx1Z2luQ29uZmlnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnBsdWdpbnMgPSBwbHVnaW5zO1xuXG4gICAgICAgIG1lLnRpbWVBeGlzID0gTmVvLmNyZWF0ZShUaW1lQXhpc0NvbXBvbmVudCwge1xuICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIGNoYW5nZTogbWUub25UaW1lQXhpc0NoYW5nZSxcbiAgICAgICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ubWUudGltZUF4aXNDb25maWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZ2V0Q29sdW1uVGltZUF4aXNDb250YWluZXIoKS5jblttZS50aW1lQXhpc1Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShtZS50aW1lQXhpcy52ZG9tKTtcblxuICAgICAgICBpZiAobWUuY2FsZW5kYXJTdG9yZS5nZXRDb3VudCgpID4gMCAmJiBtZS5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwKSB7Y29uc29sZS5sb2coJ21laGhoaGgnKTtcbiAgICAgICAgICAgIG5lZWRzRXZlbnRVcGRhdGUgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGVIZWFkZXIodHJ1ZSwgbmVlZHNFdmVudFVwZGF0ZSk7XG5cbiAgICAgICAgbmVlZHNFdmVudFVwZGF0ZSAmJiBtZS51cGRhdGVFdmVudHMoZmFsc2UpO1xuXG4gICAgICAgIG1lLmhlYWRlckNyZWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgZHJhZyBldmVudHMgd2hpY2ggc3RhcnQgb24gYW4gZXZlbnQgcmVzaXplIGhhbmRsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhZGp1c3RSZXNpemVFdmVudChkYXRhKSB7XG4gICAgICAgIGRhdGEucGF0aC5zaGlmdCgpO1xuICAgICAgICBkYXRhLnRhcmdldFBhdGguc2hpZnQoKTtcbiAgICAgICAgZGF0YS50YXJnZXQgPSBkYXRhLnBhdGhbMF07XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLmNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnJvd0hlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnJvd3NQZXJJdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudG90YWxIZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgYWRqdXN0VG90YWxIZWlnaHQoZGF0YSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByb3dIZWlnaHQgICA9IGRhdGEucm93SGVpZ2h0LFxuICAgICAgICAgICAgcm93c1Blckl0ZW0gPSBkYXRhLnJvd3NQZXJJdGVtLFxuICAgICAgICAgICAgaGVpZ2h0ICAgICAgPSBkYXRhLnRvdGFsSGVpZ2h0IC0gcm93SGVpZ2h0LFxuICAgICAgICAgICAgdmRvbSAgICAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgZ3JhZGllbnQgICAgPSBbXTtcblxuICAgICAgICBmb3IgKDsgaSA8IHJvd3NQZXJJdGVtOyBpKyspIHtcbiAgICAgICAgICAgIGdyYWRpZW50LnB1c2goXG4gICAgICAgICAgICAgICAgYHZhcigtLWMtdy1iYWNrZ3JvdW5kLWNvbG9yKSAke2kgKiByb3dIZWlnaHQgKyBpfXB4YCxcbiAgICAgICAgICAgICAgICBgdmFyKC0tYy13LWJhY2tncm91bmQtY29sb3IpICR7KGkgKyAxKSAqIHJvd0hlaWdodCArIGl9cHhgLFxuICAgICAgICAgICAgICAgICd2YXIoLS1jLXctYm9yZGVyLWNvbG9yKSAwJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUuZ2V0Q29sdW1uQ29udGFpbmVyKCkuc3R5bGUsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYGxpbmVhci1ncmFkaWVudCgke2dyYWRpZW50LmpvaW4oJywnKX0pYCxcbiAgICAgICAgICAgIGJhY2tncm91bmRTaXplIDogYDFweCAke3Jvd3NQZXJJdGVtICogcm93SGVpZ2h0ICsgcm93c1Blckl0ZW19cHhgLFxuICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgOiBgJHtoZWlnaHR9cHhgLFxuICAgICAgICAgICAgbWF4SGVpZ2h0ICAgICAgOiBgJHtoZWlnaHR9cHhgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNhbGVuZGFyU3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2FsZW5kYXJTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBvbGRWYWx1ZT8udW4oe1xuICAgICAgICAgICAgbG9hZCAgICAgICAgOiBtZS5vbkNhbGVuZGFyU3RvcmVMb2FkLFxuICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbHVlPy5vbih7XG4gICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uQ2FsZW5kYXJTdG9yZUxvYWQsXG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uQ2FsZW5kYXJTdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjdXJyZW50RGF0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtEYXRlfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnREYXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhlYWRlcihmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW50bEZvcm1hdF9kYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChtZS5sb2NhbGUsIHt3ZWVrZGF5OiB2YWx1ZX0pO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50Qm9yZGVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudEJvcmRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHM7XG5cbiAgICAgICAgb2xkVmFsdWUgJiYgTmVvQXJyYXkucmVtb3ZlKGNscywgYG5lby1ldmVudC1ib3JkZXItJHtvbGRWYWx1ZX1gKTtcbiAgICAgICAgdmFsdWUgICAgJiYgTmVvQXJyYXkuYWRkKCAgIGNscywgYG5lby1ldmVudC1ib3JkZXItJHt2YWx1ZX1gKTtcblxuICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBldmVudFN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgb2xkVmFsdWU/LnVuKCdsb2FkJywgbWUub25FdmVudFN0b3JlTG9hZCwgbWUpO1xuICAgICAgICB2YWx1ZSAgID8ub24oJ2xvYWQnLCBtZS5vbkV2ZW50U3RvcmVMb2FkLCBtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsb2NhbGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TG9jYWxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmludGxGb3JtYXRfZGF5ICA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHZhbHVlLCB7d2Vla2RheTogbWUuZGF5TmFtZUZvcm1hdH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVIZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm5lZWRzRXZlbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUV2ZW50cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3MuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG1lLmdldENvbHVtbkNvbnRhaW5lcigpLmlkXG4gICAgICAgICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5nZXRTY3JvbGxDb250YWluZXIoKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogZGF0YS53aWR0aCAvIDNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dFdmVudEVuZFRpbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93RXZlbnRFbmRUaW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd1dlZWtlbmRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd1dlZWtlbmRzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1zaG93LXdlZWtlbmRzJyk7XG5cbiAgICAgICAgbWUuX2NscyA9IGNsczsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVIZWFkZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRpbWVBeGlzUG9zaXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGltZUF4aXNQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgID0gbWUuY2xzLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgdGltZUF4aXNDb250YWluZXIgPSBtZS5nZXRDb2x1bW5UaW1lQXhpc0NvbnRhaW5lcigpO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID09PSAnZW5kJyA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby10aW1lYXhpcy1lbmQnKTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZUF4aXNDb250YWluZXIuY24udW5zaGlmdCh0aW1lQXhpc0NvbnRhaW5lci5jbi5wb3AoKSk7IC8vIHN3aXRjaCB0aGUgb3JkZXIgb2YgdGhlIDIgaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLl9jbHMgPSBjbHM7XG4gICAgICAgIG1lLnZkb20gPSB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2Vla1N0YXJ0RGF5IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdlZWtTdGFydERheSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGVhZGVyKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RGF5TmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RheU5hbWVGb3JtYXQnLCBEYXRlVXRpbC5wcm90b3R5cGUuZGF5TmFtZUZvcm1hdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHRpbWVBeGlzUG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRUaW1lQXhpc1Bvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAndGltZUF4aXNQb3NpdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHdlZWtTdGFydERheSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFdlZWtTdGFydERheSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3dlZWtTdGFydERheScsIERhdGVVdGlsLnByb3RvdHlwZS53ZWVrU3RhcnREYXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlQ29sdW1uQW5kSGVhZGVyKGRhdGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbkNscyAgID0gWyduZW8tYy13LWNvbHVtbicsICduZW8tZHJhZ2dhYmxlJ10sXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgY3VycmVudERheSAgPSBkYXRlLmdldERheSgpLFxuICAgICAgICAgICAgZGF0ZUNscyAgICAgPSBbJ25lby1kYXRlJ10sXG4gICAgICAgICAgICByZW1vdmVEb20gICA9IGZhbHNlLFxuICAgICAgICAgICAgY29sdW1uLCBoZWFkZXI7XG5cbiAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgY29sdW1uQ2xzLnB1c2goJ25lby13ZWVrZW5kJyk7XG5cbiAgICAgICAgICAgIGlmICghbWUuc2hvd1dlZWtlbmRzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGF0ZSAgICAgICAgPT09IHRvZGF5LmRheSAgICYmXG4gICAgICAgICAgICBkYXRlLmdldE1vbnRoKCkgICAgPT09IHRvZGF5Lm1vbnRoICYmXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHRvZGF5LnllYXIpIHtcbiAgICAgICAgICAgIGRhdGVDbHMucHVzaCgnbmVvLXRvZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2x1bW4gPSB7XG4gICAgICAgICAgICBjbHMgICAgICA6IGNvbHVtbkNscyxcbiAgICAgICAgICAgIGZsYWcgICAgIDogRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSksXG4gICAgICAgICAgICByZW1vdmVEb206IHJlbW92ZURvbVxuICAgICAgICB9O1xuXG4gICAgICAgIGhlYWRlciA9XG4gICAgICAgIHtjbHM6IFsnbmVvLWhlYWRlci1yb3ctaXRlbSddLCByZW1vdmVEb206IHJlbW92ZURvbSwgY246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWRheSddLCBodG1sOiBtZS5pbnRsRm9ybWF0X2RheS5mb3JtYXQoZGF0ZSl9LFxuICAgICAgICAgICAge2NsczogZGF0ZUNscywgICAgIGh0bWw6IGN1cnJlbnREYXRlfVxuICAgICAgICBdfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBoZWFkZXI6IGhlYWRlclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMudGltZUF4aXMgPSBudWxsO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5nZXRCeUZsYWcodGhpcy52ZG9tLCAnbmVvLWMtdy1jb2x1bW4tY29udGFpbmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbHVtbklkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X2NvbF8ke0RhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbHVtbkhlYWRlcklkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X2NoXyR7RGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldENvbHVtblRpbWVBeGlzQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZ2V0QnlGbGFnKHRoaXMudmRvbSwgJ25lby1jLXctY29sdW1uLXRpbWVheGlzLWNvbnRhaW5lcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZ2V0QnlGbGFnKHRoaXMudmRvbSwgJ25lby1oZWFkZXItcm93Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnNpZGUgY3JlYXRlSWQoKSBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBwYXNzZWQgdG8gdGhlIElkR2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWRLZXkoKSB7XG4gICAgICAgIHJldHVybiAnYy13JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFNjcm9sbENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LXNjcm9sbGNvbnRhaW5lcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVG9wTGV2ZWxDb2x1bW4oZXZlbnREYXRhKSB7XG4gICAgICAgIHJldHVybiBldmVudERhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1jLXctY29sdW1uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUb3BMZXZlbEV2ZW50KGV2ZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gZXZlbnREYXRhLnBhdGhbMF0uY2xzLmluY2x1ZGVzKCduZW8tZXZlbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVMb2FkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwICYmIHRoaXMudXBkYXRlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2FsZW5kYXJTdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29sdW1uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVG9wTGV2ZWxDb2x1bW4oZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkNvbHVtbkRyYWdFbmQnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbHVtbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUb3BMZXZlbENvbHVtbihkYXRhKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ29uQ29sdW1uRHJhZ01vdmUnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbHVtbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVG9wTGV2ZWxDb2x1bW4oZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkNvbHVtbkRyYWdTdGFydCcsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnREb3VibGVDbGljayhkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZXZlbnRzLmVuYWJsZUVkaXQpIHtcbiAgICAgICAgICAgIGlmICghZGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyID0gbWUub3duZXIuZWRpdEV2ZW50Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGV2ZW50Tm9kZSAgICAgICAgICA9IGRhdGEucGF0aFswXSxcbiAgICAgICAgICAgICAgICBldmVudFZkb20gICAgICAgICAgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG1lLnZkb20sIGV2ZW50Tm9kZS5pZCkudmRvbSxcbiAgICAgICAgICAgICAgICByZWNvcmQgICAgICAgICAgICAgPSBtZS5ldmVudFN0b3JlLmdldChldmVudFZkb20uZmxhZyksXG4gICAgICAgICAgICAgICAgc3R5bGUgICAgICAgICAgICAgID0gZWRpdEV2ZW50Q29udGFpbmVyLnN0eWxlO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogYCR7ZXZlbnROb2RlLnJlY3Qud2lkdGggKyAxNX1weGAsXG4gICAgICAgICAgICAgICAgdG9wIDogZXZlbnRWZG9tLnN0eWxlLnRvcFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGVkaXRFdmVudENvbnRhaW5lci5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3OiBtZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCAgIDogZGF0YS5wYXRoWzFdLmlkLFxuICAgICAgICAgICAgICAgIHJlY29yZCAgICAgOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgc3R5bGUgICAgICA6IHN0eWxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyLnJlbmRlcih0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50RHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZXZlbnRzLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmV2ZW50RHJhZ1pvbmUuZHJhZ0VuZCgpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmlzVG9wTGV2ZWxFdmVudChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtZS5hZGp1c3RSZXNpemVFdmVudChkYXRhKTtcbiAgICAgICAgICAgICAgICBtZS5nZXRQbHVnaW4oe2ZsYWc6J3Jlc2l6YWJsZSd9KS5vbkRyYWdFbmQoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmV2ZW50RHJhZ1pvbmUucmVtb3ZlQm9keUN1cnNvckNscygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ldmVudHMuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFtZS5pc1RvcExldmVsRXZlbnQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbWUuYWRqdXN0UmVzaXplRXZlbnQoZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmV2ZW50RHJhZ1pvbmUuZHJhZ01vdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZXZlbnRzLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUgICA9IG1lLmV2ZW50RHJhZ1pvbmUsXG4gICAgICAgICAgICAgICAgaXNUb3BMZXZlbEV2ZW50ID0gbWUuaXNUb3BMZXZlbEV2ZW50KGRhdGEpLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LCB0aW1lQXhpcztcblxuICAgICAgICAgICAgaWYgKCFpc1RvcExldmVsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbWUuYWRqdXN0UmVzaXplRXZlbnQoZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYWdFbGVtZW50ID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCBkYXRhLnBhdGhbMF0uaWQpLnZkb207XG4gICAgICAgICAgICB0aW1lQXhpcyAgICA9IG1lLnRpbWVBeGlzO1xuXG4gICAgICAgICAgICBtZS5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGF4aXNFbmRUaW1lICAgICAgICAgICAgICAgICAgICAgOiB0aW1lQXhpcy5nZXRUaW1lKG1lLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIGF4aXNTdGFydFRpbWUgICAgICAgICAgICAgICAgICAgOiB0aW1lQXhpcy5nZXRUaW1lKG1lLnN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQgICAgICAgICAgICAgICAgICAgICA6IGRyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiBtZS5kYXRhLmV2ZW50cy5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZSxcbiAgICAgICAgICAgICAgICBldmVudFJlY29yZCAgICAgICAgICAgICAgICAgICAgIDogbWUuZXZlbnRTdG9yZS5nZXQoZHJhZ0VsZW1lbnQuZmxhZyksXG4gICAgICAgICAgICAgICAgcHJveHlQYXJlbnRJZCAgICAgICAgICAgICAgICAgICA6IGRhdGEucGF0aFsxXS5pZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFldmVudERyYWdab25lKSB7XG4gICAgICAgICAgICAgICAgbWUuZXZlbnREcmFnWm9uZSA9IGV2ZW50RHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICA6IEV2ZW50RHJhZ1pvbmUsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkOiBtZS5nZXRTY3JvbGxDb250YWluZXIoKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuXG4gICAgICAgICAgICAgICAgICAgIGRyYWdQcm94eUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbENoYW5nZTogJ2hlaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudERyYWdab25lLnNldChjb25maWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNUb3BMZXZlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5hZGRCb2R5Q3Vyc29yQ2xzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmdldFBsdWdpbih7ZmxhZzoncmVzaXphYmxlJ30pLm9uRHJhZ1N0YXJ0KGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudERyYWdab25lLmRyYWdTdGFydChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoXG4gICAgICovXG4gICAgb25Gb2N1c0NoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBvbGRQYXRoID0gZGF0YS5vbGRQYXRoLFxuICAgICAgICAgICAgcGF0aCAgICA9IGRhdGEucGF0aDtcblxuICAgICAgICBpZiAob2xkUGF0aCkge1xuICAgICAgICAgICAgaWYgKG9sZFBhdGhbMF0/LmNscy5pbmNsdWRlcygnbmVvLWV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXModGhpcy5hcHBOYW1lLCB7aWQ6IG9sZFBhdGhbMF0uaWQsIGNsczoge3JlbW92ZTogWyduZW8tZm9jdXMnXX19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aFswXT8uY2xzLmluY2x1ZGVzKCduZW8tZXZlbnQnKSkge1xuICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtpZDogcGF0aFswXS5pZCwgY2xzOiB7YWRkOiBbJ25lby1mb2N1cyddfX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLmNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnJvd0hlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnJvd3NQZXJJdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudG90YWxIZWlnaHRcbiAgICAgKi9cbiAgICBvblRpbWVBeGlzQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGp1c3RUb3RhbEhlaWdodChkYXRhLCBtZS5oZWFkZXJDcmVhdGVkKTtcblxuICAgICAgICBpZiAobWUuaGVhZGVyQ3JlYXRlZCkge1xuICAgICAgICAgICAgbWUudXBkYXRlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25XaGVlbChkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1VwZGF0aW5nICYmIE1hdGguYWJzKGRhdGEuZGVsdGFYKSA+IE1hdGguYWJzKGRhdGEuZGVsdGFZKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgY29sdW1ucyAgICAgICAgID0gbWUuZ2V0Q29sdW1uQ29udGFpbmVyKCksXG4gICAgICAgICAgICAgICAgZmlyc3RDb2x1bW5EYXRlID0gbWUuZmlyc3RDb2x1bW5EYXRlLFxuICAgICAgICAgICAgICAgIGhlYWRlciAgICAgICAgICA9IG1lLmdldEhlYWRlckNvbnRhaW5lcigpLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgdGltZUF4aXNXaWR0aCAgID0gNTAsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgID0gZGF0YS5jbGllbnRXaWR0aCAtIHRpbWVBeGlzV2lkdGgsXG4gICAgICAgICAgICAgICAgY29uZmlnLCBkYXRlLCBzY3JvbGxWYWx1ZTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YS5zY3JvbGxMZWZ0LCBNYXRoLnJvdW5kKGRhdGEuc2Nyb2xsTGVmdCAvIChkYXRhLmNsaWVudFdpZHRoIC0gdGltZUF4aXNXaWR0aCkgKiA3KSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmRlbHRhWCA+IDAgJiYgTWF0aC5yb3VuZChkYXRhLnNjcm9sbExlZnQgLyB3aWR0aCAqIDcpID4gMTMpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoY29sdW1ucy5jbltjb2x1bW5zLmNuLmxlbmd0aCAtIDFdLmZsYWcpO1xuXG4gICAgICAgICAgICAgICAgY29sdW1ucy5jbi5zcGxpY2UoMCwgNyk7XG4gICAgICAgICAgICAgICAgaGVhZGVyIC5jbi5zcGxpY2UoMCwgNyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBtZS5jcmVhdGVDb2x1bW5BbmRIZWFkZXIoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5jbi5wdXNoKGNvbmZpZy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLnB1c2goY29uZmlnLmhlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyc3RDb2x1bW5EYXRlLnNldERhdGUoZmlyc3RDb2x1bW5EYXRlLmdldERhdGUoKSArIDcpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIG1vdmUgdGhlIGV2ZW50IHJlbmRlcmluZyBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgICAgICAgICAgICAvLyBEZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjIxNlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVFdmVudHMoZmFsc2UsIDE0LCAyMSk7XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuZGVsdGFYIDwgMCAmJiBNYXRoLnJvdW5kKGRhdGEuc2Nyb2xsTGVmdCAvIHdpZHRoICogNykgPCAxKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGNvbHVtbnMuY25bMF0uZmxhZyk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLmxlbmd0aCA9IDE0O1xuICAgICAgICAgICAgICAgIGhlYWRlciAuY24ubGVuZ3RoID0gMTQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBtZS5jcmVhdGVDb2x1bW5BbmRIZWFkZXIoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5jbi51bnNoaWZ0KGNvbmZpZy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLnVuc2hpZnQoY29uZmlnLmhlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyc3RDb2x1bW5EYXRlLnNldERhdGUoZmlyc3RDb2x1bW5EYXRlLmdldERhdGUoKSAtIDcpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIG1vdmUgdGhlIGV2ZW50IHJlbmRlcmluZyBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgICAgICAgICAgICAvLyBEZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjIxNlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVFdmVudHMoZmFsc2UsIDAsIDcpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcblxuICAgICAgICAgICAgICAgIHNjcm9sbFZhbHVlID0gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5nZXRTY3JvbGxDb250YWluZXIoKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogc2Nyb2xsVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFsZ29yaXRobSByZWxpZXMgb24gdGhlIGV2ZW50U3RvcmUgYmVpbmcgc29ydGVkIGJ5IHN0YXJ0RGF0ZSBBU0NcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4PTBdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleD0yMV1cbiAgICAgKi9cbiAgICB1cGRhdGVFdmVudHMoc2lsZW50PWZhbHNlLCBzdGFydEluZGV4PTAsIGVuZEluZGV4PTIxKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlICAgICA9IG1lLmNhbGVuZGFyU3RvcmUsXG4gICAgICAgICAgICBldmVudFN0b3JlICAgICAgICA9IG1lLmV2ZW50U3RvcmUsXG4gICAgICAgICAgICB0aW1lQXhpcyAgICAgICAgICA9IG1lLnRpbWVBeGlzLFxuICAgICAgICAgICAgZW5kVGltZSAgICAgICAgICAgPSB0aW1lQXhpcy5nZXRUaW1lKG1lLmVuZFRpbWUpLFxuICAgICAgICAgICAgc3RhcnRUaW1lICAgICAgICAgPSB0aW1lQXhpcy5nZXRUaW1lKG1lLnN0YXJ0VGltZSksXG4gICAgICAgICAgICB0b3RhbFRpbWUgICAgICAgICA9IGVuZFRpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICBkYXRlICAgICAgICAgICAgICA9IERhdGVVdGlsLmNsb25lKG1lLmZpcnN0Q29sdW1uRGF0ZSksXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICBjb250ZW50ICAgICAgICAgICA9IG1lLmdldENvbHVtbkNvbnRhaW5lcigpLFxuICAgICAgICAgICAgaiAgICAgICAgICAgICAgICAgPSBzdGFydEluZGV4LFxuICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSAgPSBtZS5zaG93RXZlbnRFbmRUaW1lLFxuICAgICAgICAgICAgY2FsZW5kYXJSZWNvcmQsIGNvbHVtbiwgZGF5UmVjb3JkcywgZHVyYXRpb24sIGVuZERhdGUsIGV2ZW50Q2xzLCBldmVudEludGVydmFscywgaGFzT3ZlcmZsb3csIGhlaWdodCwgaSxcbiAgICAgICAgICAgIGxlbiwgcmVjb3JkLCByZWNvcmRLZXksIHN0YXJ0RGF0ZSwgc3RhcnRIb3VycywgdG9wO1xuXG4gICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgPSAhbWUubW91bnRlZDtcblxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGFydEluZGV4KTtcblxuICAgICAgICBmb3IgKDsgaiA8IGVuZEluZGV4OyBqKyspIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IGNvbnRlbnQuY25bal07XG5cbiAgICAgICAgICAgIGNvbHVtbi5jbiA9IFtdOyAvLyByZW1vdmUgcHJldmlvdXMgZXZlbnRzIGZyb20gdGhlIHZkb21cblxuICAgICAgICAgICAgZGF5UmVjb3JkcyA9IGV2ZW50U3RvcmUuZ2V0RGF5UmVjb3JkcyhkYXRlKTtcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSBkYXlSZWNvcmRzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkICAgICAgICAgPSBkYXlSZWNvcmRzW2ldO1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyUmVjb3JkID0gY2FsZW5kYXJTdG9yZS5nZXQocmVjb3JkLmNhbGVuZGFySWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyUmVjb3JkPy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSAgID0gRGF0ZVV0aWwuY2xvbmUocmVjb3JkLmVuZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShyZWNvcmQuc3RhcnREYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kVGltZSA8PSBzdGFydERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lID49IGVuZERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kVGltZSA8IGVuZERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycyhlbmRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFRpbWUgPiBzdGFydERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uICAgICAgID0gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyA2MCAvIDEwMDA7IC8vIGR1cmF0aW9uIGluIGhvdXJzXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xzICAgICAgID0gWyduZW8tZXZlbnQnLCAnbmVvLWRyYWdnYWJsZScsIGBuZW8tJHtjYWxlbmRhclJlY29yZC5jb2xvcn1gXTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnRlcnZhbHMgPSBkdXJhdGlvbiAqIDYwIC8gdGltZUF4aXMuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIGhhc092ZXJmbG93ICAgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAgICAgICAgID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIHRvdGFsVGltZSAqIDEwMCAqIDEwMDApIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkS2V5ICAgICAgPSByZWNvcmRbZXZlbnRTdG9yZS5rZXlQcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SG91cnMgICAgID0gKHN0YXJ0RGF0ZS5nZXRIb3VycygpICogNjAgKyBzdGFydERhdGUuZ2V0TWludXRlcygpKSAvIDYwO1xuICAgICAgICAgICAgICAgICAgICB0b3AgICAgICAgICAgICA9IE1hdGgucm91bmQoKHN0YXJ0SG91cnMgLSBzdGFydFRpbWUpIC8gdG90YWxUaW1lICogMTAwICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEludGVydmFscyA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPdmVyZmxvdyA9IHRpbWVBeGlzLnJvd0hlaWdodCAqIGV2ZW50SW50ZXJ2YWxzIDwgKHNob3dFdmVudEVuZFRpbWUgPyA1MCA6IDM0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJmbG93ICYmICEoc2hvd0V2ZW50RW5kVGltZSAmJiAodGltZUF4aXMucm93SGVpZ2h0IC8gZXZlbnRJbnRlcnZhbHMgPj0gMzQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xzLnB1c2goJ25lby1vdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSA9ICEoaGFzT3ZlcmZsb3cgJiYgZXZlbnRJbnRlcnZhbHMgPT09IDEgfHwgIXNob3dFdmVudEVuZFRpbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudEVuZFRpbWUgJiYgZXZlbnRDbHMucHVzaCgnbmVvLXNob3ctZW5kLXRpbWUnKTtcblxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uY24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgIDogZXZlbnRDbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnICAgIDogcmVjb3JkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmlkICsgJ19fJyArIHJlY29yZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZXZlbnQtdGltZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IG1lLmludGxGb3JtYXRfdGltZS5mb3JtYXQocmVjb3JkLnN0YXJ0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgIDogbWUuaWQgKyAnX190aW1lX18nICsgcmVjb3JkS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZXZlbnQtdGl0bGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiByZWNvcmQudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgIDogbWUuaWQgKyAnX190aXRsZV9fJyArIHJlY29yZEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogWyduZW8tZXZlbnQtdGltZScsICduZW8tZXZlbnQtZW5kLXRpbWUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICAgICA6IG1lLmludGxGb3JtYXRfdGltZS5mb3JtYXQocmVjb3JkLmVuZERhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUuaWQgKyAnX19lbmRkYXRlX18nICsgcmVjb3JkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogIXNob3dFdmVudEVuZFRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYGNhbGMoJHtoZWlnaHR9JSAtIDJweClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgIDogYGNhbGMoJHt0b3B9JSArIDFweClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogJ2NhbGMoMTAwJSAtIDFweCknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZVtzaWxlbnQgPyAnX3Zkb20nIDogJ3Zkb20nXSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjcmVhdGU9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIHVwZGF0ZUhlYWRlcihjcmVhdGU9ZmFsc2UsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGUgICAgICAgICA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgIHZkb20gICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICBjb250ZW50ICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgIGhlYWRlciAgICAgICA9IG1lLmdldEhlYWRlckNvbnRhaW5lcigpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIHNob3dXZWVrZW5kcyA9IG1lLnNob3dXZWVrZW5kcyxcbiAgICAgICAgICAgIGNvbHVtbkNscywgY3VycmVudERhdGUsIGN1cnJlbnREYXksIGRhdGVDbHMsIGhlYWRlcklkLCByZW1vdmVEb207XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKG1lLmN1cnJlbnREYXRlLmdldERhdGUoKSAtIG1lLmN1cnJlbnREYXRlLmdldERheSgpICsgbWUud2Vla1N0YXJ0RGF5IC0gNyk7XG5cbiAgICAgICAgbWUuZmlyc3RDb2x1bW5EYXRlID0gRGF0ZVV0aWwuY2xvbmUoZGF0ZSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCAyMTsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5DbHMgICA9IFsnbmVvLWMtdy1jb2x1bW4nLCAnbmVvLWRyYWdnYWJsZSddO1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIGN1cnJlbnREYXkgID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgIGRhdGVDbHMgICAgID0gWyduZW8tZGF0ZSddO1xuICAgICAgICAgICAgcmVtb3ZlRG9tICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgICAgIGNvbHVtbkNscy5wdXNoKCduZW8td2Vla2VuZCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzaG93V2Vla2VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50RGF0ZSAgICAgICAgPT09IHRvZGF5LmRheSAgICYmXG4gICAgICAgICAgICAgICAgZGF0ZS5nZXRNb250aCgpICAgID09PSB0b2RheS5tb250aCAmJlxuICAgICAgICAgICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdG9kYXkueWVhcikge1xuICAgICAgICAgICAgICAgIGRhdGVDbHMucHVzaCgnbmVvLXRvZGF5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcklkID0gbWUuZ2V0Q29sdW1uSGVhZGVySWQoZGF0ZSk7XG5cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LmNuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IGNvbHVtbkNscyxcbiAgICAgICAgICAgICAgICAgICAgZmxhZyAgICAgOiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5nZXRDb2x1bW5JZChkYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiByZW1vdmVEb21cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGhlYWRlci5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1oZWFkZXItcm93LWl0ZW0nXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBoZWFkZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiByZW1vdmVEb20sXG5cbiAgICAgICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1kYXknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICA6IGAke2hlYWRlcklkfV9kYXlgXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA6IGRhdGVDbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICA6IGAke2hlYWRlcklkfV9kYXRlYFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbnRlbnQuY25baV0sIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBjb2x1bW5DbHMsXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUuZ2V0Q29sdW1uSWQoZGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogcmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlci5jbltpXSwge1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IGhlYWRlcklkLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206IHJlbW92ZURvbVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIuY25baV0uY25bMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogbWUuaW50bEZvcm1hdF9kYXkuZm9ybWF0KGRhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpZCAgOiBgJHtoZWFkZXJJZH1fZGF5YFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIuY25baV0uY25bMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzIDogZGF0ZUNscyxcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogY3VycmVudERhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlkICA6IGAke2hlYWRlcklkfV9kYXRlYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbXBvbmVudCk7XG5cbmV4cG9ydCB7Q29tcG9uZW50IGFzIGRlZmF1bHR9O1xuIiwiaW1wb3J0IERhdGVVdGlsICAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vZHJhZ2dhYmxlL0RyYWdQcm94eUNvbXBvbmVudC5tanMnO1xuaW1wb3J0IERyYWdab25lICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9kcmFnZ2FibGUvRHJhZ1pvbmUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLkRyYWdab25lXG4gKi9cbmNsYXNzIEV2ZW50RHJhZ1pvbmUgZXh0ZW5kcyBEcmFnWm9uZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsuRXZlbnREcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NhbGVuZGFyLXdlZWstZXZlbnQtZHJhZ3pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2FsZW5kYXItd2Vlay1ldmVudC1kcmFnem9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhZGREcmFnUHJveHlDbHM9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZERyYWdQcm94eUNsczogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXhpc0VuZFRpbWU9MFxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc0VuZFRpbWU6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF4aXNTdGFydFRpbWU9MFxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc1N0YXJ0VGltZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29sdW1uSGVpZ2h0PTBcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbkhlaWdodDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29sdW1uVG9wPTBcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtblRvcDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY3VycmVudEludGVydmFsPTBcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnRJbnRlcnZhbDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpbWUgaW4gbWludXRlc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGV2ZW50RHVyYXRpb249MFxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnREdXJhdGlvbjogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZXZlbnRSZWNvcmQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRSZWNvcmQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnLlxuICAgICAgICAgKiBJZiB3ZSByZXNpemUgYWNyb3NzIHRoZSBvcHBvc2l0ZSBlZGdlIGFuZCB0aGVuIGJhY2ssIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByZWxhdGVkIGVkZ2UgcG9zaXRpb24gb25jZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZm9yY2VVcGRhdGU9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNPdmVyZmxvdz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoYXNPdmVyZmxvdzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aW1lIGluIG1pbnV0ZXNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBpbnRlcnZhbFNpemU9MTVcbiAgICAgICAgICovXG4gICAgICAgIGludGVydmFsU2l6ZTogMTUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBrZWVwRW5kRGF0ZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAga2VlcEVuZERhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0ga2VlcFN0YXJ0RGF0ZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAga2VlcFN0YXJ0RGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSG9yaXpvbnRhbD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUluTWFpblRocmVhZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnLlxuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfSBuZXdFbmREYXRlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmV3RW5kRGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV9IG5ld1N0YXJ0RGF0ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5ld1N0YXJ0RGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsRmFjdG9yTGVmdD0zXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxGYWN0b3JMZWZ0OiAzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlUHJveHlXcmFwcGVyPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VQcm94eVdyYXBwZXI6IGZhbHNlXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkQm9keUN1cnNvckNscygpIHtcbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKHRoaXMuYXBwTmFtZSwge2lkOiAnZG9jdW1lbnQuYm9keScsIGNsczoge2FkZDogWyduZW8tY3Vyc29yLW1vdmUnXX19KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgMjQ6MDAgaXNzdWUsIHdoZXJlIGFuIGV2ZW50IHdvdWxkIGVuZCBvbiB0aGUgbmV4dCBkYXlcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKi9cbiAgICBhZGp1c3RFbmREYXRlKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUuZ2V0SG91cnMoKSA9PT0gMCAmJiBkYXRlLmdldE1pbnV0ZXMoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgYW4gZXZlbnQgZW5kcyBhdCAyNDowMCwgY2hhbmdlIGl0IHRvIDIzOjU5ID0+IG90aGVyd2lzZSB0aGUgZGF5IGluY3JlYXNlcyBieSAxXG4gICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmICghKGRhdGUuZ2V0SG91cnMoKSA9PT0gMjMgJiYgZGF0ZS5nZXRNaW51dGVzKCkgPT09IDU5KSAmJiBkYXRlLmdldE1pbnV0ZXMoKSAlIHRoaXMuaW50ZXJ2YWxTaXplICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugc3dpdGNoIG5vbiBpbnRlcnZhbCBiYXNlZCB2YWx1ZXMgYmFja1xuICAgICAgICAgICAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHByb3h5UGFyZW50SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UHJveHlQYXJlbnRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBub2RlIGRpZCBub3QgZ2V0IHJlbW92ZWQgeWV0XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1Byb3h5Py52ZG9tLmNuWzBdLmlkKSB7XG4gICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uICA6ICdtb3ZlTm9kZScsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBtZS5kcmFnUHJveHkuaWQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICAgOiAwLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVEcmFnUHJveHkoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQobWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQpIHx8IG1lLm93bmVyLFxuICAgICAgICAgICAgdmRvbSAgICAgID0gbWUuZHJhZ1Byb3h5Q29uZmlnPy52ZG9tLFxuICAgICAgICAgICAgY2xvbmUgICAgID0gVkRvbVV0aWwuY2xvbmUodmRvbSA/IHZkb20gOiBtZS5kcmFnRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGNsb25lLmNuWzJdLnJlbW92ZURvbSA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICA6IERyYWdQcm94eUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBtZS5tb3ZlSW5NYWluVGhyZWFkLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgIDogbWUucHJveHlQYXJlbnRJZCxcblxuICAgICAgICAgICAgLi4ubWUuZHJhZ1Byb3h5Q29uZmlnLFxuXG4gICAgICAgICAgICB2ZG9tOiBtZS51c2VQcm94eVdyYXBwZXIgPyB7Y246IFtjbG9uZV19IDogY2xvbmUgLy8gd2Ugd2FudCB0byBvdmVycmlkZSBkcmFnUHJveHlDb25maWcudmRvbSBpZiBuZWVkZWRcbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWcuY2xzID0gY29uZmlnLmNscyB8fCBbXTtcblxuICAgICAgICBjb25maWcuY2xzLnB1c2goJ25lby1mb2N1cycpO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaChjb21wb25lbnQuZ2V0VGhlbWUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvbmUuY2xzICYmICFtZS51c2VQcm94eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaCguLi5jbG9uZS5jbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmFkZERyYWdQcm94eUNscykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNvbmZpZy5jbHMsIG1lLmRyYWdQcm94eUNscyk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZy5zdHlsZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBgJHtkYXRhLmhlaWdodH1weGAsXG4gICAgICAgICAgICB0b3AgICA6IGAke2RhdGEueSAtIG1lLmNvbHVtblRvcH1weGAsXG4gICAgICAgICAgICB3aWR0aCA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdQcm94eSA9IE5lby5jcmVhdGUoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmFnRW5kIGVxdWFscyBkcm9wLCBzaW5jZSB3ZSBjYW4gb25seSBkcmFnIHRvIHZhbGlkIHBvc2l0aW9uc1xuICAgICAqIHRvZG86IEVTQyBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdFbmQoZGF0YSkge1xuICAgICAgICBzdXBlci5kcmFnRW5kKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgID0gbWUub3duZXIsXG4gICAgICAgICAgICByZWNvcmQgPSBtZS5ldmVudFJlY29yZCxcbiAgICAgICAgICAgIGVuZERhdGUsIHN0YXJ0RGF0ZTtcblxuICAgICAgICBpZiAobWUua2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgZW5kRGF0ZSAgID0gbWUubmV3RW5kRGF0ZTtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IG1lLm5ld1N0YXJ0RGF0ZSB8fCByZWNvcmQuc3RhcnREYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnREYXRlID0gbmV3IERhdGUoVkRvbVV0aWwuZmluZFZkb21DaGlsZChvd25lci52ZG9tLCBtZS5wcm94eVBhcmVudElkKS52ZG9tLmZsYWcgKyAnVDAwOjAwOjAwJyk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMobWUuYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhtZS5jdXJyZW50SW50ZXJ2YWwgKiBtZS5pbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICBpZiAobWUua2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICBlbmREYXRlICAgPSBtZS5uZXdFbmREYXRlICAgfHwgcmVjb3JkLmVuZERhdGU7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlID0gbWUubmV3U3RhcnREYXRlIHx8IHN0YXJ0RGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZSA9IERhdGVVdGlsLmNsb25lKHN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKGVuZERhdGUuZ2V0TWludXRlcygpICsgbWUuZXZlbnREdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbmREYXRlID0gbWUuYWRqdXN0RW5kRGF0ZShlbmREYXRlKTtcblxuICAgICAgICByZWNvcmQuZW5kRGF0ZSAgID0gZW5kRGF0ZTtcbiAgICAgICAgcmVjb3JkLnN0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBoYXNPdmVyZmxvdyAgOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBFbmREYXRlICA6IGZhbHNlLFxuICAgICAgICAgICAga2VlcFN0YXJ0RGF0ZTogZmFsc2UsXG4gICAgICAgICAgICBuZXdFbmREYXRlICAgOiBudWxsLFxuICAgICAgICAgICAgbmV3U3RhcnREYXRlIDogbnVsbCxcbiAgICAgICAgICAgIHByb3h5UGFyZW50SWQ6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdG9kbzogdXBkYXRpbmcgYSByZWNvcmQgZmllbGQgd2hpY2ggaXMgaW5jbHVkZWQgaW5zaWRlIGEgc29ydGVyIHNob3VsZCB0cmlnZ2VyIGNvbGxlY3Rpb24uZG9Tb3J0KClcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjM5MlxuXG4gICAgICAgIG93bmVyLmdldE1vZGVsKCkuZ2V0U3RvcmUoJ2V2ZW50cycpLmRvU29ydCgpO1xuICAgICAgICBvd25lci51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGF4aXNFbmRUaW1lICAgICA9IG1lLmF4aXNFbmRUaW1lLFxuICAgICAgICAgICAgYXhpc1N0YXJ0VGltZSAgID0gbWUuYXhpc1N0YXJ0VGltZSxcbiAgICAgICAgICAgIGNvbHVtbkhlaWdodCAgICA9IG1lLmNvbHVtbkhlaWdodCxcbiAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gICA9IG1lLmV2ZW50RHVyYXRpb24sXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgaW50ZXJ2YWxTaXplICAgID0gbWUuaW50ZXJ2YWxTaXplLFxuICAgICAgICAgICAga2VlcEVuZERhdGUgICAgID0gbWUua2VlcEVuZERhdGUsXG4gICAgICAgICAgICBrZWVwU3RhcnREYXRlICAgPSBtZS5rZWVwU3RhcnREYXRlLFxuICAgICAgICAgICAgcGF0aCAgICAgICAgICAgID0gZGF0YS50YXJnZXRQYXRoLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICAgID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBvd25lciAgICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIHJlY29yZCAgICAgICAgICA9IG1lLmV2ZW50UmVjb3JkLFxuICAgICAgICAgICAgc3dpdGNoRGlyZWN0aW9uID0gZmFsc2UsXG4gICAgICAgICAgICB0aW1lQXhpcyAgICAgICAgPSBvd25lci50aW1lQXhpcyxcbiAgICAgICAgICAgIGF4aXNTdGFydERhdGUsIGN1cnJlbnRJbnRlcnZhbCwgZGVsdGFzLCBkdXJhdGlvbiwgZW5kRGF0ZSwgZXZlbnRJbnRlcnZhbHMsIGhhc092ZXJmbG93LCBoZWlnaHQsIGludGVydmFsSGVpZ2h0LFxuICAgICAgICAgICAgaW50ZXJ2YWxzLCBsaW1pdEludGVydmFsLCBtaW5pbXVtRXZlbnRJbnRlcnZhbHMsIHBvc2l0aW9uLCBzdGFydERhdGUsIHN0YXJ0SW50ZXJ2YWw7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgaWYgKCFrZWVwRW5kRGF0ZSAmJiAha2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2xzLmluY2x1ZGVzKCduZW8tYy13LWNvbHVtbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5wcm94eVBhcmVudElkID0gcGF0aFtpXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnRlcnZhbHMgICAgICA9IChheGlzRW5kVGltZSAtIGF4aXNTdGFydFRpbWUpICogNjAgLyBpbnRlcnZhbFNpemU7IC8vIDE1IG1pbnV0ZXMgZWFjaFxuICAgICAgICAgICAgaW50ZXJ2YWxIZWlnaHQgPSBjb2x1bW5IZWlnaHQgLyBpbnRlcnZhbHM7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5taW4oY29sdW1uSGVpZ2h0LCBkYXRhLmNsaWVudFkgLSBtZS5vZmZzZXRZIC0gbWUuY29sdW1uVG9wKTtcblxuICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5mbG9vcihwb3NpdGlvbiAvIGludGVydmFsSGVpZ2h0KTtcblxuICAgICAgICAgICAgZW5kRGF0ZSAgID0gRGF0ZVV0aWwuY2xvbmUocmVjb3JkLmVuZERhdGUpO1xuICAgICAgICAgICAgc3RhcnREYXRlID0gRGF0ZVV0aWwuY2xvbmUocmVjb3JkLnN0YXJ0RGF0ZSk7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50cyBjYW4gaGF2ZSBhIHNtYWxsZXIgc3RhcnQgdGltZSB0aGFuIHRoZSBheGlzIG1pbiB2YWx1ZS5cbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIHZpYSB0aGUgbm9ydGggaGFuZGxlIG5lZWRzIHRvIGFkanVzdCB0aGUgZHVyYXRpb24gdG8gaG9ub3IgdGhpcy5cbiAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzU3RhcnRUaW1lID4gc3RhcnREYXRlLmdldEhvdXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcygwKTtcblxuICAgICAgICAgICAgICAgICAgICBldmVudER1cmF0aW9uID0gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBtaW51dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBldmVudHMgY2FuIGhhdmUgYSBiaWdnZXIgZW5kIHRpbWUgdGhhbiB0aGUgYXhpcyBtYXggdmFsdWUuXG4gICAgICAgICAgICAvLyByZXNpemluZyB2aWEgdGhlIHNvdXRoIGhhbmRsZSBuZWVkcyB0byBhZGp1c3QgdGhlIGR1cmF0aW9uIHRvIGhvbm9yIHRoaXMuXG4gICAgICAgICAgICBpZiAoa2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzRW5kVGltZSA8IGVuZERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGF4aXNFbmRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDEwMDA7IC8vIGR1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgha2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgbXVzdCBub3QgZW5kIGFmdGVyIHRoZSBsYXN0IHZpc2libGUgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLm1pbihjdXJyZW50SW50ZXJ2YWwsIGludGVydmFscyAtIChldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbHRhcyA9IFt7XG4gICAgICAgICAgICAgICAgaWQgICA6IG1lLmRyYWdQcm94eS5pZCxcbiAgICAgICAgICAgICAgICBzdHlsZToge31cbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUgfHwga2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGF4aXNTdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShyZWNvcmQuc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICBheGlzU3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIGF4aXNTdGFydERhdGUuc2V0TWludXRlcygwKTtcblxuICAgICAgICAgICAgICAgIG1pbmltdW1FdmVudEludGVydmFscyA9IG93bmVyLm1pbmltdW1FdmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplO1xuICAgICAgICAgICAgICAgIHN0YXJ0SW50ZXJ2YWwgICAgICAgICA9IChyZWNvcmQuc3RhcnREYXRlIC0gYXhpc1N0YXJ0RGF0ZSkgLyBpbnRlcnZhbFNpemUgLyA2MCAvIDEwMDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbnRlcnZhbCA9IHN0YXJ0SW50ZXJ2YWwgKyAoZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWUuZm9yY2VVcGRhdGUgJiYgY3VycmVudEludGVydmFsID4gbGltaXRJbnRlcnZhbCAtbWluaW11bUV2ZW50SW50ZXJ2YWxzICYmIGN1cnJlbnRJbnRlcnZhbCA8IGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHdlIHJlc2l6ZSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBkaXJlY3Rpb24sIGtlZXAgdGhlIG1pbiBpbnRlcnZhbCB1bnRpbCB3ZSBzbmFwIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbnRlcnZhbCA+PSBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoRGlyZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoY3VycmVudEludGVydmFsICogaW50ZXJ2YWxTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlID0gbWUuYWRqdXN0RW5kRGF0ZShlbmREYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld0VuZERhdGUgPSBlbmREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKGxpbWl0SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3U3RhcnREYXRlID0gc3RhcnREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUudG9wID0gYGNhbGMoJHtsaW1pdEludGVydmFsICogaW50ZXJ2YWxIZWlnaHQgLyBjb2x1bW5IZWlnaHQgKiAxMDB9JSArIDFweClgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdTdGFydERhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzd2l0Y2hEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWluKGN1cnJlbnRJbnRlcnZhbCwgbGltaXRJbnRlcnZhbCAtIG1pbmltdW1FdmVudEludGVydmFscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW1pdEludGVydmFsID0gc3RhcnRJbnRlcnZhbCAtIChldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBtdXN0IG5vdCBzdGFydCBiZWZvcmUgdGhlIGZpcnN0IHZpc2libGUgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWF4KC0oZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSksIGN1cnJlbnRJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJ2YWwgPD0gbGltaXRJbnRlcnZhbCAtIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaERpcmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZm9yY2VVcGRhdGUgID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKGV2ZW50RHVyYXRpb24gKyBsaW1pdEludGVydmFsICogaW50ZXJ2YWxTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlID0gbWUuYWRqdXN0RW5kRGF0ZShlbmREYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld0VuZERhdGUgPSBlbmREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKGV2ZW50RHVyYXRpb24gKyBjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3U3RhcnREYXRlID0gc3RhcnREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gaG91cnNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUgKyBjdXJyZW50SW50ZXJ2YWwpICogaW50ZXJ2YWxIZWlnaHQ7IC8vIHNuYXAgdG8gdmFsaWQgaW50ZXJ2YWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIGNvbHVtbkhlaWdodCAqIDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS50b3AgPSBgY2FsYygke3Bvc2l0aW9ufSUgKyAxcHgpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuZm9yY2VVcGRhdGUgJiYgY3VycmVudEludGVydmFsIDwgbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzaXplIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGRpcmVjdGlvbiwga2VlcCB0aGUgbWluIGludGVydmFsIHVudGlsIHdlIHNuYXAgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuZm9yY2VVcGRhdGUgJiYgY3VycmVudEludGVydmFsID49IGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWUuY3VycmVudEludGVydmFsICE9PSBjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZm9yY2VVcGRhdGUgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld1N0YXJ0RGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS50b3AgPSBgY2FsYygke3N0YXJ0SW50ZXJ2YWwgKiBpbnRlcnZhbEhlaWdodCAvIGNvbHVtbkhlaWdodCAqIDEwMH0lICsgMXB4KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzd2l0Y2hEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWF4KGN1cnJlbnRJbnRlcnZhbCwgbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgha2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBtdXN0IG5vdCBzdGFydCBiZWZvcmUgdGhlIGZpcnN0IHZpc2libGUgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLm1heCgwLCBjdXJyZW50SW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUuY3VycmVudEludGVydmFsICE9PSBjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKGV2ZW50RHVyYXRpb24gKyBjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld0VuZERhdGUgPSBlbmREYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSAoZW5kRGF0ZSAtIHJlY29yZC5zdGFydERhdGUpIC8gNjAgLyA2MCAvIDEwMDA7IC8vIGR1cmF0aW9uIGluIGhvdXJzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsSGVpZ2h0OyAvLyBzbmFwIHRvIHZhbGlkIGludGVydmFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIGNvbHVtbkhlaWdodCAqIDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLnRvcCA9IGBjYWxjKCR7cG9zaXRpb259JSArIDFweClgO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChyZWNvcmQuZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVuZERhdGUgPSBtZS5hZGp1c3RFbmREYXRlKGVuZERhdGUpO1xuXG4gICAgICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmRyYWdQcm94eS52ZG9tLmNuWzJdLmlkLFxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUw6IG93bmVyLmludGxGb3JtYXRfdGltZS5mb3JtYXQoZW5kRGF0ZSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSB8fCBrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQoZHVyYXRpb24gLyAoYXhpc0VuZFRpbWUgLSBheGlzU3RhcnRUaW1lKSAqIDEwMCAqIDEwMDApIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLmhlaWdodCA9IGBjYWxjKCR7aGVpZ2h0fSUgLSAycHgpYDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUuZHJhZ1Byb3h5LnZkb20uY25bMF0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogb3duZXIuaW50bEZvcm1hdF90aW1lLmZvcm1hdChzdGFydERhdGUpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbm9kZSBnb3QgYWRkZWQgeWV0XG4gICAgICAgICAgICAgICAgaWYgKG1lLmRyYWdQcm94eS52ZG9tLmNuWzBdLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW50ZXJ2YWxzID0gKGR1cmF0aW9uICYmIGR1cmF0aW9uICogNjAgfHwgZXZlbnREdXJhdGlvbikgLyB0aW1lQXhpcy5pbnRlcnZhbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRJbnRlcnZhbHMgPD0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3cgPSB0aW1lQXhpcy5yb3dIZWlnaHQgLyBldmVudEludGVydmFscyA8IDI1O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLmhhc092ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIDogbWUuZHJhZ1Byb3h5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB7YWRkOiBbJ25lby1vdmVyZmxvdyddfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5oYXNPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmhhc092ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA6IG1lLmRyYWdQcm94eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB7cmVtb3ZlOiBbJ25lby1vdmVyZmxvdyddfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuaGFzT3ZlcmZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCBkZWx0YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuY3VycmVudEludGVydmFsID0gY3VycmVudEludGVydmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBldmVudER1cmF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5nZXRCb3VuZGluZ0NsaWVudFJlY3Qoe1xuICAgICAgICAgICAgaWQ6IFttZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZCwgZGF0YS5wYXRoWzFdLmlkXVxuICAgICAgICB9KS50aGVuKHJlY3RzID0+IHtcbiAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gPSAobWUuZXZlbnRSZWNvcmQuZW5kRGF0ZSAtIG1lLmV2ZW50UmVjb3JkLnN0YXJ0RGF0ZSkgLyA2MCAvIDEwMDA7XG4gICAgICAgICAgICBvZmZzZXRYICAgICAgID0gZGF0YS5jbGllbnRYIC0gcmVjdHNbMF0ubGVmdDtcbiAgICAgICAgICAgIG9mZnNldFkgICAgICAgPSBkYXRhLmNsaWVudFkgLSByZWN0c1swXS50b3A7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5IZWlnaHQgICA6IHJlY3RzWzFdLmhlaWdodCxcbiAgICAgICAgICAgICAgICBjb2x1bW5Ub3AgICAgICA6IHJlY3RzWzFdLnRvcCxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3RzWzBdLFxuICAgICAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gIDogTWF0aC5yb3VuZChldmVudER1cmF0aW9uIC8gbWUuaW50ZXJ2YWxTaXplKSAqIG1lLmludGVydmFsU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRYICAgICAgICA6IG9mZnNldFgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgOiBvZmZzZXRZXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuY3JlYXRlRHJhZ1Byb3h5KHJlY3RzWzBdKTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnZHJhZ1N0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdDogcmVjdHNbMF0sXG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBvZmZzZXRYICAgICAgICA6IG9mZnNldFgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgOiBvZmZzZXRZXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZHJhZ01vdmUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlQm9keUN1cnNvckNscygpIHtcbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKHRoaXMuYXBwTmFtZSwge2lkOiAnZG9jdW1lbnQuYm9keScsIGNsczoge3JlbW92ZTogWyduZW8tY3Vyc29yLW1vdmUnXX19KTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKEV2ZW50RHJhZ1pvbmUpO1xuXG5leHBvcnQge0V2ZW50RHJhZ1pvbmUgYXMgZGVmYXVsdH07XG4iLCJpbXBvcnQgUmVzaXphYmxlIGZyb20gJy4uLy4uLy4uL3BsdWdpbi9SZXNpemFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudFJlc2l6YWJsZVxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIEV2ZW50UmVzaXphYmxlIGV4dGVuZHMgUmVzaXphYmxlIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudFJlc2l6YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudFJlc2l6YWJsZSdcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBtZS5yZW1vdmVCb2R5Q3Vyc29yQ2xzKCk7XG4gICAgICAgIG1lLnJlbW92ZUFsbE5vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ01vdmUoZGF0YSkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgbWUuYWRkQm9keUN1cnNvckNscygpO1xuICAgICAgICBtZS5vd25lci5ldmVudERyYWdab25lW21lLmN1cnJlbnROb2RlTmFtZSA9PT0gJ3RvcCcgPyAna2VlcEVuZERhdGUnIDogJ2tlZXBTdGFydERhdGUnXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSBzaG93IHRoZSByZXNpemUgaGFuZGxlcyBpbiBjYXNlIGRyYWdnaW5nIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm93bmVyLmRhdGEuZXZlbnRzLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIHN1cGVyLm9uTW91c2VNb3ZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhFdmVudFJlc2l6YWJsZSk7XG5cbmV4cG9ydCB7RXZlbnRSZXNpemFibGUgYXMgZGVmYXVsdH07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LndlZWsuVGltZUF4aXNDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBUaW1lQXhpc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGdldFN0YXRpY0NvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGZvciBpbnRlcnZhbFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gaW50ZXJ2YWxzPVsxNSwgMzAsIDYwXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGludGVydmFsczogWzE1LCAzMCwgNjBdXG4gICAgfX1cblxuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy53ZWVrLlRpbWVBeGlzQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLlRpbWVBeGlzQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NhbGVuZGFyLXRpbWVheGlzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NhbGVuZGFyLXRpbWVheGlzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgZW5kVGltZSAgOiBkYXRhID0+IGRhdGEuZW5kVGltZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogZGF0YSA9PiBkYXRhLnN0YXJ0VGltZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ25lby1jYWxlbmRhci10aW1lYXhpcyddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnbmVvLWNhbGVuZGFyLXRpbWVheGlzJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGZ1bGwgaG91cnMgYXJlIHZhbGlkIGZvciBub3dcbiAgICAgICAgICogZm9ybWF0OiAnaGg6bW0nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZW5kVGltZV89JzI0OjAwJ1xuICAgICAgICAgKi9cbiAgICAgICAgZW5kVGltZV86ICcyNDowMCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBpbnRlcnZhbCBpbiBtaW51dGVzIHRvIGRpc3BsYXkgYXMgcm93cy5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAxNSwgMzAsIDYwXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaW50ZXJ2YWxfPTMwXG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnZhbF86IDMwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3dIZWlnaHRfPTIwXG4gICAgICAgICAqL1xuICAgICAgICByb3dIZWlnaHRfOiAyMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZnVsbCBob3VycyBhcmUgdmFsaWQgZm9yIG5vd1xuICAgICAgICAgKiBmb3JtYXQ6ICdoaDptbSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzdGFydFRpbWVfPScwMDowMCdcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0VGltZV86ICcwMDowMCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb21cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHtzdHlsZToge319XG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgbWUuYWZ0ZXJTZXRSb3dIZWlnaHQobWUucm93SGVpZ2h0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVuZFRpbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RW5kVGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIHRvZG86IGhhbmRsZSAyNDowMCBhcyAyMzo1OVxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLl9lbmRUaW1lID0gJzI0OjAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuYWZ0ZXJTZXRSb3dIZWlnaHQobWUucm93SGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0Um93SGVpZ2h0KHRoaXMucm93SGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZG9tLmNuKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUgICAgID0gbWUuZ2V0VGltZShtZS5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgICA9IG1lLmdldFRpbWUobWUuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICB2ZG9tICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0ICAgPSBtZS5yb3dIZWlnaHQsXG4gICAgICAgICAgICAgICAgcm93c1Blckl0ZW0gPSBtZS5nZXRSb3dzUGVySXRlbSgpLFxuICAgICAgICAgICAgICAgIGl0ZW1IZWlnaHQgID0gcm93c1Blckl0ZW0gKiByb3dIZWlnaHQgKyByb3dzUGVySXRlbSwgLy8gcm93c1Blckl0ZW0gKiAxcHggYm9yZGVyc1xuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ID0gcm93SGVpZ2h0ICsgKChlbmRUaW1lIC0gc3RhcnRUaW1lKSAqIGl0ZW1IZWlnaHQpLFxuICAgICAgICAgICAgICAgIGksIGl0ZW1TdHlsZTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlICAgIDogYGxpbmVhci1ncmFkaWVudCh2YXIoLS1jLXctYmFja2dyb3VuZC1jb2xvcikgJHtpdGVtSGVpZ2h0IC0gMX1weCwgdmFyKC0tYy13LWJvcmRlci1jb2xvcikgMXB4KWAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uWTogYCR7LWl0ZW1IZWlnaHQgKyAxfXB4YCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSAgICAgOiBgMC40ZW0gJHtpdGVtSGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgICAgICAgICAgOiBgJHt0b3RhbEhlaWdodCAtIHJvd0hlaWdodCArIDF9cHhgLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodCAgICAgICAgICA6IGAke3RvdGFsSGVpZ2h0IC0gcm93SGVpZ2h0ICsgMX1weGBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7aXRlbUhlaWdodH1weGBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUubWFyZ2luVG9wID0gYCR7LTIgLSByb3dIZWlnaHQgKiAocm93c1Blckl0ZW0gPT09IDEgPyAwLjUgOiByb3dzUGVySXRlbSA9PT0gMiA/IDEgOiAyKX1weGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1TdHlsZS5tYXJnaW5Ub3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmRvbS5jbltpXS5zdHlsZSA9IGl0ZW1TdHlsZTtcblxuICAgICAgICAgICAgICAgIHZkb20uY25baV0ucmVtb3ZlRG9tID0gKGkgPCBzdGFydFRpbWUgfHwgaSAtIDEgPj0gZW5kVGltZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNpbGVudCB1cGRhdGU6IHRoZSB2aWV3IGNvbnRhaW5pbmcgdGhpcyBjb21wb25lbnQgd2lsbCB0cmlnZ2VyIHRoZSB2ZG9tIHVwZGF0ZVxuICAgICAgICAgICAgbWUuX3Zkb20gPSB2ZG9tO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ICA6IG1lLFxuICAgICAgICAgICAgICAgIHJvd0hlaWdodCAgOiByb3dIZWlnaHQsXG4gICAgICAgICAgICAgICAgcm93c1Blckl0ZW06IHJvd3NQZXJJdGVtLFxuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0OiB0b3RhbEhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0YXJ0VGltZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdGFydFRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0Um93SGVpZ2h0KHRoaXMucm93SGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGludGVydmFsIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0SW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdpbnRlcnZhbCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCB2ZG9tID0gdGhpcy52ZG9tLFxuICAgICAgICAgICAgaHRtbCwgaTtcblxuICAgICAgICB2ZG9tLmNuID0gW107XG5cbiAgICAgICAgZm9yIChpPTA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICBodG1sID0gaSA9PT0gMjQgPyAnMDA6MDAnIDogKGkgPCAxMCA/ICcwJyA6ICcnKSArIGkgKyAnOjAwJztcblxuICAgICAgICAgICAgdmRvbS5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tYy13LXRpbWVheGlzLWl0ZW0nXSxcbiAgICAgICAgICAgICAgICBjbiAgIDogW3todG1sOiBodG1sfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IG9mIHJvd3MgcmVsYXRlZCB0byB0aGUgaW50ZXJ2YWwgY29uZmlnXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dzUGVySXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgPT09IDYwID8gMSA6IHRoaXMuaW50ZXJ2YWwgPT09IDMwID8gMiA6IDQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdGltZSBmb3IgdGhlIGVuZC0gb3Igc3RhcnRUaW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRUaW1lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpWzBdO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoVGltZUF4aXNDb21wb25lbnQpO1xuXG5leHBvcnQge1RpbWVBeGlzQ29tcG9uZW50IGFzIGRlZmF1bHR9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==