"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_week_Component_mjs"],{

/***/ "./src/calendar/view/week/Component.mjs":
/*!**********************************************!*\
  !*** ./src/calendar/view/week/Component.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeAxisComponent.mjs */ "./src/calendar/view/week/TimeAxisComponent.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.week.Component
 * @extends Neo.component.Base
 */
class Component extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getStaticConfig() {return {
        /**
         * Valid values for timeAxisPosition
         * @member {String[]} timeAxisPositions=['end', 'start']
         * @protected
         * @static
         */
        timeAxisPositions: ['end', 'start']
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.Component'
         * @protected
         */
        className: 'Neo.calendar.view.week.Component',
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            enableDrag          : data => data.events.enableDrag,
            endTime             : data => data.endTime,
            eventBorder         : data => data.events.border,
            eventStore          : 'stores.events',
            intlFormat_time     : data => data.intlFormat_time,
            locale              : data => data.locale,
            minimumEventDuration: data => data.minimumEventDuration,
            showWeekends        : data => data.showWeekends,
            startTime           : data => data.startTime,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore_: null,
        /**
         * @member {String[]} cls=['neo-calendar-weekcomponent']
         */
        cls: ['neo-calendar-weekcomponent'],
        /**
         * Amount of hidden columns on both sides each inside this view.
         * @member {Number} columnsBuffer_=7
         */
        columnsBuffer_: 7,
        /**
         * Amount of visible columns inside this view.
         * @member {Number} columnsVisible_=7
         */
        columnsVisible_: 7,
        /**
         * Bound to the view model.
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='short'
         */
        dayNameFormat_: 'short',
        /**
         * Bound to the view model.
         * @member {Boolean} enableDrag_=true
         * @protected
         */
        enableDrag_: true,
        /**
         * Bound to the view model
         * @member {String|null} eventBorder_=null
         */
        eventBorder_: null,
        /**
         * @member {Neo.calendar.view.week.EventDragZone|null} eventDragZone=null
         */
        eventDragZone: null,
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         */
        eventStore_: null,
        /**
         * Will get passed from updateHeader()
         * @member {Date|null} firstColumnDate=null
         * @protected
         */
        firstColumnDate: null,
        /**
         * Internal flag to check if updateHeader(true) has already run
         * @member {Boolean} headerCreated=false
         * @protected
         */
        headerCreated: false,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * Bound to the view model.
         * @member {Intl.DateTimeFormat|null} intlFormat_time_=null
         * @protected
         */
        intlFormat_time_: null,
        /**
         * @member {Boolean} isUpdating=false
         * @protected
         */
        isUpdating: false,
        /**
         * Bound to the view model.
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * Time in minutes. Bound to the view model.
         * @member {Number} minimumEventDuration=30
         * @protected
         */
        minimumEventDuration: 30,
        /**
         * Internal flag to store if updateEvents() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * config values for Neo.calendar.view.week.plugin.DragDrop
         * @member {Object} pluginDragDropConfig=null
         */
        pluginDragDropConfig: null,
        /**
         * config values for Neo.calendar.view.week.plugin.EventResizable
         * @member {Object} pluginResizableConfig=null
         */
        pluginEventResizableConfig: null,
        /**
         * @member {Boolean} showEventEndTime_=false
         */
        showEventEndTime_: false,
        /**
         * Bound to the view model.
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * @member {Object} timeAxis=null
         */
        timeAxis: null,
        /**
         * @member {Object} timeAxisConfig=null
         */
        timeAxisConfig: null,
        /**
         * Position the timeAxis at the left or right side.
         * Valid values are start & end.
         * start => left, end => right in LTR mode.
         * @member {String} timeAxisPosition_='start'
         */
        timeAxisPosition_: 'start',
        /**
         * Internal flag to store the total amount of rendered columns.
         * Changing columnsBuffer or columnsVisible will update this value.
         * @member {Number|null} totalColumns=null
         * @protected
         */
        totalColumns: null,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-scroll-overlay']},
            {cls: ['neo-c-w-scrollcontainer'], flag: 'neo-c-w-scrollcontainer', cn: [
                {cls: ['neo-header-row'], flag: 'neo-header-row', cn: []},
                {cls: ['neo-c-w-column-timeaxis-container'], flag: 'neo-c-w-column-timeaxis-container', cn: [
                    {cls: ['neo-c-w-column-container'], flag: 'neo-c-w-column-container', style: {}, cn: []}
                ]}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the view model.
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            domListeners = me.domListeners;

        domListeners.push(
            {dblclick: me.onEventDoubleClick, scope: me, delegate: '.neo-event'},
            {wheel   : me.onWheel,            scope: me}
        );

        me.domListeners = domListeners;

        me.timeAxis = Neo.create(_TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
            appName  : me.appName,
            parentId : me.id,
            listeners: {
                change: me.onTimeAxisChange,
                scope : me
            },
            ...me.timeAxisConfig
        });

        me.getColumnTimeAxisContainer().cn[me.timeAxisPosition === 'start' ? 'unshift' : 'push'](me.timeAxis.vdom);

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.needsEventUpdate = true;
        }

        me.updateHeader(true, me.needsEventUpdate);

        me.needsEventUpdate && me.updateEvents(false);

        me.headerCreated = true;
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     * @param {Boolean} [silent=false]
     */
    adjustTotalHeight(data, silent=false) {
        let me          = this,
            rowHeight   = data.rowHeight,
            rowsPerItem = data.rowsPerItem,
            height      = data.totalHeight - rowHeight,
            vdom        = me.vdom,
            i           = 0,
            gradient    = [];

        for (; i < rowsPerItem; i++) {
            gradient.push(
                `var(--c-w-background-color) ${i * rowHeight + i}px`,
                `var(--c-w-background-color) ${(i + 1) * rowHeight + i}px`,
                'var(--c-w-border-color) 0'
            );
        }

        Object.assign(me.getColumnContainer().style, {
            backgroundImage: `linear-gradient(${gradient.join(',')})`,
            backgroundSize : `1px ${rowsPerItem * rowHeight + rowsPerItem}px`,
            height         : `${height}px`,
            maxHeight      : `${height}px`
        });

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners);
    }

    /**
     * Triggered after the columnsBuffer config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsBuffer(value, oldValue) {
        this.totalColumns = this.visibleColumns + 2 * value;
    }

    /**
     * Triggered after the columnsVisible config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsVisible(value, oldValue) {
        this.totalColumns = 2 * this.columnsBuffer + value;
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        let me = this;

        if (me.isConstructed) {
            me.updateHeader(false, true);
            me.updateEvents();
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});
        oldValue && me.updateHeader();
    }

    /**
     * Triggered after the enableDrag config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetEnableDrag(value, oldValue) {
        let me = this;

        if (value && !me.getPlugin({flag: 'dragdrop'})) {
            Promise.all([
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_calendar_view_week_plugin_DragDrop_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/DragDrop.mjs */ "./src/calendar/view/week/plugin/DragDrop.mjs")),
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_plugin_Resizable_mjs"), __webpack_require__.e("src_calendar_view_week_plugin_EventResizable_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/EventResizable.mjs */ "./src/calendar/view/week/plugin/EventResizable.mjs"))
            ]).then(modules => {
                let me      = this,
                    plugins = me.plugins || [];

                plugins.push({
                    module : modules[0].default,
                    appName: me.appName,
                    flag   : 'dragdrop',
                    ...me.pluginDragDropConfig
                }, {
                    module       : modules[1].default,
                    appName      : me.appName,
                    delegationCls: 'neo-event',
                    directions   : ['b', 't'],
                    flag         : 'resizable',
                    ...me.pluginEventResizableConfig
                });

                me.plugins = plugins;
            });
        }
    }

    /**
     * Triggered after the eventBorder config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetEventBorder(value, oldValue) {
        let me  = this,
            cls = me.cls;

        oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, `neo-event-border-${oldValue}`);
        value    && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(   cls, `neo-event-border-${value}`);

        me.cls = cls;
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners);
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.intlFormat_day  = new Intl.DateTimeFormat(value, {weekday: me.dayNameFormat});
            me.updateHeader();
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value) {
            if (me.needsEventUpdate) {
                me.updateEvents();
                me.needsEventUpdate = false;
            }

            setTimeout(() => {
                me.getDomRect(me.getColumnContainer().id).then(data => {
                    Neo.main.DomAccess.scrollBy({
                        appName  : me.appName,
                        direction: 'left',
                        id       : me.getScrollContainer().id,
                        value    : data.width * me.columnsBuffer / me.columnsVisible / 3
                    });
                });
            }, 20);
        }
    }

    /**
     * Triggered after the showEventEndTime config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowEventEndTime(value, oldValue) {
        oldValue !== undefined && this.updateEvents();
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-weekends');

        me._cls = cls; // silent update

        if (oldValue !== undefined) {
            me.updateHeader(false, true);
            me.updateEvents();
        }
    }

    /**
     * Triggered after the timeAxisPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTimeAxisPosition(value, oldValue) {
        let me                = this,
            cls               = me.cls,
            vdom              = me.vdom,
            timeAxisContainer = me.getColumnTimeAxisContainer();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value === 'end' ? 'add' : 'remove'](cls, 'neo-timeaxis-end');

        if (oldValue !== undefined) {
            timeAxisContainer.cn.unshift(timeAxisContainer.cn.pop()); // switch the order of the 2 items
        }

        me._cls = cls; // silent update
        me.vdom = vdom;
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        if (oldValue !== undefined) {
            this.updateHeader(false, true);
            this.updateEvents();
        }
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats);
    }

    /**
     * Triggered before the timeAxisPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTimeAxisPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'timeAxisPosition');
    }

    /**
     * Triggered before the weekStartDay config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetWeekStartDay(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'weekStartDay', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.weekStartDays);
    }

    /**
     * @param {Date} date
     * @returns {Object}
     */
    createColumnAndHeader(date) {
        let me          = this,
            columnCls   = ['neo-c-w-column', 'neo-draggable'],
            currentDate = date.getDate(),
            currentDay  = date.getDay(),
            dateCls     = ['neo-date'],
            removeDom   = false,
            column, header;

        if (currentDay === 0 || currentDay === 6) {
            columnCls.push('neo-weekend');
            !me.showWeekends && (removeDom = true);
        }

        if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
            dateCls.push('neo-today');
        }

        column = {cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), removeDom};

        header =
        {cls: ['neo-header-row-item'], removeDom: removeDom, cn: [
            {cls: ['neo-day'], html: me.intlFormat_day.format(date)},
            {cls: dateCls,     html: currentDate}
        ]};

        return {column, header};
    }

    /**
     *
     */
    destroy(...args) {
        this.timeAxis = null;

        super.destroy(...args);
    }

    /**
     *
     */
    getColumnContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-container');
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnId(date) {
        return `${this.id}_col_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`;
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnHeaderId(date) {
        return `${this.id}_ch_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`;
    }

    /**
     *
     */
    getColumnTimeAxisContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-timeaxis-container');
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getEventId(recordId) {
        return `${this.id}__${recordId}`;
    }

    /**
     *
     */
    getHeaderContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-header-row');
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * @returns {String}
     */
    getIdKey() {
        return 'c-w';
    }

    /**
     *
     */
    getScrollContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-scrollcontainer');
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.updateEvents();
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.updateEvents();
    }

    /**
     * @param {Object} data
     */
    onEventDoubleClick(data) {
        if (this.data.events.enableEdit) {
            !data.path[0].cls.includes('neo-event') && data.path.shift();

            let me                 = this,
                editEventContainer = me.owner.editEventContainer,
                eventNode          = data.path[0],
                eventVdom          = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].findVdomChild(me.vdom, eventNode.id).vdom,
                record             = me.eventStore.get(eventVdom.flag),
                style              = editEventContainer.style;

            Object.assign(style, {left: `${eventNode.rect.width + 15}px`, top: eventVdom.style.top});
            editEventContainer.setSilent({parentId: data.path[1].id, record, style});
            editEventContainer.render(true);
        }
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.updateEvents();
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.updateEvents();
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @param {Object[]} data.path
     */
    onFocusChange(data) {
        let oldPath = data.oldPath,
            path    = data.path;

        oldPath?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.appName, {id: oldPath[0].id, cls: {remove: ['neo-focus']}});
        path   ?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.appName, {id: path[0]   .id, cls: {add:    ['neo-focus']}});
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     */
    onTimeAxisChange(data) {
        let me = this;

        me.adjustTotalHeight(data, me.headerCreated);
        me.headerCreated && me.updateEvents();
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (!this.isUpdating && Math.abs(data.deltaX) > Math.abs(data.deltaY)) {
            let me              = this,
                columns         = me.getColumnContainer(),
                columnsBuffer   = me.columnsBuffer,
                columnsVisible  = me.columnsVisible,
                firstColumnDate = me.firstColumnDate,
                header          = me.getHeaderContainer(),
                i               = 0,
                timeAxisWidth   = 50,
                width           = data.clientWidth - timeAxisWidth,
                config, date, scrollValue;

            // console.log(data.scrollLeft, Math.round(data.scrollLeft / (data.clientWidth - timeAxisWidth) * 7));

            if (data.deltaX > 0 && Math.round(data.scrollLeft / width * columnsBuffer) > columnsBuffer + columnsVisible - 1) {
                date = new Date(columns.cn[columns.cn.length - 1].flag);

                columns.cn.splice(0, columnsBuffer);
                header .cn.splice(0, columnsBuffer);

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() + 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.push(config.column);
                    header .cn.push(config.header);
                }

                firstColumnDate.setDate(firstColumnDate.getDate() + columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                setTimeout(() => {me.updateEvents(false, columnsBuffer + columnsVisible, me.totalColumns)}, 50);

                scrollValue = -width;
            }

            else if (data.deltaX < 0 && Math.round(data.scrollLeft / width * columnsBuffer) < 1) {
                date = new Date(columns.cn[0].flag);

                columns.cn.length = columnsBuffer + columnsVisible;
                header .cn.length = columnsBuffer + columnsVisible;

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() - 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.unshift(config.column);
                    header .cn.unshift(config.header);
                }

                firstColumnDate.setDate(firstColumnDate.getDate() - columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                setTimeout(() => {me.updateEvents(false, 0, columnsBuffer)}, 50);

                scrollValue = width;
            }

            if (scrollValue) {
                me.isUpdating = true;

                me.promiseVdomUpdate().then(() => {
                    Neo.main.DomAccess.scrollBy({
                        direction: 'left',
                        id       : me.getScrollContainer().id,
                        value    : scrollValue
                    }).then(() => {
                        me.isUpdating = false;
                    });
                });
            }
        }
    }

    /**
     * @param {Date} date
     */
    setFirstColumnDate(date) {
        date.setDate(date.getDate() - date.getDay() + this.weekStartDay - this.columnsBuffer);
    }

    /**
     * The algorithm relies on the eventStore being sorted by startDate ASC
     * @param {Boolean} [silent=false]
     * @param {Number} [startIndex=0]
     * @param {Number} [endIndex=this.totalColumns]
     */
    updateEvents(silent=false, startIndex=0, endIndex=this.totalColumns) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true;
        } else {
            let calendarStore     = me.calendarStore,
                eventStore        = me.eventStore,
                timeAxis          = me.timeAxis,
                endTime           = timeAxis.getTime(me.endTime),
                startTime         = timeAxis.getTime(me.startTime),
                totalTime         = endTime - startTime,
                date              = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(me.firstColumnDate),
                vdom              = me.vdom,
                content           = me.getColumnContainer(),
                j                 = startIndex,
                showEventEndTime  = me.showEventEndTime,
                calendarRecord, column, dayRecords, duration, endDate, eventCls, eventIntervals, hasOverflow, height, i,
                len, record, recordKey, startDate, startHours, top;

            date.setDate(date.getDate() + startIndex);

            for (; j < endIndex; j++) {
                column = content.cn[j];

                column.cn = []; // remove previous events from the vdom

                dayRecords = eventStore.getDayRecords(date);
                len        = dayRecords.length;

                for (i = 0; i < len; i++) {
                    record         = dayRecords[i];
                    calendarRecord = calendarStore.get(record.calendarId);

                    if (calendarRecord?.active) {
                        endDate   = record.endDate;
                        startDate = record.startDate;

                        if (endTime <= startDate.getHours() || startTime >= endDate.getHours()) {
                            continue;
                        }

                        if (endTime < endDate.getHours()) {
                            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(endDate);
                            endDate.setHours(endTime);
                            endDate.setMinutes(0);
                        }

                        if (startTime > startDate.getHours()) {
                            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(startDate);
                            startDate.setHours(startTime);
                            startDate.setMinutes(0);
                        }

                        duration       = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                        eventCls       = ['neo-event', 'neo-draggable', `neo-${calendarRecord.color}`];
                        eventIntervals = duration * 60 / timeAxis.interval;
                        hasOverflow    = false;
                        height         = Math.round(duration / totalTime * 100 * 1000) / 1000;
                        recordKey      = record[eventStore.keyProperty];
                        startHours     = (startDate.getHours() * 60 + startDate.getMinutes()) / 60;
                        top            = Math.round((startHours - startTime) / totalTime * 100 * 1000) / 1000;

                        if (eventIntervals <= 2) {
                            hasOverflow = timeAxis.rowHeight * eventIntervals < (showEventEndTime ? 50 : 34);

                            if (hasOverflow && !(showEventEndTime && (timeAxis.rowHeight / eventIntervals >= 34))) {
                                eventCls.push('neo-overflow');
                            }
                        }

                        showEventEndTime = !(hasOverflow && eventIntervals === 1 || !showEventEndTime);

                        showEventEndTime && eventCls.push('neo-show-end-time');

                        column.cn.push({
                            cls     : eventCls,
                            flag    : recordKey,
                            id      : me.getEventId(recordKey),
                            tabIndex: -1,

                            cn: [{
                                cls : ['neo-event-time'],
                                html: me.intlFormat_time.format(record.startDate),
                                id  : `${me.id}__time__${recordKey}`
                            }, {
                                cls : ['neo-event-title'],
                                html: record.title,
                                id  : `${me.id}__title__${recordKey}`
                            }, {
                                cls      : ['neo-event-time', 'neo-event-end-time'],
                                html     : me.intlFormat_time.format(record.endDate),
                                id       : `${me.id}__enddate__${recordKey}`,
                                removeDom: !showEventEndTime
                            }],

                            style: {
                                height: `calc(${height}% - 2px)`,
                                top   : `calc(${top}% + 1px)`,
                                width : 'calc(100% - 1px)'
                            }
                        });
                    }
                }

                date.setDate(date.getDate() + 1);
            }

            me[silent ? '_vdom' : 'vdom'] = vdom;
        }
    }

    /**
     * @param {Boolean} [create=false]
     * @param {Boolean} [silent=false]
     */
    updateHeader(create=false, silent=false) {
        let me           = this,
            date         = me.currentDate, // cloned
            vdom         = me.vdom,
            content      = me.getColumnContainer(),
            header       = me.getHeaderContainer(),
            i            = 0,
            showWeekends = me.showWeekends,
            columnCls, currentDate, currentDay, dateCls, headerId, removeDom;

        me.setFirstColumnDate(date);

        me.firstColumnDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(date);

        for (; i < me.totalColumns; i++) {
            columnCls   = ['neo-c-w-column', 'neo-draggable'];
            currentDate = date.getDate();
            currentDay  = date.getDay();
            dateCls     = ['neo-date'];
            removeDom   = false;

            if (currentDay === 0 || currentDay === 6) {
                columnCls.push('neo-weekend');
                !showWeekends && (removeDom = true);
            }

            if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
                dateCls.push('neo-today');
            }

            headerId = me.getColumnHeaderId(date);

            if (create) {
                content.cn.push({cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), id: me.getColumnId(date), removeDom});

                header.cn.push(
                {cls: ['neo-header-row-item'], id: headerId, removeDom, cn: [
                    {cls: ['neo-day'], html: me.intlFormat_day.format(date), id: `${headerId}_day`},
                    {cls : dateCls,    html: currentDate,                    id: `${headerId}_date`}
                ]});
            } else {
                Object.assign(content.cn[i], {
                    cls : columnCls,
                    flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date),
                    id  : me.getColumnId(date),
                    removeDom
                });

                Object.assign(header.cn[i], {id: headerId, removeDom});
                Object.assign(header.cn[i].cn[0], {html: me.intlFormat_day.format(date), id: `${headerId}_day`});
                Object.assign(header.cn[i].cn[1], {cls: dateCls, html: currentDate, id: `${headerId}_date`});
            }

            date.setDate(date.getDate() + 1);
        }

        me[silent ? '_vdom' : 'vdom'] = vdom;
    }
}

Neo.applyClassConfig(Component);




/***/ }),

/***/ "./src/calendar/view/week/TimeAxisComponent.mjs":
/*!******************************************************!*\
  !*** ./src/calendar/view/week/TimeAxisComponent.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TimeAxisComponent)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.calendar.view.week.TimeAxisComponent
 * @extends Neo.container.Base
 */
class TimeAxisComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getStaticConfig() {return {
        /**
         * Valid values for interval
         * @member {Number[]} intervals=[15, 30, 60]
         * @protected
         * @static
         */
        intervals: [15, 30, 60]
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.TimeAxisComponent'
         * @protected
         */
        className: 'Neo.calendar.view.week.TimeAxisComponent',
        /**
         * @member {Object} bind
         */
        bind: {
            endTime  : data => data.endTime,
            startTime: data => data.startTime
        },
        /**
         * @member {String[]} cls=['neo-calendar-timeaxis']
         */
        cls: ['neo-calendar-timeaxis'],
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         */
        endTime_: '24:00',
        /**
         * The time interval in minutes to display as rows.
         * Valid values: 15, 30, 60
         * @member {Number} interval_=30
         */
        interval_: 30,
        /**
         * @member {Number} rowHeight_=20
         */
        rowHeight_: 20,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         */
        startTime_: '00:00',
        /**
         * @member {Object} vdom
         */
        vdom:
        {style: {}}
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItems();
        me.afterSetRowHeight(me.rowHeight, 0);
    }

    /**
     * Triggered after the endTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetEndTime(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            // todo: handle 24:00 as 23:59
            if (!value) {
                me._endTime = '24:00';
            }

            me.afterSetRowHeight(me.rowHeight, 0);
        }
    }

    /**
     * Triggered after the interval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInterval(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0);
        }
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (oldValue !== undefined && this.vdom.cn) {
            let me          = this,
                endTime     = me.getTime(me.endTime),
                startTime   = me.getTime(me.startTime),
                vdom        = me.vdom,
                rowHeight   = me.rowHeight,
                rowsPerItem = me.getRowsPerItem(),
                itemHeight  = rowsPerItem * rowHeight + rowsPerItem, // rowsPerItem * 1px borders
                totalHeight = rowHeight + ((endTime - startTime) * itemHeight),
                i, itemStyle;

            Object.assign(vdom.style, {
                backgroundImage    : `linear-gradient(var(--c-w-background-color) ${itemHeight - 1}px, var(--c-w-border-color) 1px)`,
                backgroundPositionY: `${-itemHeight + 1}px`,
                backgroundSize     : `0.4em ${itemHeight}px`,
                height             : `${totalHeight - rowHeight + 1}px`,
                maxHeight          : `${totalHeight - rowHeight + 1}px`
            });

            for (i=0; i < 25; i++) {
                itemStyle = {
                    height: `${itemHeight}px`
                };

                if (i === startTime) {
                    itemStyle.marginTop = `${-2 - rowHeight * (rowsPerItem === 1 ? 0.5 : rowsPerItem === 2 ? 1 : 2)}px`;
                } else {
                    delete itemStyle.marginTop;
                }

                vdom.cn[i].style = itemStyle;

                vdom.cn[i].removeDom = (i < startTime || i - 1 >= endTime);
            }

            // silent update: the view containing this component will trigger the vdom update
            me._vdom = vdom;

            me.fire('change', {
                component: me,
                rowHeight,
                rowsPerItem,
                totalHeight
            });
        }
    }

    /**
     * Triggered after the startTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetStartTime(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0);
        }
    }

    /**
     * Triggered before the interval config gets changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    beforeSetInterval(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'interval');
    }

    /**
     *
     */
    createItems() {
        let vdom = this.vdom,
            html, i;

        vdom.cn = [];

        for (i=0; i < 25; i++) {
            html = i === 24 ? '00:00' : (i < 10 ? '0' : '') + i + ':00';

            vdom.cn.push({
                cls  : ['neo-c-w-timeaxis-item'],
                cn   : [{html: html}]
            });
        }
    }

    /**
     * Calculates the amount of rows related to the interval config
     * @returns {Number}
     */
    getRowsPerItem() {
        return this.interval === 60 ? 1 : this.interval === 30 ? 2 : 4;
    }

    /**
     * Calculates the time for the end- or startTime
     * @param {String} value
     * @returns {Number}
     */
    getTime(value) {
        return value.split(':').map(Number)[0];
    }
}

Neo.applyClassConfig(TimeAxisComponent);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X3dlZWtfQ29tcG9uZW50X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDTDtBQUNDO0FBQ0E7QUFDRDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBYTtBQUNyQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBMkM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FB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c0IsUUFBUTtBQUM5QjtBQUNBLCtCQUErQixXQUFXO0FBQzFDOztBQUVBO0FBQ0EsNkNBQTZDLHVFQUF1RTtBQUNwSCxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQyxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L3dlZWsvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9UaW1lQXhpc0NvbXBvbmVudC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VDb21wb25lbnQgICAgIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgRGF0ZVV0aWwgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFRpbWVBeGlzQ29tcG9uZW50IGZyb20gJy4vVGltZUF4aXNDb21wb25lbnQubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL1ZEb20ubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuY29uc3QgdG9kYXkgPSB7XG4gICAgZGF5ICA6IHRvZGF5RGF0ZS5nZXREYXRlKCksXG4gICAgbW9udGg6IHRvZGF5RGF0ZS5nZXRNb250aCgpLFxuICAgIHllYXIgOiB0b2RheURhdGUuZ2V0RnVsbFllYXIoKVxufTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRpbWVBeGlzUG9zaXRpb25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHRpbWVBeGlzUG9zaXRpb25zPVsnZW5kJywgJ3N0YXJ0J11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lQXhpc1Bvc2l0aW9uczogWydlbmQnLCAnc3RhcnQnXVxuICAgIH19XG5cbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZSAgICAgICA6ICdzdG9yZXMuY2FsZW5kYXJzJyxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlICAgICAgICAgOiBkYXRhID0+IGRhdGEuY3VycmVudERhdGUsXG4gICAgICAgICAgICBlbmFibGVEcmFnICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmV2ZW50cy5lbmFibGVEcmFnLFxuICAgICAgICAgICAgZW5kVGltZSAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5lbmRUaW1lLFxuICAgICAgICAgICAgZXZlbnRCb3JkZXIgICAgICAgICA6IGRhdGEgPT4gZGF0YS5ldmVudHMuYm9yZGVyLFxuICAgICAgICAgICAgZXZlbnRTdG9yZSAgICAgICAgICA6ICdzdG9yZXMuZXZlbnRzJyxcbiAgICAgICAgICAgIGludGxGb3JtYXRfdGltZSAgICAgOiBkYXRhID0+IGRhdGEuaW50bEZvcm1hdF90aW1lLFxuICAgICAgICAgICAgbG9jYWxlICAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5sb2NhbGUsXG4gICAgICAgICAgICBtaW5pbXVtRXZlbnREdXJhdGlvbjogZGF0YSA9PiBkYXRhLm1pbmltdW1FdmVudER1cmF0aW9uLFxuICAgICAgICAgICAgc2hvd1dlZWtlbmRzICAgICAgICA6IGRhdGEgPT4gZGF0YS5zaG93V2Vla2VuZHMsXG4gICAgICAgICAgICBzdGFydFRpbWUgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLnN0YXJ0VGltZSxcbiAgICAgICAgICAgIHdlZWtTdGFydERheSAgICAgICAgOiBkYXRhID0+IGRhdGEud2Vla1N0YXJ0RGF5XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IGNhbGVuZGFyU3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ25lby1jYWxlbmRhci13ZWVrY29tcG9uZW50J11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8tY2FsZW5kYXItd2Vla2NvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIGhpZGRlbiBjb2x1bW5zIG9uIGJvdGggc2lkZXMgZWFjaCBpbnNpZGUgdGhpcyB2aWV3LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtbnNCdWZmZXJfPTdcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbnNCdWZmZXJfOiA3LFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIHZpc2libGUgY29sdW1ucyBpbnNpZGUgdGhpcyB2aWV3LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtbnNWaXNpYmxlXz03XG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5zVmlzaWJsZV86IDcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBjdXJyZW50RGF0ZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50RGF0ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBjb2x1bW4gaGVhZGVycy5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZTogbmFycm93LCBzaG9ydCAmIGxvbmdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkYXlOYW1lRm9ybWF0Xz0nc2hvcnQnXG4gICAgICAgICAqL1xuICAgICAgICBkYXlOYW1lRm9ybWF0XzogJ3Nob3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVEcmFnXz10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZURyYWdfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGV2ZW50Qm9yZGVyXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudEJvcmRlcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmV8bnVsbH0gZXZlbnREcmFnWm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudERyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSBldmVudFN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZ2V0IHBhc3NlZCBmcm9tIHVwZGF0ZUhlYWRlcigpXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV8bnVsbH0gZmlyc3RDb2x1bW5EYXRlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZmlyc3RDb2x1bW5EYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBjaGVjayBpZiB1cGRhdGVIZWFkZXIodHJ1ZSkgaGFzIGFscmVhZHkgcnVuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhlYWRlckNyZWF0ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyQ3JlYXRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfZGF5PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF9kYXk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X3RpbWVfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF90aW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVXBkYXRpbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNVcGRhdGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsb2NhbGVfPU5lby5jb25maWcubG9jYWxlXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGVfOiBOZW8uY29uZmlnLmxvY2FsZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgaW4gbWludXRlcy4gQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWluaW11bUV2ZW50RHVyYXRpb249MzBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWluaW11bUV2ZW50RHVyYXRpb246IDMwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBzdG9yZSBpZiB1cGRhdGVFdmVudHMoKSBnb3QgY2FsbGVkIHdoaWxlIG5vdCBiZWluZyBtb3VudGVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG5lZWRzRXZlbnRVcGRhdGU9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmVlZHNFdmVudFVwZGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb25maWcgdmFsdWVzIGZvciBOZW8uY2FsZW5kYXIudmlldy53ZWVrLnBsdWdpbi5EcmFnRHJvcFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHBsdWdpbkRyYWdEcm9wQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBsdWdpbkRyYWdEcm9wQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogY29uZmlnIHZhbHVlcyBmb3IgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5wbHVnaW4uRXZlbnRSZXNpemFibGVcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBwbHVnaW5SZXNpemFibGVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luRXZlbnRSZXNpemFibGVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93RXZlbnRFbmRUaW1lXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0V2ZW50RW5kVGltZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dXZWVrZW5kc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1dlZWtlbmRzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdGltZUF4aXM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGltZUF4aXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRpbWVBeGlzQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVBeGlzQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gdGhlIHRpbWVBeGlzIGF0IHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmUgc3RhcnQgJiBlbmQuXG4gICAgICAgICAqIHN0YXJ0ID0+IGxlZnQsIGVuZCA9PiByaWdodCBpbiBMVFIgbW9kZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aW1lQXhpc1Bvc2l0aW9uXz0nc3RhcnQnXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lQXhpc1Bvc2l0aW9uXzogJ3N0YXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgdGhlIHRvdGFsIGFtb3VudCBvZiByZW5kZXJlZCBjb2x1bW5zLlxuICAgICAgICAgKiBDaGFuZ2luZyBjb2x1bW5zQnVmZmVyIG9yIGNvbHVtbnNWaXNpYmxlIHdpbGwgdXBkYXRlIHRoaXMgdmFsdWUuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0b3RhbENvbHVtbnM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbENvbHVtbnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb21cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tc2Nyb2xsLW92ZXJsYXknXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1jLXctc2Nyb2xsY29udGFpbmVyJ10sIGZsYWc6ICduZW8tYy13LXNjcm9sbGNvbnRhaW5lcicsIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8taGVhZGVyLXJvdyddLCBmbGFnOiAnbmVvLWhlYWRlci1yb3cnLCBjbjogW119LFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWMtdy1jb2x1bW4tdGltZWF4aXMtY29udGFpbmVyJ10sIGZsYWc6ICduZW8tYy13LWNvbHVtbi10aW1lYXhpcy1jb250YWluZXInLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jLXctY29sdW1uLWNvbnRhaW5lciddLCBmbGFnOiAnbmVvLWMtdy1jb2x1bW4tY29udGFpbmVyJywgc3R5bGU6IHt9LCBjbjogW119XG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19LFxuICAgICAgICAvKipcbiAgICAgICAgICogMC02ID0+IFN1bi1TYXRcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2Vla1N0YXJ0RGF5Xz0wXG4gICAgICAgICAqL1xuICAgICAgICB3ZWVrU3RhcnREYXlfOiAwXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gbWUuZG9tTGlzdGVuZXJzO1xuXG4gICAgICAgIGRvbUxpc3RlbmVycy5wdXNoKFxuICAgICAgICAgICAge2RibGNsaWNrOiBtZS5vbkV2ZW50RG91YmxlQ2xpY2ssIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWV2ZW50J30sXG4gICAgICAgICAgICB7d2hlZWwgICA6IG1lLm9uV2hlZWwsICAgICAgICAgICAgc2NvcGU6IG1lfVxuICAgICAgICApO1xuXG4gICAgICAgIG1lLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVycztcblxuICAgICAgICBtZS50aW1lQXhpcyA9IE5lby5jcmVhdGUoVGltZUF4aXNDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGFwcE5hbWUgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IG1lLm9uVGltZUF4aXNDaGFuZ2UsXG4gICAgICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLm1lLnRpbWVBeGlzQ29uZmlnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmdldENvbHVtblRpbWVBeGlzQ29udGFpbmVyKCkuY25bbWUudGltZUF4aXNQb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10obWUudGltZUF4aXMudmRvbSk7XG5cbiAgICAgICAgaWYgKG1lLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgbWUuZXZlbnRTdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGVIZWFkZXIodHJ1ZSwgbWUubmVlZHNFdmVudFVwZGF0ZSk7XG5cbiAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSAmJiBtZS51cGRhdGVFdmVudHMoZmFsc2UpO1xuXG4gICAgICAgIG1lLmhlYWRlckNyZWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93SGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93c1Blckl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS50b3RhbEhlaWdodFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICBhZGp1c3RUb3RhbEhlaWdodChkYXRhLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJvd0hlaWdodCAgID0gZGF0YS5yb3dIZWlnaHQsXG4gICAgICAgICAgICByb3dzUGVySXRlbSA9IGRhdGEucm93c1Blckl0ZW0sXG4gICAgICAgICAgICBoZWlnaHQgICAgICA9IGRhdGEudG90YWxIZWlnaHQgLSByb3dIZWlnaHQsXG4gICAgICAgICAgICB2ZG9tICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBncmFkaWVudCAgICA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBpIDwgcm93c1Blckl0ZW07IGkrKykge1xuICAgICAgICAgICAgZ3JhZGllbnQucHVzaChcbiAgICAgICAgICAgICAgICBgdmFyKC0tYy13LWJhY2tncm91bmQtY29sb3IpICR7aSAqIHJvd0hlaWdodCArIGl9cHhgLFxuICAgICAgICAgICAgICAgIGB2YXIoLS1jLXctYmFja2dyb3VuZC1jb2xvcikgJHsoaSArIDEpICogcm93SGVpZ2h0ICsgaX1weGAsXG4gICAgICAgICAgICAgICAgJ3ZhcigtLWMtdy1ib3JkZXItY29sb3IpIDAnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZS5nZXRDb2x1bW5Db250YWluZXIoKS5zdHlsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgbGluZWFyLWdyYWRpZW50KCR7Z3JhZGllbnQuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgYmFja2dyb3VuZFNpemUgOiBgMXB4ICR7cm93c1Blckl0ZW0gKiByb3dIZWlnaHQgKyByb3dzUGVySXRlbX1weGAsXG4gICAgICAgICAgICBoZWlnaHQgICAgICAgICA6IGAke2hlaWdodH1weGAsXG4gICAgICAgICAgICBtYXhIZWlnaHQgICAgICA6IGAke2hlaWdodH1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2FsZW5kYXJTdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDYWxlbmRhclN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25DYWxlbmRhclN0b3JlTG9hZCxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25DYWxlbmRhclN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHVtbnNCdWZmZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sdW1uc0J1ZmZlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy50b3RhbENvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zICsgMiAqIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sdW1uc1Zpc2libGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sdW1uc1Zpc2libGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudG90YWxDb2x1bW5zID0gMiAqIHRoaXMuY29sdW1uc0J1ZmZlciArIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY3VycmVudERhdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtEYXRlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDdXJyZW50RGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW50bEZvcm1hdF9kYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChtZS5sb2NhbGUsIHt3ZWVrZGF5OiB2YWx1ZX0pO1xuICAgICAgICBvbGRWYWx1ZSAmJiBtZS51cGRhdGVIZWFkZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVuYWJsZURyYWcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFbmFibGVEcmFnKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuZ2V0UGx1Z2luKHtmbGFnOiAnZHJhZ2Ryb3AnfSkpIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4vcGx1Z2luL0RyYWdEcm9wLm1qcycpLFxuICAgICAgICAgICAgICAgIGltcG9ydCgnLi9wbHVnaW4vRXZlbnRSZXNpemFibGUubWpzJylcbiAgICAgICAgICAgIF0pLnRoZW4obW9kdWxlcyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSA6IG1vZHVsZXNbMF0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmxhZyAgIDogJ2RyYWdkcm9wJyxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUucGx1Z2luRHJhZ0Ryb3BDb25maWdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IG1vZHVsZXNbMV0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGlvbkNsczogJ25lby1ldmVudCcsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgICA6IFsnYicsICd0J10sXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgICAgICAgICA6ICdyZXNpemFibGUnLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5wbHVnaW5FdmVudFJlc2l6YWJsZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRCb3JkZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50Qm9yZGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBvbGRWYWx1ZSAmJiBOZW9BcnJheS5yZW1vdmUoY2xzLCBgbmVvLWV2ZW50LWJvcmRlci0ke29sZFZhbHVlfWApO1xuICAgICAgICB2YWx1ZSAgICAmJiBOZW9BcnJheS5hZGQoICAgY2xzLCBgbmVvLWV2ZW50LWJvcmRlci0ke3ZhbHVlfWApO1xuXG4gICAgICAgIG1lLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50U3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uRXZlbnRTdG9yZUxvYWQsXG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uRXZlbnRTdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfTtcblxuICAgICAgICBvbGRWYWx1ZT8udW4obGlzdGVuZXJzKTtcbiAgICAgICAgdmFsdWUgICA/Lm9uKGxpc3RlbmVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsb2NhbGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TG9jYWxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmludGxGb3JtYXRfZGF5ICA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHZhbHVlLCB7d2Vla2RheTogbWUuZGF5TmFtZUZvcm1hdH0pO1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1lLm5lZWRzRXZlbnRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVFdmVudHMoKTtcbiAgICAgICAgICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmdldERvbVJlY3QobWUuZ2V0Q29sdW1uQ29udGFpbmVyKCkuaWQpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxCeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUuZ2V0U2Nyb2xsQ29udGFpbmVyKCkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IGRhdGEud2lkdGggKiBtZS5jb2x1bW5zQnVmZmVyIC8gbWUuY29sdW1uc1Zpc2libGUgLyAzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93RXZlbnRFbmRUaW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0V2ZW50RW5kVGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnVwZGF0ZUV2ZW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd1dlZWtlbmRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd1dlZWtlbmRzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1zaG93LXdlZWtlbmRzJyk7XG5cbiAgICAgICAgbWUuX2NscyA9IGNsczsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVIZWFkZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRpbWVBeGlzUG9zaXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGltZUF4aXNQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgID0gbWUuY2xzLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgdGltZUF4aXNDb250YWluZXIgPSBtZS5nZXRDb2x1bW5UaW1lQXhpc0NvbnRhaW5lcigpO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID09PSAnZW5kJyA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby10aW1lYXhpcy1lbmQnKTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZUF4aXNDb250YWluZXIuY24udW5zaGlmdCh0aW1lQXhpc0NvbnRhaW5lci5jbi5wb3AoKSk7IC8vIHN3aXRjaCB0aGUgb3JkZXIgb2YgdGhlIDIgaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLl9jbHMgPSBjbHM7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgbWUudmRvbSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3ZWVrU3RhcnREYXkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2Vla1N0YXJ0RGF5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFkZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRheU5hbWVGb3JtYXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREYXlOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGF5TmFtZUZvcm1hdCcsIERhdGVVdGlsLnByb3RvdHlwZS5kYXlOYW1lRm9ybWF0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdGltZUF4aXNQb3NpdGlvbiBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFRpbWVBeGlzUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICd0aW1lQXhpc1Bvc2l0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgd2Vla1N0YXJ0RGF5IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0V2Vla1N0YXJ0RGF5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnd2Vla1N0YXJ0RGF5JywgRGF0ZVV0aWwucHJvdG90eXBlLndlZWtTdGFydERheXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlQ29sdW1uQW5kSGVhZGVyKGRhdGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbkNscyAgID0gWyduZW8tYy13LWNvbHVtbicsICduZW8tZHJhZ2dhYmxlJ10sXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgY3VycmVudERheSAgPSBkYXRlLmdldERheSgpLFxuICAgICAgICAgICAgZGF0ZUNscyAgICAgPSBbJ25lby1kYXRlJ10sXG4gICAgICAgICAgICByZW1vdmVEb20gICA9IGZhbHNlLFxuICAgICAgICAgICAgY29sdW1uLCBoZWFkZXI7XG5cbiAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgY29sdW1uQ2xzLnB1c2goJ25lby13ZWVrZW5kJyk7XG4gICAgICAgICAgICAhbWUuc2hvd1dlZWtlbmRzICYmIChyZW1vdmVEb20gPSB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGF0ZSA9PT0gdG9kYXkuZGF5ICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gdG9kYXkubW9udGggJiYgZGF0ZS5nZXRGdWxsWWVhcigpID09PSB0b2RheS55ZWFyKSB7XG4gICAgICAgICAgICBkYXRlQ2xzLnB1c2goJ25lby10b2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1uID0ge2NsczogY29sdW1uQ2xzLCBmbGFnOiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKSwgcmVtb3ZlRG9tfTtcblxuICAgICAgICBoZWFkZXIgPVxuICAgICAgICB7Y2xzOiBbJ25lby1oZWFkZXItcm93LWl0ZW0nXSwgcmVtb3ZlRG9tOiByZW1vdmVEb20sIGNuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1kYXknXSwgaHRtbDogbWUuaW50bEZvcm1hdF9kYXkuZm9ybWF0KGRhdGUpfSxcbiAgICAgICAgICAgIHtjbHM6IGRhdGVDbHMsICAgICBodG1sOiBjdXJyZW50RGF0ZX1cbiAgICAgICAgXX07XG5cbiAgICAgICAgcmV0dXJuIHtjb2x1bW4sIGhlYWRlcn07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy50aW1lQXhpcyA9IG51bGw7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldENvbHVtbkNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LWNvbHVtbi1jb250YWluZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbHVtbklkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X2NvbF8ke0RhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5IZWFkZXJJZChkYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9jaF8ke0RhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5UaW1lQXhpc0NvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LWNvbHVtbi10aW1lYXhpcy1jb250YWluZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRFdmVudElkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtyZWNvcmRJZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZ2V0QnlGbGFnKHRoaXMudmRvbSwgJ25lby1oZWFkZXItcm93Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnNpZGUgY3JlYXRlSWQoKSBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBwYXNzZWQgdG8gdGhlIElkR2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWRLZXkoKSB7XG4gICAgICAgIHJldHVybiAnYy13JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFNjcm9sbENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LXNjcm9sbGNvbnRhaW5lcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVMb2FkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwICYmIHRoaXMudXBkYXRlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ldmVudHMuZW5hYmxlRWRpdCkge1xuICAgICAgICAgICAgIWRhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpICYmIGRhdGEucGF0aC5zaGlmdCgpO1xuXG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIgPSBtZS5vd25lci5lZGl0RXZlbnRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgZXZlbnROb2RlICAgICAgICAgID0gZGF0YS5wYXRoWzBdLFxuICAgICAgICAgICAgICAgIGV2ZW50VmRvbSAgICAgICAgICA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUudmRvbSwgZXZlbnROb2RlLmlkKS52ZG9tLFxuICAgICAgICAgICAgICAgIHJlY29yZCAgICAgICAgICAgICA9IG1lLmV2ZW50U3RvcmUuZ2V0KGV2ZW50VmRvbS5mbGFnKSxcbiAgICAgICAgICAgICAgICBzdHlsZSAgICAgICAgICAgICAgPSBlZGl0RXZlbnRDb250YWluZXIuc3R5bGU7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHtsZWZ0OiBgJHtldmVudE5vZGUucmVjdC53aWR0aCArIDE1fXB4YCwgdG9wOiBldmVudFZkb20uc3R5bGUudG9wfSk7XG4gICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIuc2V0U2lsZW50KHtwYXJlbnRJZDogZGF0YS5wYXRoWzFdLmlkLCByZWNvcmQsIHN0eWxlfSk7XG4gICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIucmVuZGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudFN0b3JlUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aFxuICAgICAqL1xuICAgIG9uRm9jdXNDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgb2xkUGF0aCA9IGRhdGEub2xkUGF0aCxcbiAgICAgICAgICAgIHBhdGggICAgPSBkYXRhLnBhdGg7XG5cbiAgICAgICAgb2xkUGF0aD8uWzBdPy5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpICYmIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtpZDogb2xkUGF0aFswXS5pZCwgY2xzOiB7cmVtb3ZlOiBbJ25lby1mb2N1cyddfX0pO1xuICAgICAgICBwYXRoICAgPy5bMF0/LmNscy5pbmNsdWRlcygnbmVvLWV2ZW50JykgJiYgTmVvLmFwcGx5RGVsdGFzKHRoaXMuYXBwTmFtZSwge2lkOiBwYXRoWzBdICAgLmlkLCBjbHM6IHthZGQ6ICAgIFsnbmVvLWZvY3VzJ119fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dzUGVySXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnRvdGFsSGVpZ2h0XG4gICAgICovXG4gICAgb25UaW1lQXhpc0NoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRqdXN0VG90YWxIZWlnaHQoZGF0YSwgbWUuaGVhZGVyQ3JlYXRlZCk7XG4gICAgICAgIG1lLmhlYWRlckNyZWF0ZWQgJiYgbWUudXBkYXRlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldoZWVsKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRpbmcgJiYgTWF0aC5hYnMoZGF0YS5kZWx0YVgpID4gTWF0aC5hYnMoZGF0YS5kZWx0YVkpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjb2x1bW5zICAgICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zQnVmZmVyICAgPSBtZS5jb2x1bW5zQnVmZmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbnNWaXNpYmxlICA9IG1lLmNvbHVtbnNWaXNpYmxlLFxuICAgICAgICAgICAgICAgIGZpcnN0Q29sdW1uRGF0ZSA9IG1lLmZpcnN0Q29sdW1uRGF0ZSxcbiAgICAgICAgICAgICAgICBoZWFkZXIgICAgICAgICAgPSBtZS5nZXRIZWFkZXJDb250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIHRpbWVBeGlzV2lkdGggICA9IDUwLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICAgICA9IGRhdGEuY2xpZW50V2lkdGggLSB0aW1lQXhpc1dpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZywgZGF0ZSwgc2Nyb2xsVmFsdWU7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEuc2Nyb2xsTGVmdCwgTWF0aC5yb3VuZChkYXRhLnNjcm9sbExlZnQgLyAoZGF0YS5jbGllbnRXaWR0aCAtIHRpbWVBeGlzV2lkdGgpICogNykpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5kZWx0YVggPiAwICYmIE1hdGgucm91bmQoZGF0YS5zY3JvbGxMZWZ0IC8gd2lkdGggKiBjb2x1bW5zQnVmZmVyKSA+IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZSAtIDEpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoY29sdW1ucy5jbltjb2x1bW5zLmNuLmxlbmd0aCAtIDFdLmZsYWcpO1xuXG4gICAgICAgICAgICAgICAgY29sdW1ucy5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgaGVhZGVyIC5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvbHVtbnNCdWZmZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBtZS5jcmVhdGVDb2x1bW5BbmRIZWFkZXIoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5jbi5wdXNoKGNvbmZpZy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLnB1c2goY29uZmlnLmhlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyc3RDb2x1bW5EYXRlLnNldERhdGUoZmlyc3RDb2x1bW5EYXRlLmdldERhdGUoKSArIGNvbHVtbnNCdWZmZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIG1vdmUgdGhlIGV2ZW50IHJlbmRlcmluZyBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgICAgICAgICAgICAvLyBEZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjIxNlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge21lLnVwZGF0ZUV2ZW50cyhmYWxzZSwgY29sdW1uc0J1ZmZlciArIGNvbHVtbnNWaXNpYmxlLCBtZS50b3RhbENvbHVtbnMpfSwgNTApO1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuZGVsdGFYIDwgMCAmJiBNYXRoLnJvdW5kKGRhdGEuc2Nyb2xsTGVmdCAvIHdpZHRoICogY29sdW1uc0J1ZmZlcikgPCAxKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGNvbHVtbnMuY25bMF0uZmxhZyk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcbiAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY29sdW1uc0J1ZmZlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lLmNyZWF0ZUNvbHVtbkFuZEhlYWRlcihkYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLnVuc2hpZnQoY29uZmlnLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciAuY24udW5zaGlmdChjb25maWcuaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJzdENvbHVtbkRhdGUuc2V0RGF0ZShmaXJzdENvbHVtbkRhdGUuZ2V0RGF0ZSgpIC0gY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2hvcnQgZGVsYXkgdG8gbW92ZSB0aGUgZXZlbnQgcmVuZGVyaW5nIGludG8gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAgICAgICAgICAgIC8vIERldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMjE2XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7bWUudXBkYXRlRXZlbnRzKGZhbHNlLCAwLCBjb2x1bW5zQnVmZmVyKX0sIDUwKTtcblxuICAgICAgICAgICAgICAgIHNjcm9sbFZhbHVlID0gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5nZXRTY3JvbGxDb250YWluZXIoKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogc2Nyb2xsVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICovXG4gICAgc2V0Rmlyc3RDb2x1bW5EYXRlKGRhdGUpIHtcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gZGF0ZS5nZXREYXkoKSArIHRoaXMud2Vla1N0YXJ0RGF5IC0gdGhpcy5jb2x1bW5zQnVmZmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWxnb3JpdGhtIHJlbGllcyBvbiB0aGUgZXZlbnRTdG9yZSBiZWluZyBzb3J0ZWQgYnkgc3RhcnREYXRlIEFTQ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXg9MF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4PXRoaXMudG90YWxDb2x1bW5zXVxuICAgICAqL1xuICAgIHVwZGF0ZUV2ZW50cyhzaWxlbnQ9ZmFsc2UsIHN0YXJ0SW5kZXg9MCwgZW5kSW5kZXg9dGhpcy50b3RhbENvbHVtbnMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNhbGVuZGFyU3RvcmUgICAgID0gbWUuY2FsZW5kYXJTdG9yZSxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlICAgICAgICA9IG1lLmV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgdGltZUF4aXMgICAgICAgICAgPSBtZS50aW1lQXhpcyxcbiAgICAgICAgICAgICAgICBlbmRUaW1lICAgICAgICAgICA9IHRpbWVBeGlzLmdldFRpbWUobWUuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lICAgICAgICAgPSB0aW1lQXhpcy5nZXRUaW1lKG1lLnN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgdG90YWxUaW1lICAgICAgICAgPSBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGRhdGUgICAgICAgICAgICAgID0gRGF0ZVV0aWwuY2xvbmUobWUuZmlyc3RDb2x1bW5EYXRlKSxcbiAgICAgICAgICAgICAgICB2ZG9tICAgICAgICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICAgICAgY29udGVudCAgICAgICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBqICAgICAgICAgICAgICAgICA9IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSAgPSBtZS5zaG93RXZlbnRFbmRUaW1lLFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyUmVjb3JkLCBjb2x1bW4sIGRheVJlY29yZHMsIGR1cmF0aW9uLCBlbmREYXRlLCBldmVudENscywgZXZlbnRJbnRlcnZhbHMsIGhhc092ZXJmbG93LCBoZWlnaHQsIGksXG4gICAgICAgICAgICAgICAgbGVuLCByZWNvcmQsIHJlY29yZEtleSwgc3RhcnREYXRlLCBzdGFydEhvdXJzLCB0b3A7XG5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0YXJ0SW5kZXgpO1xuXG4gICAgICAgICAgICBmb3IgKDsgaiA8IGVuZEluZGV4OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb250ZW50LmNuW2pdO1xuXG4gICAgICAgICAgICAgICAgY29sdW1uLmNuID0gW107IC8vIHJlbW92ZSBwcmV2aW91cyBldmVudHMgZnJvbSB0aGUgdmRvbVxuXG4gICAgICAgICAgICAgICAgZGF5UmVjb3JkcyA9IGV2ZW50U3RvcmUuZ2V0RGF5UmVjb3JkcyhkYXRlKTtcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgID0gZGF5UmVjb3Jkcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkICAgICAgICAgPSBkYXlSZWNvcmRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhclJlY29yZCA9IGNhbGVuZGFyU3RvcmUuZ2V0KHJlY29yZC5jYWxlbmRhcklkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJSZWNvcmQ/LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSAgID0gcmVjb3JkLmVuZERhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgPSByZWNvcmQuc3RhcnREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kVGltZSA8PSBzdGFydERhdGUuZ2V0SG91cnMoKSB8fCBzdGFydFRpbWUgPj0gZW5kRGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRUaW1lIDwgZW5kRGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSA9IERhdGVVdGlsLmNsb25lKGVuZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoZW5kVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lID4gc3RhcnREYXRlLmdldEhvdXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiAgICAgICA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDbHMgICAgICAgPSBbJ25lby1ldmVudCcsICduZW8tZHJhZ2dhYmxlJywgYG5lby0ke2NhbGVuZGFyUmVjb3JkLmNvbG9yfWBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnRlcnZhbHMgPSBkdXJhdGlvbiAqIDYwIC8gdGltZUF4aXMuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPdmVyZmxvdyAgICA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgPSBNYXRoLnJvdW5kKGR1cmF0aW9uIC8gdG90YWxUaW1lICogMTAwICogMTAwMCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkS2V5ICAgICAgPSByZWNvcmRbZXZlbnRTdG9yZS5rZXlQcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEhvdXJzICAgICA9IChzdGFydERhdGUuZ2V0SG91cnMoKSAqIDYwICsgc3RhcnREYXRlLmdldE1pbnV0ZXMoKSkgLyA2MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgICAgICAgICAgID0gTWF0aC5yb3VuZCgoc3RhcnRIb3VycyAtIHN0YXJ0VGltZSkgLyB0b3RhbFRpbWUgKiAxMDAgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEludGVydmFscyA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3cgPSB0aW1lQXhpcy5yb3dIZWlnaHQgKiBldmVudEludGVydmFscyA8IChzaG93RXZlbnRFbmRUaW1lID8gNTAgOiAzNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmZsb3cgJiYgIShzaG93RXZlbnRFbmRUaW1lICYmICh0aW1lQXhpcy5yb3dIZWlnaHQgLyBldmVudEludGVydmFscyA+PSAzNCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xzLnB1c2goJ25lby1vdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSA9ICEoaGFzT3ZlcmZsb3cgJiYgZXZlbnRJbnRlcnZhbHMgPT09IDEgfHwgIXNob3dFdmVudEVuZFRpbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRFbmRUaW1lICYmIGV2ZW50Q2xzLnB1c2goJ25lby1zaG93LWVuZC10aW1lJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgIDogZXZlbnRDbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyAgICA6IHJlY29yZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuZ2V0RXZlbnRJZChyZWNvcmRLZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNuOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1ldmVudC10aW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IG1lLmludGxGb3JtYXRfdGltZS5mb3JtYXQocmVjb3JkLnN0YXJ0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICA6IGAke21lLmlkfV9fdGltZV9fJHtyZWNvcmRLZXl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZXZlbnQtdGl0bGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogcmVjb3JkLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgOiBgJHttZS5pZH1fX3RpdGxlX18ke3JlY29yZEtleX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWV2ZW50LXRpbWUnLCAnbmVvLWV2ZW50LWVuZC10aW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgICAgIDogbWUuaW50bEZvcm1hdF90aW1lLmZvcm1hdChyZWNvcmQuZW5kRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogYCR7bWUuaWR9X19lbmRkYXRlX18ke3JlY29yZEtleX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206ICFzaG93RXZlbnRFbmRUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGBjYWxjKCR7aGVpZ2h0fSUgLSAycHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgY2FsYygke3RvcH0lICsgMXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogJ2NhbGMoMTAwJSAtIDFweCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWVbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSB2ZG9tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3JlYXRlPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICB1cGRhdGVIZWFkZXIoY3JlYXRlPWZhbHNlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRlICAgICAgICAgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgY29udGVudCAgICAgID0gbWUuZ2V0Q29sdW1uQ29udGFpbmVyKCksXG4gICAgICAgICAgICBoZWFkZXIgICAgICAgPSBtZS5nZXRIZWFkZXJDb250YWluZXIoKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBzaG93V2Vla2VuZHMgPSBtZS5zaG93V2Vla2VuZHMsXG4gICAgICAgICAgICBjb2x1bW5DbHMsIGN1cnJlbnREYXRlLCBjdXJyZW50RGF5LCBkYXRlQ2xzLCBoZWFkZXJJZCwgcmVtb3ZlRG9tO1xuXG4gICAgICAgIG1lLnNldEZpcnN0Q29sdW1uRGF0ZShkYXRlKTtcblxuICAgICAgICBtZS5maXJzdENvbHVtbkRhdGUgPSBEYXRlVXRpbC5jbG9uZShkYXRlKTtcblxuICAgICAgICBmb3IgKDsgaSA8IG1lLnRvdGFsQ29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5DbHMgICA9IFsnbmVvLWMtdy1jb2x1bW4nLCAnbmVvLWRyYWdnYWJsZSddO1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIGN1cnJlbnREYXkgID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgIGRhdGVDbHMgICAgID0gWyduZW8tZGF0ZSddO1xuICAgICAgICAgICAgcmVtb3ZlRG9tICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgICAgIGNvbHVtbkNscy5wdXNoKCduZW8td2Vla2VuZCcpO1xuICAgICAgICAgICAgICAgICFzaG93V2Vla2VuZHMgJiYgKHJlbW92ZURvbSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudERhdGUgPT09IHRvZGF5LmRheSAmJiBkYXRlLmdldE1vbnRoKCkgPT09IHRvZGF5Lm1vbnRoICYmIGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdG9kYXkueWVhcikge1xuICAgICAgICAgICAgICAgIGRhdGVDbHMucHVzaCgnbmVvLXRvZGF5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcklkID0gbWUuZ2V0Q29sdW1uSGVhZGVySWQoZGF0ZSk7XG5cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LmNuLnB1c2goe2NsczogY29sdW1uQ2xzLCBmbGFnOiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKSwgaWQ6IG1lLmdldENvbHVtbklkKGRhdGUpLCByZW1vdmVEb219KTtcblxuICAgICAgICAgICAgICAgIGhlYWRlci5jbi5wdXNoKFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWhlYWRlci1yb3ctaXRlbSddLCBpZDogaGVhZGVySWQsIHJlbW92ZURvbSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tZGF5J10sIGh0bWw6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKSwgaWQ6IGAke2hlYWRlcklkfV9kYXlgfSxcbiAgICAgICAgICAgICAgICAgICAge2NscyA6IGRhdGVDbHMsICAgIGh0bWw6IGN1cnJlbnREYXRlLCAgICAgICAgICAgICAgICAgICAgaWQ6IGAke2hlYWRlcklkfV9kYXRlYH1cbiAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGVudC5jbltpXSwge1xuICAgICAgICAgICAgICAgICAgICBjbHMgOiBjb2x1bW5DbHMsXG4gICAgICAgICAgICAgICAgICAgIGZsYWc6IERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpZCAgOiBtZS5nZXRDb2x1bW5JZChkYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlci5jbltpXSwge2lkOiBoZWFkZXJJZCwgcmVtb3ZlRG9tfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIuY25baV0uY25bMF0sIHtodG1sOiBtZS5pbnRsRm9ybWF0X2RheS5mb3JtYXQoZGF0ZSksIGlkOiBgJHtoZWFkZXJJZH1fZGF5YH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVyLmNuW2ldLmNuWzFdLCB7Y2xzOiBkYXRlQ2xzLCBodG1sOiBjdXJyZW50RGF0ZSwgaWQ6IGAke2hlYWRlcklkfV9kYXRlYH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lW3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gdmRvbTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbXBvbmVudCk7XG5cbmV4cG9ydCB7Q29tcG9uZW50IGFzIGRlZmF1bHR9O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy53ZWVrLlRpbWVBeGlzQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVGltZUF4aXNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBnZXRTdGF0aWNDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaW50ZXJ2YWxcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyW119IGludGVydmFscz1bMTUsIDMwLCA2MF1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnZhbHM6IFsxNSwgMzAsIDYwXVxuICAgIH19XG5cbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5UaW1lQXhpc0NvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5UaW1lQXhpc0NvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGJpbmRcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICAgIGVuZFRpbWUgIDogZGF0YSA9PiBkYXRhLmVuZFRpbWUsXG4gICAgICAgICAgICBzdGFydFRpbWU6IGRhdGEgPT4gZGF0YS5zdGFydFRpbWVcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8tY2FsZW5kYXItdGltZWF4aXMnXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ25lby1jYWxlbmRhci10aW1lYXhpcyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmdWxsIGhvdXJzIGFyZSB2YWxpZCBmb3Igbm93XG4gICAgICAgICAqIGZvcm1hdDogJ2hoOm1tJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGVuZFRpbWVfPScyNDowMCdcbiAgICAgICAgICovXG4gICAgICAgIGVuZFRpbWVfOiAnMjQ6MDAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgaW50ZXJ2YWwgaW4gbWludXRlcyB0byBkaXNwbGF5IGFzIHJvd3MuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogMTUsIDMwLCA2MFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGludGVydmFsXz0zMFxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJ2YWxfOiAzMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm93SGVpZ2h0Xz0yMFxuICAgICAgICAgKi9cbiAgICAgICAgcm93SGVpZ2h0XzogMjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGZ1bGwgaG91cnMgYXJlIHZhbGlkIGZvciBub3dcbiAgICAgICAgICogZm9ybWF0OiAnaGg6bW0nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc3RhcnRUaW1lXz0nMDA6MDAnXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydFRpbWVfOiAnMDA6MDAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tXG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9fVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIG1lLmFmdGVyU2V0Um93SGVpZ2h0KG1lLnJvd0hlaWdodCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlbmRUaW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEVuZFRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyB0b2RvOiBoYW5kbGUgMjQ6MDAgYXMgMjM6NTlcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtZS5fZW5kVGltZSA9ICcyNDowMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmFmdGVyU2V0Um93SGVpZ2h0KG1lLnJvd0hlaWdodCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEludGVydmFsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZnRlclNldFJvd0hlaWdodCh0aGlzLnJvd0hlaWdodCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJvd0hlaWdodCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3dIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmRvbS5jbikge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBlbmRUaW1lICAgICA9IG1lLmdldFRpbWUobWUuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lICAgPSBtZS5nZXRUaW1lKG1lLnN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgdmRvbSAgICAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgICAgIHJvd0hlaWdodCAgID0gbWUucm93SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJvd3NQZXJJdGVtID0gbWUuZ2V0Um93c1Blckl0ZW0oKSxcbiAgICAgICAgICAgICAgICBpdGVtSGVpZ2h0ICA9IHJvd3NQZXJJdGVtICogcm93SGVpZ2h0ICsgcm93c1Blckl0ZW0sIC8vIHJvd3NQZXJJdGVtICogMXB4IGJvcmRlcnNcbiAgICAgICAgICAgICAgICB0b3RhbEhlaWdodCA9IHJvd0hlaWdodCArICgoZW5kVGltZSAtIHN0YXJ0VGltZSkgKiBpdGVtSGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBpLCBpdGVtU3R5bGU7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZSAgICA6IGBsaW5lYXItZ3JhZGllbnQodmFyKC0tYy13LWJhY2tncm91bmQtY29sb3IpICR7aXRlbUhlaWdodCAtIDF9cHgsIHZhcigtLWMtdy1ib3JkZXItY29sb3IpIDFweClgLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRQb3NpdGlvblk6IGAkey1pdGVtSGVpZ2h0ICsgMX1weGAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFNpemUgICAgIDogYDAuNGVtICR7aXRlbUhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgICAgIDogYCR7dG90YWxIZWlnaHQgLSByb3dIZWlnaHQgKyAxfXB4YCxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgICAgICAgICAgOiBgJHt0b3RhbEhlaWdodCAtIHJvd0hlaWdodCArIDF9cHhgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yIChpPTA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2l0ZW1IZWlnaHR9cHhgXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09PSBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlLm1hcmdpblRvcCA9IGAkey0yIC0gcm93SGVpZ2h0ICogKHJvd3NQZXJJdGVtID09PSAxID8gMC41IDogcm93c1Blckl0ZW0gPT09IDIgPyAxIDogMil9cHhgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtU3R5bGUubWFyZ2luVG9wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZkb20uY25baV0uc3R5bGUgPSBpdGVtU3R5bGU7XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuW2ldLnJlbW92ZURvbSA9IChpIDwgc3RhcnRUaW1lIHx8IGkgLSAxID49IGVuZFRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzaWxlbnQgdXBkYXRlOiB0aGUgdmlldyBjb250YWluaW5nIHRoaXMgY29tcG9uZW50IHdpbGwgdHJpZ2dlciB0aGUgdmRvbSB1cGRhdGVcbiAgICAgICAgICAgIG1lLl92ZG9tID0gdmRvbTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJvd3NQZXJJdGVtLFxuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RhcnRUaW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0YXJ0VGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJTZXRSb3dIZWlnaHQodGhpcy5yb3dIZWlnaHQsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaW50ZXJ2YWwgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRJbnRlcnZhbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2ludGVydmFsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IHZkb20gPSB0aGlzLnZkb20sXG4gICAgICAgICAgICBodG1sLCBpO1xuXG4gICAgICAgIHZkb20uY24gPSBbXTtcblxuICAgICAgICBmb3IgKGk9MDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgIGh0bWwgPSBpID09PSAyNCA/ICcwMDowMCcgOiAoaSA8IDEwID8gJzAnIDogJycpICsgaSArICc6MDAnO1xuXG4gICAgICAgICAgICB2ZG9tLmNuLnB1c2goe1xuICAgICAgICAgICAgICAgIGNscyAgOiBbJ25lby1jLXctdGltZWF4aXMtaXRlbSddLFxuICAgICAgICAgICAgICAgIGNuICAgOiBbe2h0bWw6IGh0bWx9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhbW91bnQgb2Ygcm93cyByZWxhdGVkIHRvIHRoZSBpbnRlcnZhbCBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd3NQZXJJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA9PT0gNjAgPyAxIDogdGhpcy5pbnRlcnZhbCA9PT0gMzAgPyAyIDogNDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB0aW1lIGZvciB0aGUgZW5kLSBvciBzdGFydFRpbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFRpbWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KCc6JykubWFwKE51bWJlcilbMF07XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhUaW1lQXhpc0NvbXBvbmVudCk7XG5cbmV4cG9ydCB7VGltZUF4aXNDb21wb25lbnQgYXMgZGVmYXVsdH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=