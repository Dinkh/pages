"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_shareddialog_app_mjs-src_container_Panel_mjs"],{

/***/ "./apps/shareddialog/app.mjs":
/*!***********************************!*\
  !*** ./apps/shareddialog/app.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onStart": () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/MainContainer.mjs */ "./apps/shareddialog/view/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'SharedDialog'
});


/***/ }),

/***/ "./apps/shareddialog/view/DemoDialog.mjs":
/*!***********************************************!*\
  !*** ./apps/shareddialog/view/DemoDialog.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/dialog/Base.mjs */ "./src/dialog/Base.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");



/**
 * @class SharedDialog.view.DemoDialog
 * @extends Neo.dialog.Base
 */
class DemoDialog extends _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.DemoDialog'
         * @protected
         */
        className: 'SharedDialog.view.DemoDialog',
        /**
         * @member {String} title='Drag me across Windows!'
         */
        title: 'Drag me across Windows!',
        /**
         * @member {Object} containerConfig={style:padding:'20px}}
         */
        containerConfig: {
            style: {
                padding: '20px'
            }
        },
        /**
         * @member {Object} itemDefaults={labelWidth:70}
         */
        itemDefaults: {
            labelWidth: 70
        },
        /**
         * @member {Object[]} items
         */
        items: [{
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 'none',
            labelText: 'Field 1'
        }, {
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 'none',
            labelText: 'Field 2'
        }],
        /**
         * @member {Object} wrapperStyle={height:'40%',width:'40%'}
         */
        wrapperStyle: {
            height: '40%',
            width : '40%'
        }
    }
}

Neo.applyClassConfig(DemoDialog);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DemoDialog);


/***/ }),

/***/ "./apps/shareddialog/view/MainContainer.mjs":
/*!**************************************************!*\
  !*** ./apps/shareddialog/view/MainContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_form_field_Radio_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/Radio.mjs */ "./src/form/field/Radio.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/shareddialog/view/MainContainerController.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");






/**
 * @class SharedDialog.view.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.MainContainer'
         * @protected
         */
        className: 'SharedDialog.view.MainContainer',
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex  : 'none',
            items :[{
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                flag   : 'open-dialog-button',
                handler: 'onCreateDialogButtonClick',
                iconCls: 'far fa-window-maximize',
                text   : 'Create Dialog',
            }, '->', {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'switchTheme',
                iconCls: 'fa fa-moon',
                text   : 'Theme Dark'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'openDockedWindow',
                iconCls: 'far fa-window-restore',
                style  : {marginLeft: '1em'},
                text   : 'Open docked Window'
            }]
        }, {
            ntype : 'container',
            flex  : 'none',
            layout: 'hbox',

            style: {
                height     : '72px',
                marginRight: '1em',
                marginTop  : '1em'
            },

            items : [{
                ntype: 'component',
                flex : 1
            }, {
                ntype: 'container',
                flex : 'none',

                itemDefaults: {
                    module        : _src_form_field_Radio_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    hideValueLabel: false,
                    labelText     : '',
                    labelWidth    : 50,
                    name          : 'dockedPosition',

                    listeners: {
                        change: 'onDockedPositionChange'
                    }
                },

                items: [{
                    labelText     : 'Dock',
                    valueLabelText: 'Top',
                    value         : 'top'
                }, {
                    checked       : true,
                    valueLabelText: 'Right',
                    value         : 'right'
                }, {
                    valueLabelText: 'Bottom',
                    value         : 'bottom'
                }, {
                    valueLabelText: 'Left',
                    value         : 'left'
                }]
            }]
        }, {
            ntype: 'component',
            flex : 1,
            html : '#1',

            style: {
                alignItems    : 'center',
                color         : '#bbb',
                display       : 'flex',
                fontSize      : '200px',
                justifyContent: 'center',
                marginBottom  : '88px',
                userSelect    : 'none'
            }
        }],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Object} style={padding:'20px'}
         */
        style: {padding: '20px'}
    }
}

Neo.applyClassConfig(MainContainer);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainer);


/***/ }),

/***/ "./apps/shareddialog/view/MainContainerController.mjs":
/*!************************************************************!*\
  !*** ./apps/shareddialog/view/MainContainerController.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _DemoDialog_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DemoDialog.mjs */ "./apps/shareddialog/view/DemoDialog.mjs");
/* harmony import */ var _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../src/util/Rectangle.mjs */ "./src/util/Rectangle.mjs");







/**
 * @class SharedDialog.view.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.MainContainerController'
         * @protected
         */
        className: 'SharedDialog.view.MainContainerController',
        /**
         * @member {String[]} connectedApps=[]
         */
        connectedApps: [],
        /**
         * @member {String} currentTheme='neo-theme-light'
         */
        currentTheme: 'neo-theme-light',
        /**
         * @member {String} dockedWindowAppName='SharedDialog2'
         */
        dockedWindowAppName: 'SharedDialog2',
        /**
         * @member {Neo.component.Base|null} dockedWindowProxy=null
         */
        dockedWindowProxy: null,
        /**
         * Valid values: bottom, left, right, top
         * @member {String} dockedWindowSide_='right'
         */
        dockedWindowSide_: 'right',
        /**
         * @member {Number} dockedWindowSize=500
         */
        dockedWindowSize: 500,
        /**
         * @member {Object} dialogRect=null
         */
        dialogRect: null,
        /**
         * @member {Object} dragStartWindowRect=null
         */
        dragStartWindowRect: null,
        /**
         * @member {Number|null} targetWindowSize=0
         */
        targetWindowSize: 0
    }

    /**
     * The App worker will receive connect & disconnect events inside the SharedWorkers context
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onAppConnect,
            disconnect: me.onAppDisconnect,
            scope     : me
        });
    }

    /**
     * Triggered after the dockedWindowSide config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDockedWindowSide(value, oldValue) {
        if (this.hasDockedWindow()) {
            Neo.main.addon.WindowPosition.setDock({
                name: this.dockedWindowAppName,
                dock: value
            });
        }
    }

    /**
     * @param {Object} data
     * @param {String} appName
     */
    createDialog(data, appName) {
        let me = this;

        me.enableOpenDialogButtons(false);

        me.dialog = Neo.create(_DemoDialog_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
            animateTargetId    : data.component.id,
            appName            : appName,
            boundaryContainerId: null,
            cls                : [me.currentTheme, 'neo-dialog', 'neo-panel', 'neo-container'],

            dragZoneConfig: {
                alwaysFireDragMove: true
            },

            listeners: {
                close          : me.onDialogClose,
                dragZoneCreated: me.onDragZoneCreated,
                scope          : me
            }
        });
    }

    /**
     *
     */
    destroyDockedWindowProxy() {
        let me = this;

        if (me.dockedWindowProxy) {
            me.dockedWindowProxy.destroy(true);
            me.dockedWindowProxy = null;
        }
    }

    /**
     * @param {Object} proxyRect
     */
    dropDialogBetweenWindows(proxyRect) {
        let me           = this,
            dialog       = me.dialog,
            intersection = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersectionDetails(me.dragStartWindowRect, proxyRect),
            side         = me.dockedWindowSide,
            size         = proxyRect.height * proxyRect.width,
            wrapperStyle;

        if (intersection.area > size / 2) { // drop the dialog fully into the dragStart window
            me.destroyDockedWindowProxy();

            wrapperStyle = dialog.wrapperStyle;

            if (dialog.appName === me.dockedWindowAppName) {
                side = me.getOppositeSide(side);
            }

            switch (side) {
                case 'bottom':
                    wrapperStyle.top = `${me.dragStartWindowRect.height - proxyRect.height}px`;
                    break;
                case 'left':
                    wrapperStyle.left = '0px';
                    break;
                case 'right':
                    wrapperStyle.left = `${me.dragStartWindowRect.width - proxyRect.width}px`;
                    break;
                case 'top':
                    wrapperStyle.top = '0px';
                    break;
            }

            dialog.wrapperStyle = wrapperStyle;
        } else { // drop the dialog fully into the dragEnd window
            me.mountDialogInOtherWindow({
                fullyIncludeIntoWindow: true,
                proxyRect             : proxyRect
            });
        }
    }

    /**
     * @param {Boolean} enable
     */
    enableOpenDialogButtons(enable) {
        this.getOpenDialogButtons().forEach(button => {
            button.disabled = !enable;
        });
    }

    /**
     * @return {Neo.button.Base}
     */
    getOpenDockedWindowButton() {
        return this.component.down({iconCls: 'far fa-window-restore'});
    }

    /**
     *
     */
    getOpenDialogButtons() {
        return _src_manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find({
            flag: 'open-dialog-button'
        });
    }

    /**
     * @param {String} side
     * @return {String}
     */
    getOppositeSide(side) {
        return {
            bottom: 'top',
            left  : 'right',
            right : 'left',
            top   : 'bottom'
        }[side];
    }

    /**
     * @param {Object} proxyRect
     * @param {String} side
     * @param {Boolean} [fullyIncludeIntoWindow=false]
     * @return {{left: String, top: String}}
     */
    getProxyPosition(proxyRect, side, fullyIncludeIntoWindow=false) {
        let me                  = this,
            dragStartWindowRect = me.dragStartWindowRect,
            targetWindowSize    = me.targetWindowSize,
            left, top;

        switch(side) {
            case 'bottom':
                left = `${proxyRect.left}px`;
                top  = `${fullyIncludeIntoWindow ? 0 : proxyRect.top - dragStartWindowRect.height}px`;
                break;
            case 'left':
                left = `${fullyIncludeIntoWindow ? targetWindowSize - proxyRect.width : targetWindowSize + proxyRect.left}px`;
                top  = `${proxyRect.top}px`;
                break;
            case 'right':
                left = `${fullyIncludeIntoWindow ? 0 : proxyRect.left - dragStartWindowRect.width}px`;
                top  = `${proxyRect.top}px`;
                break;
            case 'top':
                left = `${proxyRect.left}px`;
                top  = `${fullyIncludeIntoWindow ? targetWindowSize - proxyRect.height : targetWindowSize + proxyRect.top}px`;
                break;
        }

        return {
            left: left,
            top : top
        };
    }

    /**
     * @return {Boolean}
     */
    hasDockedWindow() {
        return this.connectedApps.includes(this.dockedWindowAppName);
    }

    /**
     * @param {Object} data
     * @param {Object} data.proxyRect
     * @param {Boolean} [data.fullyIncludeIntoWindow]
     */
    mountDialogInOtherWindow(data) {
        let me                   = this,
            appName              = me.component.appName,
            dialog               = me.dialog,
            dragEndWindowAppName = me.dockedWindowAppName,
            side                 = me.dockedWindowSide,
            proxyPosition, wrapperStyle;

        if (dialog.appName === dragEndWindowAppName) {
            dragEndWindowAppName = me.component.appName;
            side                 = me.getOppositeSide(me.dockedWindowSide);
        }

        proxyPosition = me.getProxyPosition(data.proxyRect, side, data.fullyIncludeIntoWindow);

        dialog.unmount();

        // we need a delay to ensure dialog.Base: onDragEnd() is done.
        // we could use the dragEnd event of the dragZone instead.
        setTimeout(() => {
            dialog.appName = dialog.appName === dragEndWindowAppName ? appName : dragEndWindowAppName;

            me.getOpenDialogButtons().forEach(button => {
                if (button.appName === dialog.appName) {
                    dialog.animateTargetId = button.id;
                }
            });

            wrapperStyle = dialog.wrapperStyle;

            wrapperStyle.left = proxyPosition.left;
            wrapperStyle.top  = proxyPosition.top;

            dialog.wrapperStyle = wrapperStyle;

            me.destroyDockedWindowProxy();

            dialog.mount();
        }, 70);
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     */
    onAppConnect(data) {
        let me   = this,
            name = data.appName;

        _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(me.connectedApps, name);

        if (name !== 'SharedDialog' && me.currentTheme !== 'neo-theme-light') {
            me.switchThemeForApp(name, me.currentTheme);
        }

        if (name === me.dockedWindowAppName) {
            me.getOpenDockedWindowButton().disabled = true;
        }

        me.enableOpenDialogButtons(!me.dialog);
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     */
    onAppDisconnect(data) {
        let me   = this,
            name = data.appName;

        if (name === 'SharedDialog') {
            // we want to close all popup windows, which equals to all connected apps minus the main app
            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(me.connectedApps, 'SharedDialog');

            Neo.Main.windowClose({
                names: me.connectedApps,
            });
        } else {
            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(me.connectedApps, name);

            Neo.main.addon.WindowPosition.unregisterWindow({
                name: name
            });
        }

        if (name === me.dockedWindowAppName) {
            me.getOpenDockedWindowButton().disabled = false;
        }
    }

    /**
     * @param {Object} data
     */
    onCreateDialogButtonClick(data) {
        this.createDialog(data, this.component.appName);
    }

    /**
     *
     */
    onDialogClose() {
        this.enableOpenDialogButtons(true);
    }

    /**
     * @param {Object} data
     */
    onDockedPositionChange(data) {
        if (data.value === true) {
            this.dockedWindowSide = data.component.value;
        }
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.hasDockedWindow()) {
            let me                  = this,
                dialog              = me.dialog,
                dragStartWindowRect = me.dragStartWindowRect,
                proxyRect           = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].moveTo(me.dialogRect, data.clientX - data.offsetX, data.clientY - data.offsetY),
                side                = me.dockedWindowSide;

            if (dialog.appName === me.dockedWindowAppName) {
                side = me.getOppositeSide(me.dockedWindowSide);
            }

            if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].leavesSide(dragStartWindowRect, proxyRect, side)) {
                if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].excludes(dragStartWindowRect, proxyRect)) {
                    me.mountDialogInOtherWindow({
                        proxyRect: proxyRect
                    });
                } else {
                    me.dropDialogBetweenWindows(proxyRect);
                }
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragMove(data) {
        if (this.hasDockedWindow()) {
            let me                  = this,
                dialogRect          = me.dialogRect,
                dockedWindowAppName = me.dockedWindowAppName,
                dragStartWindowRect = me.dragStartWindowRect,
                proxyRect           = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].moveTo(dialogRect, data.clientX - data.offsetX, data.clientY - data.offsetY),
                side                = me.dockedWindowSide,
                proxyPosition, vdom;

            // in case we trigger the drag:start inside the docked window,
            // we can keep the same logic with just flipping the side.
            if (me.dialog.appName === dockedWindowAppName) {
                dockedWindowAppName = me.component.appName;
                side                = me.getOppositeSide(me.dockedWindowSide);
            }

            if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].leavesSide(dragStartWindowRect, proxyRect, side)) {
                proxyPosition = me.getProxyPosition(proxyRect, side);

                if (!me.dockedWindowProxy) {
                    vdom = Neo.clone(me.dialog.dragZone.dragProxy.vdom, true);

                    delete vdom.id;

                    Object.assign(vdom.style, {
                        ...proxyPosition,
                        transform         : 'none',
                        transitionProperty: 'none'
                    });

                    me.dockedWindowProxy = Neo.create({
                        module    : _src_component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                        appName   : dockedWindowAppName,
                        autoMount : true,
                        autoRender: true,
                        cls       : ['neo-dialog-wrapper'],
                        parentId  : 'document.body',
                        vdom      : vdom
                    });

                    // The other window has most likely not loaded The dialog JS module yet,
                    // but the drag proxy is using some CSS rules of it.
                    Neo.currentWorker.insertThemeFiles(dockedWindowAppName, Neo.dialog.Base.prototype);
                } else {
                    me.updateDockedWindowProxyStyle({
                        ...proxyPosition,
                        visibility: null
                    });
                }
            } else {
                me.updateDockedWindowProxyStyle({visibility: 'hidden'});
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragStart(data) {
        if (this.hasDockedWindow()) {
            let me               = this,
                appName          = me.component.appName,
                dockedHorizontal = me.dockedWindowSide === 'left' || me.dockedWindowSide === 'right';

            me.dialogRect = data.dragElementRect;

            for (let item of data.eventData.path) {
                if (item.tagName === 'body') {
                    me.dragStartWindowRect = item.rect;
                    break;
                }
            }

            if (me.hasDockedWindow()) {
                Neo.Main.getWindowData({
                    appName: me.dialog.appName === appName ? me.dockedWindowAppName : appName
                }).then(data => {
                    me.targetWindowSize = dockedHorizontal ? data.innerWidth : data.innerHeight;
                });
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragZoneCreated(data) {
        let me = this;

        data.dragZone.on({
            dragEnd  : me.onDragEnd,
            dragMove : me.onDragMove,
            dragStart: me.onDragStart,
            scope    : me
        });
    }

    /**
     * Creates a new popup window, which is initially docked to this.dockedWindowSide of the main window
     * @param {Object} handlerData
     */
    openDockedWindow(handlerData) {
        Neo.Main.getWindowData().then(data => {
            let me     = this,
                dock   = me.dockedWindowSide,
                size   = me.dockedWindowSize,
                height, left, top, width;

            switch (dock) {
                case 'bottom':
                    height = size;
                    left   = data.screenLeft;
                    top    = data.outerHeight + data.screenTop - 52;
                    width  = data.outerWidth;
                    break;
                case 'left':
                    height = data.outerHeight - 78;
                    left   = data.screenLeft  - size;
                    top    = data.screenTop   + 28;
                    width  = size;
                    break;
                case 'right':
                    height = data.outerHeight - 78;
                    left   = data.outerWidth  + data.screenLeft;
                    top    = data.screenTop   + 28;
                    width  = size;
                    break;
                case 'top':
                    height = size;
                    left   = data.screenLeft;
                    top    = data.screenTop - size + 28;
                    width  = data.outerWidth;
                    break;
            }

            Neo.Main.windowOpen({
                url           : '../shareddialog2/index.html',
                windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
                windowName    : me.dockedWindowAppName
            });

            Neo.main.addon.WindowPosition.registerWindow({
                dock: dock,
                name: me.dockedWindowAppName,
                size: size
            });
        });
    }

    /**
     * Switches the theme for all connected apps
     * @param {Object} data
     */
    switchTheme(data) {
        let me         = this,
            button     = data.component,
            buttonText = 'Theme Light',
            dialog     = me.dialog,
            iconCls    = 'fa fa-sun',
            theme      = 'neo-theme-dark',
            cls;

        if (button.text === 'Theme Light') {
            buttonText = 'Theme Dark';
            iconCls    = 'fa fa-moon';
            theme      = 'neo-theme-light';
        }

        me.connectedApps.forEach(appName => {
            me.switchThemeForApp(appName, theme);
        });

        button.set({
            iconCls: iconCls,
            text   : buttonText
        });

        if (dialog) {
            cls = dialog.cls;

            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].removeAdd(cls, me.currentTheme, theme);

            dialog.cls = cls;
        }

        me.currentTheme = theme;
    }

    /**
     * @param {String} appName
     * @param {String} theme
     */
    switchThemeForApp(appName, theme) {
        Neo.main.DomAccess.setBodyCls({
            appName: appName,
            add    : [theme],
            remove : [this.currentTheme]
        });
    }

    /**
     * @param {Object} style
     */
    updateDockedWindowProxyStyle(style) {
        let dockedWindowProxy = this.dockedWindowProxy;

        if (dockedWindowProxy) {
            dockedWindowProxy.style = Object.assign(dockedWindowProxy.style || {}, style);
        }
    }
}

Neo.applyClassConfig(MainContainerController);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainContainerController);


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} text_=''
         */
        text_: '',
        /**
         * @member {Object} _vdom={tag: 'label'}
         */
        _vdom:
        {tag: 'label', draggable: false}
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.vdom.html = value;
        this.update();
    }
}

Neo.applyClassConfig(Label);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Label);


/***/ }),

/***/ "./src/container/Panel.mjs":
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header};
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                items                = me.items,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header));
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header));
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header));
                });

                verticalItems.push({
                    ntype : 'container',
                    items : horizontalItems,
                    layout: {
                        ntype: (hf ? 'hbox' : 'vbox'),
                        align: 'stretch'
                    }
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config});
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header));
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems();
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0;
    }
}

Neo.applyClassConfig(Panel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Panel);


/***/ }),

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport']
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName: this.appName,
            cls    : ['neo-body-viewport']
        })
    }
}

Neo.applyClassConfig(Viewport);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");





/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me        = this,
            component = me.component,
            listenerId;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed();
        } else {
            listenerId = component.on('constructed', () => {
                component.un('constructed', listenerId);
                me.onComponentConstructed();
            });
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent();
    }

    /**
     * @param {String} handlerName
     * @returns {Neo.controller.Component|null}
     */
    getHandlerScope(handlerName) {
        let me     = this,
            parent = me.parent;

        return Neo.isFunction(me[handlerName]) ?
            me : parent ?
            parent.getHandlerScope(handlerName) : null;
    }

    /**
     * sameLevelOnly=false will return the closest VM inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getModel(sameLevelOnly=false) {
        let component = this.component;
        return sameLevelOnly ? component.model : component.getModel();
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me = this,
            parentComponent, parentId;

        if (me.parent) {
            return me.parent;
        }

        parentId        = me.component.parentId;
        parentComponent = parentId && Neo.getComponent(parentId);

        return parentComponent?.getController() || null;
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component;
            }
        }

        return component || null;
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me        = this,
            listeners = component.listeners,
            reference = component.reference,
            eventHandler, handlerScope;

        if (listeners) {
            Object.entries(listeners).forEach(([key, value]) => {
                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                        handlerScope = me.getHandlerScope(eventHandler);

                        if (!handlerScope) {
                            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown event handler for', eventHandler, component);
                        } else {
                            listeners[key] = {};
                            listeners[key].fn = handlerScope[eventHandler].bind(handlerScope);
                        }
                    } else {
                        value.forEach(listener => {
                            if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                                eventHandler = listener.fn;
                                handlerScope = me.getHandlerScope(eventHandler);

                                if (!handlerScope) {
                                    _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown event handler for', eventHandler, component);
                                } else {
                                    listener.fn = handlerScope[eventHandler].bind(handlerScope);
                                }
                            }
                        });
                    }
                }
            });
        }

        if (reference) {
            me.references[reference] = component;
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me           = this,
            domListeners = component.domListeners,
            eventHandler, scope;

        if (domListeners) {
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    eventHandler = null;

                    if (key !== 'scope' && key !== 'delegate') {
                        if (Neo.isString(value)) {
                            eventHandler = value;
                        } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                            eventHandler = value.fn;
                        }

                        if (eventHandler) {
                            scope = me.getHandlerScope(eventHandler);

                            if (!scope) {
                                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Unknown domEvent handler for', eventHandler, component);
                            } else {
                                domListener[key] = scope[eventHandler].bind(scope);
                            }
                        }
                    }
                });
            });
        }
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me = this,
            references = me.references,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break;
            }
        }

        me.getParent()?.removeReference(component);
    }
}

Neo.applyClassConfig(Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);


/***/ }),

/***/ "./src/form/field/CheckBox.mjs":
/*!*************************************!*\
  !*** ./src/form/field/CheckBox.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.form.field.CheckBox
 * @extends Neo.form.field.Base
 */
class CheckBox extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for labelPosition
     * @member {String[]} labelPositions=['left','top']
     * @protected
     * @static
     */
    static labelPositions = ['left', 'top']

    static config = {
        /**
         * @member {String} className='Neo.form.field.CheckBox'
         * @protected
         */
        className: 'Neo.form.field.CheckBox',
        /**
         * @member {String} ntype='checkboxfield'
         * @protected
         */
        ntype: 'checkboxfield',
        /**
         * @member {String[]} baseCls=['neo-checkboxfield']
         */
        baseCls: ['neo-checkboxfield'],
        /**
         * @member {Boolean} checked_=false
         */
        checked_: false,
        /**
         * @member {Boolean} hideLabel_=false
         */
        hideLabel_: false,
        /**
         * @member {String[]} iconCls=['far','fa-square']
         */
        iconCls: ['far', 'fa-square'],
        /**
         * @member {String[]} iconClsChecked=['fas','fa-check']
         */
        iconClsChecked: ['fas', 'fa-check'],
        /**
         * @member {String} inputType_='checkbox'
         */
        inputType_: 'checkbox',
        /**
         * @member {String[]} labelBaseCls=['neo-checkbox-label']
         */
        labelBaseCls: ['neo-checkbox-label'],
        /**
         * @member {String[]} labelCls_=[]
         */
        labelCls_: [],
        /**
         * Valid values: 'left', 'top'
         * @member {String} labelPosition_='left'
         */
        labelPosition_: 'left',
        /**
         * @member {String} labelText_='LabelText'
         */
        labelText_: 'LabelText',
        /**
         * defaults to px
         * @member {Number|String} labelWidth_=150
         */
        labelWidth_: 150,
        /**
         * @member {String} The name (group) of the input dom node
         */
        name_: '',
        /**
         * @member {String|null} valueLabelText_=null
         */
        valueLabelText_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'label', cn: [
            {tag: 'span',  cls: []},
            {tag: 'input', cls: ['neo-checkbox-input']},
            {tag: 'i',     cls: ['neo-checkbox-icon']},
            {tag: 'span',  cls: ['neo-checkbox-value-label']}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners(
            {change: me.onInputValueChange, scope: me}
        );
    }

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetChecked(value, oldValue) {
        let me      = this,
            iconCls = me.vdom.cn[2].cls,
            newCls  = value ? me.iconClsChecked : me.iconCls,
            oldCls  = value ? me.iconCls : me.iconClsChecked;

        me.vdom.cn[1].checked = value;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(iconCls, oldCls);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(iconCls, newCls);

        me.update();

        if (oldValue !== undefined) {
            me.fire('change', {
                component: me,
                oldValue,
                value
            })
        }
    }

    /**
     * Triggered after the hideLabel config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetHideLabel(value, oldValue) {
        this.vdom.cn[0].removeDom = value;
        this.update();
    }

    /**
     * Triggered after the id config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me   = this,
            vdom = me.vdom;

        vdom.cn[0].id = me.getLabelId();
        vdom.cn[1].id = me.getInputElId();
        vdom.cn[2].id = me.getIconElId();
        vdom.cn[3].id = me.getValueLabelId();

        // silent vdom update, the super call will trigger the engine
        super.afterSetId(value, oldValue);
    }

    /**
     * Triggered after the inputType config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetInputType(value, oldValue) {
        this.vdom.cn[1].type = value;
        this.update();
    }

    /**
     * Triggered after the labelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetLabelCls(value, oldValue) {
        let me  = this,
            cls = me.vdom.cn[0].cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, value);

        me.update();
    }

    /**
     * Triggered after the labelPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelPosition(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-label-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(   cls, 'neo-label-' + value);
        me.cls = cls;
    }

    /**
     * Triggered after the labelText config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        this.vdom.cn[0].innerHTML = value;
        this.update();
    }

    /**
     * Triggered after the labelWidth config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetLabelWidth(value, oldValue) {
        let me = this;

        if (!me.hideLabel) {
            me.vdom.cn[0].width = value;
            me.update();
        }
    }

    /**
     * Triggered after the name config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetName(value, oldValue) {
        this.vdom.cn[1].name = value;
        this.update();
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        if (value) {
            this.vdom.cn[1].value = value;
            this.update();
        }

        super.afterSetValue(value, oldValue);
    }

    /**
     * Triggered after the valueLabel config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValueLabelText(value, oldValue) {
        let me         = this,
            valueLabel = me.vdom.cn[3],
            showLabel  = !!value; // hide the label, in case value === null || value === ''

        if (showLabel) {
            valueLabel.innerHTML = value;
        }

        valueLabel.removeDom = !showLabel;
        me.update();
    }

    /**
     * Triggered before the labelCls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(value || [], this.labelBaseCls);
    }

    /**
     * Triggered before the labelPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'labelPosition');
    }

    /**
     * @returns {String}
     */
    getIconElId() {
        return `${this.id}__icon`;
    }

    /**
     * @returns {String}
     */
    getInputElId() {
        return `${this.id}__input`;
    }

    /**
     * @returns {String}
     */
    getLabelId() {
        return `${this.id}__label`;
    }

    /**
     * @returns {String}
     */
    getValueLabelId() {
        return `${this.id}__value-label`;
    }

    /**
     * Gets triggered when a user checks a checkbox input.
     * @param {Object} data
     */
    onInputValueChange(data) {
        let me      = this,
            checked = data.target.checked;

        // keep the vdom & vnode in sync for future updates
        me.vnode.childNodes[me.hideLabel ? 0 : 1].attributes.checked = `${checked}`;

        me.checked = checked;
    }
}

Neo.applyClassConfig(CheckBox);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CheckBox);


/***/ }),

/***/ "./src/form/field/Radio.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Radio.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.form.field.Radio
 * @extends Neo.form.field.CheckBox
 */
class Radio extends _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Radio'
         * @protected
         */
        className: 'Neo.form.field.Radio',
        /**
         * @member {String} ntype='radiofield'
         * @protected
         */
        ntype: 'radiofield',
        /**
         * @member {String[]} baseCls=['neo-radiofield','neo-checkboxfield']
         */
        baseCls: ['neo-radiofield', 'neo-checkboxfield'],
        /**
         * @member {String[]} iconCls=['far','fa-circle']
         */
        iconCls: ['far', 'fa-circle'],
        /**
         * @member {String} inputType='radio'
         */
        inputType: 'radio'
    }

    /**
     * Triggered after the checked config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetChecked(value, oldValue) {
        super.afterSetChecked(value, oldValue);

        // update radios with the same name to be unchecked
        value && this.uncheckGroupItems()
    }

    /**
     * Radios do not fire a change event for "uncheck", so we need to iterate over other radios with the same name.
     */
    uncheckGroupItems() {
        let me = this,
            radios;

        // discuss: we could limit this to radios inside the same form, IF a top level form is used
        radios = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find({
            ntype: 'radiofield',
            name : me.name
        });

        radios.forEach(item => {
            if (item.id !== me.id && item._checked) {
                item.checked = false;
            }
        })
    }
}

Neo.applyClassConfig(Radio);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Radio);


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Base extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left']
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left']

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String} dock_='top'
         */
        dock_: 'top',
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} _layout={ntype: 'hbox', align: 'center', pack : 'start'}
         */
        _layout: {
            ntype: 'hbox',
            align: 'center',
            pack : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value;
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        let me            = this,
            cls           = me.cls,
            dockPositions = me.getStaticConfig('dockPositions');

        dockPositions.forEach(key => {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][key === value ? 'add' : 'remove'](cls, 'neo-dock-' + key);
        });

        me.cls    = cls;
        me.layout = me.getLayoutConfig();
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    ...me.sortZoneConfig
                });
            });
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions');
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            items.forEach((item, index) => {
                if (item === '->') {
                    items[index] = Neo.create({
                        module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                        flex  : 1
                    });
                }
            });
        }

        return super.createItems();
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let layoutConfig;

        switch(this.dock) {
            case 'bottom':
            case 'top':
                layoutConfig = {
                    ntype: 'hbox',
                    align: 'center',
                    pack : 'start'
                };
                break;
            case 'left':
                layoutConfig = {
                    ntype    : 'vbox',
                    align    : 'center',
                    direction: 'column-reverse',
                    pack     : 'start'
                };
                break;
            case 'right':
                layoutConfig = {
                    ntype    : 'vbox',
                    align    : 'center',
                    direction: 'column',
                    pack     : 'start'
                };
                break;
        }

        return layoutConfig;
    }
}

Neo.applyClassConfig(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/util/Rectangle.mjs":
/*!********************************!*\
  !*** ./src/util/Rectangle.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * The class contains utility methods for working with DOMRect Objects
 * @class Neo.util.Rectangle
 * @extends Neo.core.Base
 */
class Rectangle extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Rectangle'
         * @protected
         */
        className: 'Neo.util.Rectangle'
    }

    /**
     * Checks if rect1 does not have an intersection with rect2
     * !includes() is true for intersections as well
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static excludes(rect1, rect2) {
        return rect1.bottom < rect2.top     // rect2 is below rect1
            || rect1.left   > rect2.right   // rect2 is left of rect1
            || rect1.right  < rect2.left    // rect2 is right of rect1
            || rect1.top    > rect2.bottom; // rect2 is above rect1
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Number} The area (x * y)
     */
    static getIntersection(rect1, rect2) {
        return Rectangle.getIntersectionDetails(rect1, rect2).area;
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Object} x, y & area
     */
    static getIntersectionDetails(rect1, rect2) {
        let width  = Math.max(0, Math.min(rect1.right,  rect2.right)  - Math.max(rect1.left, rect2.left)),
            height = Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top,  rect2.top));

        return {
            area: height * width,
            height,
            width
        };
    }

    /**
     * Checks if rect2 is fully contained inside rect1
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static includes(rect1, rect2) {
        return rect1.bottom >= rect2.bottom
            && rect1.left   <= rect2.left
            && rect1.right  >= rect2.right
            && rect1.top    <= rect2.top;
    }

    /**
     * Checks if rect2 is not contained inside rect1.
     * This could be an intersection or being fully excluded.
     * @param {Object} rect1
     * @param {Object} rect2
     * @param {String} side bottom, left, right or top
     * @returns {Boolean}
     */
    static leavesSide(rect1, rect2, side) {
        if (Rectangle.includes(rect1, rect2)) {
            return false;
        }

        if (side === 'bottom') {
            return rect1.bottom < rect2.bottom;
        }

        if (side === 'left') {
            return rect1.left > rect2.left;
        }

        if (side === 'right') {
            return rect1.right < rect2.right;
        }

        if (side === 'top') {
            return rect1.top > rect2.top;
        }
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveBy(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  += x;
            movedRect.right += x;
            movedRect.x     += x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom += y;
            movedRect.top    += y;
            movedRect.y      += y;
        }

        return movedRect;
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveTo(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  = x;
            movedRect.right = x + movedRect.width;
            movedRect.x     = x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom = y + movedRect.height;
            movedRect.top    = y;
            movedRect.y      = y;
        }

        return movedRect;
    }
}

Neo.applyClassConfig(Rectangle);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rectangle);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfc2hhcmVkZGlhbG9nX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7O0FBRTlDO0FBQ1AsY0FBYywrREFBYTtBQUMzQjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTG9EO0FBQ0k7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFFBQVEsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFTO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGdFQUFTO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsUUFBUSxjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFVBQVUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RHlDO0FBQ0s7QUFDSjtBQUNBO0FBQ007O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1FQUFRO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQSxvQkFBb0Isb0VBQXVCO0FBQzNDO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQiw2REFBTztBQUMzQjtBQUNBO0FBQ0EseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7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Q3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9zaGFyZWRkaWFsb2cvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9zaGFyZWRkaWFsb2cvdmlldy9EZW1vRGlhbG9nLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9zaGFyZWRkaWFsb2cvdmlldy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9zaGFyZWRkaWFsb2cvdmlldy9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udGFpbmVyL1BhbmVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvUmFkaW8ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvUmVjdGFuZ2xlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL3ZpZXcvTWFpbkNvbnRhaW5lci5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBNYWluQ29udGFpbmVyLFxuICAgIG5hbWUgICAgOiAnU2hhcmVkRGlhbG9nJ1xufSk7XG4iLCJpbXBvcnQgRGlhbG9nICAgIGZyb20gJy4uLy4uLy4uL3NyYy9kaWFsb2cvQmFzZS5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFNoYXJlZERpYWxvZy52aWV3LkRlbW9EaWFsb2dcbiAqIEBleHRlbmRzIE5lby5kaWFsb2cuQmFzZVxuICovXG5jbGFzcyBEZW1vRGlhbG9nIGV4dGVuZHMgRGlhbG9nIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1NoYXJlZERpYWxvZy52aWV3LkRlbW9EaWFsb2cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1NoYXJlZERpYWxvZy52aWV3LkRlbW9EaWFsb2cnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aXRsZT0nRHJhZyBtZSBhY3Jvc3MgV2luZG93cyEnXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZTogJ0RyYWcgbWUgYWNyb3NzIFdpbmRvd3MhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY29udGFpbmVyQ29uZmlnPXtzdHlsZTpwYWRkaW5nOicyMHB4fX1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNvbmZpZzoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMjBweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtsYWJlbFdpZHRoOjcwfVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbURlZmF1bHRzOiB7XG4gICAgICAgICAgICBsYWJlbFdpZHRoOiA3MFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgZmxleCAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdGaWVsZCAxJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgIGZsZXggICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnRmllbGQgMidcbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHdyYXBwZXJTdHlsZT17aGVpZ2h0Oic0MCUnLHdpZHRoOic0MCUnfVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlclN0eWxlOiB7XG4gICAgICAgICAgICBoZWlnaHQ6ICc0MCUnLFxuICAgICAgICAgICAgd2lkdGggOiAnNDAlJ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhEZW1vRGlhbG9nKTtcblxuZXhwb3J0IGRlZmF1bHQgRGVtb0RpYWxvZztcbiIsImltcG9ydCBCdXR0b24gICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBSYWRpbyAgICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9SYWRpby5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJDb250cm9sbGVyIGZyb20gJy4vTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzJztcbmltcG9ydCBUb29sYmFyICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdG9vbGJhci9CYXNlLm1qcyc7XG5pbXBvcnQgVmlld3BvcnQgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcjogTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZScsXG4gICAgICAgICAgICBpdGVtcyA6W3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBCdXR0b24sXG4gICAgICAgICAgICAgICAgZmxhZyAgIDogJ29wZW4tZGlhbG9nLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogJ29uQ3JlYXRlRGlhbG9nQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYXIgZmEtd2luZG93LW1heGltaXplJyxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnQ3JlYXRlIERpYWxvZycsXG4gICAgICAgICAgICB9LCAnLT4nLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdzd2l0Y2hUaGVtZScsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLW1vb24nLFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdUaGVtZSBEYXJrJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiAnb3BlbkRvY2tlZFdpbmRvdycsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhciBmYS13aW5kb3ctcmVzdG9yZScsXG4gICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpbkxlZnQ6ICcxZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnT3BlbiBkb2NrZWQgV2luZG93J1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnR5cGUgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgIGZsZXggIDogJ25vbmUnLFxuICAgICAgICAgICAgbGF5b3V0OiAnaGJveCcsXG5cbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICA6ICc3MnB4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzFlbScsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wICA6ICcxZW0nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIGZsZXggOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgIGZsZXggOiAnbm9uZScsXG5cbiAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IFJhZGlvLFxuICAgICAgICAgICAgICAgICAgICBoaWRlVmFsdWVMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxXaWR0aCAgICA6IDUwLFxuICAgICAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgIDogJ2RvY2tlZFBvc2l0aW9uJyxcblxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogJ29uRG9ja2VkUG9zaXRpb25DaGFuZ2UnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgOiAnRG9jaycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTGFiZWxUZXh0OiAnVG9wJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICA6ICd0b3AnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMYWJlbFRleHQ6ICdSaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiAncmlnaHQnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogJ0JvdHRvbScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiAnYm90dG9tJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMYWJlbFRleHQ6ICdMZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICA6ICdsZWZ0J1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICBmbGV4IDogMSxcbiAgICAgICAgICAgIGh0bWwgOiAnIzEnLFxuXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGFsaWduSXRlbXMgICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBjb2xvciAgICAgICAgIDogJyNiYmInLFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgICAgICAgOiAnZmxleCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemUgICAgICA6ICcyMDBweCcsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSAgOiAnODhweCcsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdCAgICA6ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PXtudHlwZTondmJveCcsYWxpZ246J3N0cmV0Y2gnfVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXtwYWRkaW5nOicyMHB4J31cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiB7cGFkZGluZzogJzIwcHgnfVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTWFpbkNvbnRhaW5lcik7XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5Db250YWluZXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50ICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRDb250cm9sbGVyIGZyb20gJy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgICAgZnJvbSAnLi4vLi4vLi4vc3JjL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRGVtb0RpYWxvZyAgICAgICAgICBmcm9tICcuL0RlbW9EaWFsb2cubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdXRpbC9SZWN0YW5nbGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgU2hhcmVkRGlhbG9nLnZpZXcuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyQ29udHJvbGxlciBleHRlbmRzIENvbXBvbmVudENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nU2hhcmVkRGlhbG9nLnZpZXcuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1NoYXJlZERpYWxvZy52aWV3Lk1haW5Db250YWluZXJDb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjb25uZWN0ZWRBcHBzPVtdXG4gICAgICAgICAqL1xuICAgICAgICBjb25uZWN0ZWRBcHBzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY3VycmVudFRoZW1lPSduZW8tdGhlbWUtbGlnaHQnXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50VGhlbWU6ICduZW8tdGhlbWUtbGlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkb2NrZWRXaW5kb3dBcHBOYW1lPSdTaGFyZWREaWFsb2cyJ1xuICAgICAgICAgKi9cbiAgICAgICAgZG9ja2VkV2luZG93QXBwTmFtZTogJ1NoYXJlZERpYWxvZzInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGRvY2tlZFdpbmRvd1Byb3h5PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tlZFdpbmRvd1Byb3h5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiBib3R0b20sIGxlZnQsIHJpZ2h0LCB0b3BcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkb2NrZWRXaW5kb3dTaWRlXz0ncmlnaHQnXG4gICAgICAgICAqL1xuICAgICAgICBkb2NrZWRXaW5kb3dTaWRlXzogJ3JpZ2h0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZG9ja2VkV2luZG93U2l6ZT01MDBcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tlZFdpbmRvd1NpemU6IDUwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGlhbG9nUmVjdD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkaWFsb2dSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcmFnU3RhcnRXaW5kb3dSZWN0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdTdGFydFdpbmRvd1JlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gdGFyZ2V0V2luZG93U2l6ZT0wXG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXRXaW5kb3dTaXplOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIEFwcCB3b3JrZXIgd2lsbCByZWNlaXZlIGNvbm5lY3QgJiBkaXNjb25uZWN0IGV2ZW50cyBpbnNpZGUgdGhlIFNoYXJlZFdvcmtlcnMgY29udGV4dFxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uQXBwQ29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uQXBwRGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZG9ja2VkV2luZG93U2lkZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREb2NrZWRXaW5kb3dTaWRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNEb2NrZWRXaW5kb3coKSkge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb24uc2V0RG9jayh7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5kb2NrZWRXaW5kb3dBcHBOYW1lLFxuICAgICAgICAgICAgICAgIGRvY2s6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwcE5hbWVcbiAgICAgKi9cbiAgICBjcmVhdGVEaWFsb2coZGF0YSwgYXBwTmFtZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmVuYWJsZU9wZW5EaWFsb2dCdXR0b25zKGZhbHNlKTtcblxuICAgICAgICBtZS5kaWFsb2cgPSBOZW8uY3JlYXRlKERlbW9EaWFsb2csIHtcbiAgICAgICAgICAgIGFuaW1hdGVUYXJnZXRJZCAgICA6IGRhdGEuY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICAgIDogYXBwTmFtZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgICAgOiBbbWUuY3VycmVudFRoZW1lLCAnbmVvLWRpYWxvZycsICduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuXG4gICAgICAgICAgICBkcmFnWm9uZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGFsd2F5c0ZpcmVEcmFnTW92ZTogdHJ1ZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgY2xvc2UgICAgICAgICAgOiBtZS5vbkRpYWxvZ0Nsb3NlLFxuICAgICAgICAgICAgICAgIGRyYWdab25lQ3JlYXRlZDogbWUub25EcmFnWm9uZUNyZWF0ZWQsXG4gICAgICAgICAgICAgICAgc2NvcGUgICAgICAgICAgOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3lEb2NrZWRXaW5kb3dQcm94eSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuZG9ja2VkV2luZG93UHJveHkpIHtcbiAgICAgICAgICAgIG1lLmRvY2tlZFdpbmRvd1Byb3h5LmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgICBtZS5kb2NrZWRXaW5kb3dQcm94eSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJveHlSZWN0XG4gICAgICovXG4gICAgZHJvcERpYWxvZ0JldHdlZW5XaW5kb3dzKHByb3h5UmVjdCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRpYWxvZyAgICAgICA9IG1lLmRpYWxvZyxcbiAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IFJlY3RhbmdsZS5nZXRJbnRlcnNlY3Rpb25EZXRhaWxzKG1lLmRyYWdTdGFydFdpbmRvd1JlY3QsIHByb3h5UmVjdCksXG4gICAgICAgICAgICBzaWRlICAgICAgICAgPSBtZS5kb2NrZWRXaW5kb3dTaWRlLFxuICAgICAgICAgICAgc2l6ZSAgICAgICAgID0gcHJveHlSZWN0LmhlaWdodCAqIHByb3h5UmVjdC53aWR0aCxcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZTtcblxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmFyZWEgPiBzaXplIC8gMikgeyAvLyBkcm9wIHRoZSBkaWFsb2cgZnVsbHkgaW50byB0aGUgZHJhZ1N0YXJ0IHdpbmRvd1xuICAgICAgICAgICAgbWUuZGVzdHJveURvY2tlZFdpbmRvd1Byb3h5KCk7XG5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IGRpYWxvZy53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgIGlmIChkaWFsb2cuYXBwTmFtZSA9PT0gbWUuZG9ja2VkV2luZG93QXBwTmFtZSkge1xuICAgICAgICAgICAgICAgIHNpZGUgPSBtZS5nZXRPcHBvc2l0ZVNpZGUoc2lkZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS50b3AgPSBgJHttZS5kcmFnU3RhcnRXaW5kb3dSZWN0LmhlaWdodCAtIHByb3h5UmVjdC5oZWlnaHR9cHhgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IGAke21lLmRyYWdTdGFydFdpbmRvd1JlY3Qud2lkdGggLSBwcm94eVJlY3Qud2lkdGh9cHhgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaWFsb2cud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlO1xuICAgICAgICB9IGVsc2UgeyAvLyBkcm9wIHRoZSBkaWFsb2cgZnVsbHkgaW50byB0aGUgZHJhZ0VuZCB3aW5kb3dcbiAgICAgICAgICAgIG1lLm1vdW50RGlhbG9nSW5PdGhlcldpbmRvdyh7XG4gICAgICAgICAgICAgICAgZnVsbHlJbmNsdWRlSW50b1dpbmRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm94eVJlY3QgICAgICAgICAgICAgOiBwcm94eVJlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVcbiAgICAgKi9cbiAgICBlbmFibGVPcGVuRGlhbG9nQnV0dG9ucyhlbmFibGUpIHtcbiAgICAgICAgdGhpcy5nZXRPcGVuRGlhbG9nQnV0dG9ucygpLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9ICFlbmFibGU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge05lby5idXR0b24uQmFzZX1cbiAgICAgKi9cbiAgICBnZXRPcGVuRG9ja2VkV2luZG93QnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZG93bih7aWNvbkNsczogJ2ZhciBmYS13aW5kb3ctcmVzdG9yZSd9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldE9wZW5EaWFsb2dCdXR0b25zKCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5maW5kKHtcbiAgICAgICAgICAgIGZsYWc6ICdvcGVuLWRpYWxvZy1idXR0b24nXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldE9wcG9zaXRlU2lkZShzaWRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3R0b206ICd0b3AnLFxuICAgICAgICAgICAgbGVmdCAgOiAncmlnaHQnLFxuICAgICAgICAgICAgcmlnaHQgOiAnbGVmdCcsXG4gICAgICAgICAgICB0b3AgICA6ICdib3R0b20nXG4gICAgICAgIH1bc2lkZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3h5UmVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZnVsbHlJbmNsdWRlSW50b1dpbmRvdz1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHt7bGVmdDogU3RyaW5nLCB0b3A6IFN0cmluZ319XG4gICAgICovXG4gICAgZ2V0UHJveHlQb3NpdGlvbihwcm94eVJlY3QsIHNpZGUsIGZ1bGx5SW5jbHVkZUludG9XaW5kb3c9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZHJhZ1N0YXJ0V2luZG93UmVjdCA9IG1lLmRyYWdTdGFydFdpbmRvd1JlY3QsXG4gICAgICAgICAgICB0YXJnZXRXaW5kb3dTaXplICAgID0gbWUudGFyZ2V0V2luZG93U2l6ZSxcbiAgICAgICAgICAgIGxlZnQsIHRvcDtcblxuICAgICAgICBzd2l0Y2goc2lkZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYCR7cHJveHlSZWN0LmxlZnR9cHhgO1xuICAgICAgICAgICAgICAgIHRvcCAgPSBgJHtmdWxseUluY2x1ZGVJbnRvV2luZG93ID8gMCA6IHByb3h5UmVjdC50b3AgLSBkcmFnU3RhcnRXaW5kb3dSZWN0LmhlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYCR7ZnVsbHlJbmNsdWRlSW50b1dpbmRvdyA/IHRhcmdldFdpbmRvd1NpemUgLSBwcm94eVJlY3Qud2lkdGggOiB0YXJnZXRXaW5kb3dTaXplICsgcHJveHlSZWN0LmxlZnR9cHhgO1xuICAgICAgICAgICAgICAgIHRvcCAgPSBgJHtwcm94eVJlY3QudG9wfXB4YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYCR7ZnVsbHlJbmNsdWRlSW50b1dpbmRvdyA/IDAgOiBwcm94eVJlY3QubGVmdCAtIGRyYWdTdGFydFdpbmRvd1JlY3Qud2lkdGh9cHhgO1xuICAgICAgICAgICAgICAgIHRvcCAgPSBgJHtwcm94eVJlY3QudG9wfXB4YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGAke3Byb3h5UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB0b3AgID0gYCR7ZnVsbHlJbmNsdWRlSW50b1dpbmRvdyA/IHRhcmdldFdpbmRvd1NpemUgLSBwcm94eVJlY3QuaGVpZ2h0IDogdGFyZ2V0V2luZG93U2l6ZSArIHByb3h5UmVjdC50b3B9cHhgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3AgOiB0b3BcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0RvY2tlZFdpbmRvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkQXBwcy5pbmNsdWRlcyh0aGlzLmRvY2tlZFdpbmRvd0FwcE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucHJveHlSZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5mdWxseUluY2x1ZGVJbnRvV2luZG93XVxuICAgICAqL1xuICAgIG1vdW50RGlhbG9nSW5PdGhlcldpbmRvdyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgICA9IG1lLmNvbXBvbmVudC5hcHBOYW1lLFxuICAgICAgICAgICAgZGlhbG9nICAgICAgICAgICAgICAgPSBtZS5kaWFsb2csXG4gICAgICAgICAgICBkcmFnRW5kV2luZG93QXBwTmFtZSA9IG1lLmRvY2tlZFdpbmRvd0FwcE5hbWUsXG4gICAgICAgICAgICBzaWRlICAgICAgICAgICAgICAgICA9IG1lLmRvY2tlZFdpbmRvd1NpZGUsXG4gICAgICAgICAgICBwcm94eVBvc2l0aW9uLCB3cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgaWYgKGRpYWxvZy5hcHBOYW1lID09PSBkcmFnRW5kV2luZG93QXBwTmFtZSkge1xuICAgICAgICAgICAgZHJhZ0VuZFdpbmRvd0FwcE5hbWUgPSBtZS5jb21wb25lbnQuYXBwTmFtZTtcbiAgICAgICAgICAgIHNpZGUgICAgICAgICAgICAgICAgID0gbWUuZ2V0T3Bwb3NpdGVTaWRlKG1lLmRvY2tlZFdpbmRvd1NpZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJveHlQb3NpdGlvbiA9IG1lLmdldFByb3h5UG9zaXRpb24oZGF0YS5wcm94eVJlY3QsIHNpZGUsIGRhdGEuZnVsbHlJbmNsdWRlSW50b1dpbmRvdyk7XG5cbiAgICAgICAgZGlhbG9nLnVubW91bnQoKTtcblxuICAgICAgICAvLyB3ZSBuZWVkIGEgZGVsYXkgdG8gZW5zdXJlIGRpYWxvZy5CYXNlOiBvbkRyYWdFbmQoKSBpcyBkb25lLlxuICAgICAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGRyYWdFbmQgZXZlbnQgb2YgdGhlIGRyYWdab25lIGluc3RlYWQuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGlhbG9nLmFwcE5hbWUgPSBkaWFsb2cuYXBwTmFtZSA9PT0gZHJhZ0VuZFdpbmRvd0FwcE5hbWUgPyBhcHBOYW1lIDogZHJhZ0VuZFdpbmRvd0FwcE5hbWU7XG5cbiAgICAgICAgICAgIG1lLmdldE9wZW5EaWFsb2dCdXR0b25zKCkuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChidXR0b24uYXBwTmFtZSA9PT0gZGlhbG9nLmFwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmFuaW1hdGVUYXJnZXRJZCA9IGJ1dHRvbi5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd3JhcHBlclN0eWxlID0gZGlhbG9nLndyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBwcm94eVBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IHByb3h5UG9zaXRpb24udG9wO1xuXG4gICAgICAgICAgICBkaWFsb2cud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICBtZS5kZXN0cm95RG9ja2VkV2luZG93UHJveHkoKTtcblxuICAgICAgICAgICAgZGlhbG9nLm1vdW50KCk7XG4gICAgICAgIH0sIDcwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKi9cbiAgICBvbkFwcENvbm5lY3QoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBuYW1lID0gZGF0YS5hcHBOYW1lO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChtZS5jb25uZWN0ZWRBcHBzLCBuYW1lKTtcblxuICAgICAgICBpZiAobmFtZSAhPT0gJ1NoYXJlZERpYWxvZycgJiYgbWUuY3VycmVudFRoZW1lICE9PSAnbmVvLXRoZW1lLWxpZ2h0Jykge1xuICAgICAgICAgICAgbWUuc3dpdGNoVGhlbWVGb3JBcHAobmFtZSwgbWUuY3VycmVudFRoZW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lKSB7XG4gICAgICAgICAgICBtZS5nZXRPcGVuRG9ja2VkV2luZG93QnV0dG9uKCkuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZW5hYmxlT3BlbkRpYWxvZ0J1dHRvbnMoIW1lLmRpYWxvZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5hcHBOYW1lXG4gICAgICovXG4gICAgb25BcHBEaXNjb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgbmFtZSA9IGRhdGEuYXBwTmFtZTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ1NoYXJlZERpYWxvZycpIHtcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gY2xvc2UgYWxsIHBvcHVwIHdpbmRvd3MsIHdoaWNoIGVxdWFscyB0byBhbGwgY29ubmVjdGVkIGFwcHMgbWludXMgdGhlIG1haW4gYXBwXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobWUuY29ubmVjdGVkQXBwcywgJ1NoYXJlZERpYWxvZycpO1xuXG4gICAgICAgICAgICBOZW8uTWFpbi53aW5kb3dDbG9zZSh7XG4gICAgICAgICAgICAgICAgbmFtZXM6IG1lLmNvbm5lY3RlZEFwcHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShtZS5jb25uZWN0ZWRBcHBzLCBuYW1lKTtcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb24udW5yZWdpc3RlcldpbmRvdyh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSA9PT0gbWUuZG9ja2VkV2luZG93QXBwTmFtZSkge1xuICAgICAgICAgICAgbWUuZ2V0T3BlbkRvY2tlZFdpbmRvd0J1dHRvbigpLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ3JlYXRlRGlhbG9nQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZURpYWxvZyhkYXRhLCB0aGlzLmNvbXBvbmVudC5hcHBOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRGlhbG9nQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlT3BlbkRpYWxvZ0J1dHRvbnModHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRvY2tlZFBvc2l0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9ja2VkV2luZG93U2lkZSA9IGRhdGEuY29tcG9uZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oYXNEb2NrZWRXaW5kb3coKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRpYWxvZyAgICAgICAgICAgICAgPSBtZS5kaWFsb2csXG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0V2luZG93UmVjdCA9IG1lLmRyYWdTdGFydFdpbmRvd1JlY3QsXG4gICAgICAgICAgICAgICAgcHJveHlSZWN0ICAgICAgICAgICA9IFJlY3RhbmdsZS5tb3ZlVG8obWUuZGlhbG9nUmVjdCwgZGF0YS5jbGllbnRYIC0gZGF0YS5vZmZzZXRYLCBkYXRhLmNsaWVudFkgLSBkYXRhLm9mZnNldFkpLFxuICAgICAgICAgICAgICAgIHNpZGUgICAgICAgICAgICAgICAgPSBtZS5kb2NrZWRXaW5kb3dTaWRlO1xuXG4gICAgICAgICAgICBpZiAoZGlhbG9nLmFwcE5hbWUgPT09IG1lLmRvY2tlZFdpbmRvd0FwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzaWRlID0gbWUuZ2V0T3Bwb3NpdGVTaWRlKG1lLmRvY2tlZFdpbmRvd1NpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoUmVjdGFuZ2xlLmxlYXZlc1NpZGUoZHJhZ1N0YXJ0V2luZG93UmVjdCwgcHJveHlSZWN0LCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIGlmIChSZWN0YW5nbGUuZXhjbHVkZXMoZHJhZ1N0YXJ0V2luZG93UmVjdCwgcHJveHlSZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudERpYWxvZ0luT3RoZXJXaW5kb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlSZWN0OiBwcm94eVJlY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJvcERpYWxvZ0JldHdlZW5XaW5kb3dzKHByb3h5UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRG9ja2VkV2luZG93KCkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkaWFsb2dSZWN0ICAgICAgICAgID0gbWUuZGlhbG9nUmVjdCxcbiAgICAgICAgICAgICAgICBkb2NrZWRXaW5kb3dBcHBOYW1lID0gbWUuZG9ja2VkV2luZG93QXBwTmFtZSxcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRXaW5kb3dSZWN0ID0gbWUuZHJhZ1N0YXJ0V2luZG93UmVjdCxcbiAgICAgICAgICAgICAgICBwcm94eVJlY3QgICAgICAgICAgID0gUmVjdGFuZ2xlLm1vdmVUbyhkaWFsb2dSZWN0LCBkYXRhLmNsaWVudFggLSBkYXRhLm9mZnNldFgsIGRhdGEuY2xpZW50WSAtIGRhdGEub2Zmc2V0WSksXG4gICAgICAgICAgICAgICAgc2lkZSAgICAgICAgICAgICAgICA9IG1lLmRvY2tlZFdpbmRvd1NpZGUsXG4gICAgICAgICAgICAgICAgcHJveHlQb3NpdGlvbiwgdmRvbTtcblxuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSB0cmlnZ2VyIHRoZSBkcmFnOnN0YXJ0IGluc2lkZSB0aGUgZG9ja2VkIHdpbmRvdyxcbiAgICAgICAgICAgIC8vIHdlIGNhbiBrZWVwIHRoZSBzYW1lIGxvZ2ljIHdpdGgganVzdCBmbGlwcGluZyB0aGUgc2lkZS5cbiAgICAgICAgICAgIGlmIChtZS5kaWFsb2cuYXBwTmFtZSA9PT0gZG9ja2VkV2luZG93QXBwTmFtZSkge1xuICAgICAgICAgICAgICAgIGRvY2tlZFdpbmRvd0FwcE5hbWUgPSBtZS5jb21wb25lbnQuYXBwTmFtZTtcbiAgICAgICAgICAgICAgICBzaWRlICAgICAgICAgICAgICAgID0gbWUuZ2V0T3Bwb3NpdGVTaWRlKG1lLmRvY2tlZFdpbmRvd1NpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoUmVjdGFuZ2xlLmxlYXZlc1NpZGUoZHJhZ1N0YXJ0V2luZG93UmVjdCwgcHJveHlSZWN0LCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIHByb3h5UG9zaXRpb24gPSBtZS5nZXRQcm94eVBvc2l0aW9uKHByb3h5UmVjdCwgc2lkZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1lLmRvY2tlZFdpbmRvd1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20gPSBOZW8uY2xvbmUobWUuZGlhbG9nLmRyYWdab25lLmRyYWdQcm94eS52ZG9tLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmRvbS5pZDtcblxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3h5UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLmRvY2tlZFdpbmRvd1Byb3h5ID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgOiBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgOiBkb2NrZWRXaW5kb3dBcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b01vdW50IDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9SZW5kZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICAgOiBbJ25lby1kaWFsb2ctd3JhcHBlciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmRvbSAgICAgIDogdmRvbVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3RoZXIgd2luZG93IGhhcyBtb3N0IGxpa2VseSBub3QgbG9hZGVkIFRoZSBkaWFsb2cgSlMgbW9kdWxlIHlldCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBkcmFnIHByb3h5IGlzIHVzaW5nIHNvbWUgQ1NTIHJ1bGVzIG9mIGl0LlxuICAgICAgICAgICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKGRvY2tlZFdpbmRvd0FwcE5hbWUsIE5lby5kaWFsb2cuQmFzZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURvY2tlZFdpbmRvd1Byb3h5U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJveHlQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVEb2NrZWRXaW5kb3dQcm94eVN0eWxlKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0RvY2tlZFdpbmRvdygpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICA9IG1lLmNvbXBvbmVudC5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGRvY2tlZEhvcml6b250YWwgPSBtZS5kb2NrZWRXaW5kb3dTaWRlID09PSAnbGVmdCcgfHwgbWUuZG9ja2VkV2luZG93U2lkZSA9PT0gJ3JpZ2h0JztcblxuICAgICAgICAgICAgbWUuZGlhbG9nUmVjdCA9IGRhdGEuZHJhZ0VsZW1lbnRSZWN0O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGRhdGEuZXZlbnREYXRhLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50YWdOYW1lID09PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ1N0YXJ0V2luZG93UmVjdCA9IGl0ZW0ucmVjdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUuaGFzRG9ja2VkV2luZG93KCkpIHtcbiAgICAgICAgICAgICAgICBOZW8uTWFpbi5nZXRXaW5kb3dEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuZGlhbG9nLmFwcE5hbWUgPT09IGFwcE5hbWUgPyBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lIDogYXBwTmFtZVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRhcmdldFdpbmRvd1NpemUgPSBkb2NrZWRIb3Jpem9udGFsID8gZGF0YS5pbm5lcldpZHRoIDogZGF0YS5pbm5lckhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnWm9uZUNyZWF0ZWQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGRhdGEuZHJhZ1pvbmUub24oe1xuICAgICAgICAgICAgZHJhZ0VuZCAgOiBtZS5vbkRyYWdFbmQsXG4gICAgICAgICAgICBkcmFnTW92ZSA6IG1lLm9uRHJhZ01vdmUsXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IG1lLm9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgc2NvcGUgICAgOiBtZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBvcHVwIHdpbmRvdywgd2hpY2ggaXMgaW5pdGlhbGx5IGRvY2tlZCB0byB0aGlzLmRvY2tlZFdpbmRvd1NpZGUgb2YgdGhlIG1haW4gd2luZG93XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJEYXRhXG4gICAgICovXG4gICAgb3BlbkRvY2tlZFdpbmRvdyhoYW5kbGVyRGF0YSkge1xuICAgICAgICBOZW8uTWFpbi5nZXRXaW5kb3dEYXRhKCkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRvY2sgICA9IG1lLmRvY2tlZFdpbmRvd1NpZGUsXG4gICAgICAgICAgICAgICAgc2l6ZSAgID0gbWUuZG9ja2VkV2luZG93U2l6ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQsIGxlZnQsIHRvcCwgd2lkdGg7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICA9IGRhdGEuc2NyZWVuTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgID0gZGF0YS5vdXRlckhlaWdodCArIGRhdGEuc2NyZWVuVG9wIC0gNTI7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICA9IGRhdGEub3V0ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGRhdGEub3V0ZXJIZWlnaHQgLSA3ODtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgID0gZGF0YS5zY3JlZW5MZWZ0ICAtIHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICA9IGRhdGEuc2NyZWVuVG9wICAgKyAyODtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBkYXRhLm91dGVySGVpZ2h0IC0gNzg7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICA9IGRhdGEub3V0ZXJXaWR0aCAgKyBkYXRhLnNjcmVlbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICA9IGRhdGEuc2NyZWVuVG9wICAgKyAyODtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgID0gZGF0YS5zY3JlZW5MZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0b3AgICAgPSBkYXRhLnNjcmVlblRvcCAtIHNpemUgKyAyODtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggID0gZGF0YS5vdXRlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvLk1haW4ud2luZG93T3Blbih7XG4gICAgICAgICAgICAgICAgdXJsICAgICAgICAgICA6ICcuLi9zaGFyZWRkaWFsb2cyL2luZGV4Lmh0bWwnLFxuICAgICAgICAgICAgICAgIHdpbmRvd0ZlYXR1cmVzOiBgaGVpZ2h0PSR7aGVpZ2h0fSxsZWZ0PSR7bGVmdH0sdG9wPSR7dG9wfSx3aWR0aD0ke3dpZHRofWAsXG4gICAgICAgICAgICAgICAgd2luZG93TmFtZSAgICA6IG1lLmRvY2tlZFdpbmRvd0FwcE5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvbi5yZWdpc3RlcldpbmRvdyh7XG4gICAgICAgICAgICAgICAgZG9jazogZG9jayxcbiAgICAgICAgICAgICAgICBuYW1lOiBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgdGhlbWUgZm9yIGFsbCBjb25uZWN0ZWQgYXBwc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc3dpdGNoVGhlbWUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidXR0b24gICAgID0gZGF0YS5jb21wb25lbnQsXG4gICAgICAgICAgICBidXR0b25UZXh0ID0gJ1RoZW1lIExpZ2h0JyxcbiAgICAgICAgICAgIGRpYWxvZyAgICAgPSBtZS5kaWFsb2csXG4gICAgICAgICAgICBpY29uQ2xzICAgID0gJ2ZhIGZhLXN1bicsXG4gICAgICAgICAgICB0aGVtZSAgICAgID0gJ25lby10aGVtZS1kYXJrJyxcbiAgICAgICAgICAgIGNscztcblxuICAgICAgICBpZiAoYnV0dG9uLnRleHQgPT09ICdUaGVtZSBMaWdodCcpIHtcbiAgICAgICAgICAgIGJ1dHRvblRleHQgPSAnVGhlbWUgRGFyayc7XG4gICAgICAgICAgICBpY29uQ2xzICAgID0gJ2ZhIGZhLW1vb24nO1xuICAgICAgICAgICAgdGhlbWUgICAgICA9ICduZW8tdGhlbWUtbGlnaHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuY29ubmVjdGVkQXBwcy5mb3JFYWNoKGFwcE5hbWUgPT4ge1xuICAgICAgICAgICAgbWUuc3dpdGNoVGhlbWVGb3JBcHAoYXBwTmFtZSwgdGhlbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBidXR0b24uc2V0KHtcbiAgICAgICAgICAgIGljb25DbHM6IGljb25DbHMsXG4gICAgICAgICAgICB0ZXh0ICAgOiBidXR0b25UZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkaWFsb2cpIHtcbiAgICAgICAgICAgIGNscyA9IGRpYWxvZy5jbHM7XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZUFkZChjbHMsIG1lLmN1cnJlbnRUaGVtZSwgdGhlbWUpO1xuXG4gICAgICAgICAgICBkaWFsb2cuY2xzID0gY2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuY3VycmVudFRoZW1lID0gdGhlbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWVcbiAgICAgKi9cbiAgICBzd2l0Y2hUaGVtZUZvckFwcChhcHBOYW1lLCB0aGVtZSkge1xuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2V0Qm9keUNscyh7XG4gICAgICAgICAgICBhcHBOYW1lOiBhcHBOYW1lLFxuICAgICAgICAgICAgYWRkICAgIDogW3RoZW1lXSxcbiAgICAgICAgICAgIHJlbW92ZSA6IFt0aGlzLmN1cnJlbnRUaGVtZV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICovXG4gICAgdXBkYXRlRG9ja2VkV2luZG93UHJveHlTdHlsZShzdHlsZSkge1xuICAgICAgICBsZXQgZG9ja2VkV2luZG93UHJveHkgPSB0aGlzLmRvY2tlZFdpbmRvd1Byb3h5O1xuXG4gICAgICAgIGlmIChkb2NrZWRXaW5kb3dQcm94eSkge1xuICAgICAgICAgICAgZG9ja2VkV2luZG93UHJveHkuc3R5bGUgPSBPYmplY3QuYXNzaWduKGRvY2tlZFdpbmRvd1Byb3h5LnN0eWxlIHx8IHt9LCBzdHlsZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE1haW5Db250YWluZXJDb250cm9sbGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGNsYXNzIHRvIHJlbmRlciBhIGxhYmVsIHdpdGggYSB0ZXh0XG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5MYWJlbFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIExhYmVsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuTGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuTGFiZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGFiZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tbGFiZWwnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tbGFiZWwnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGV4dF89JydcbiAgICAgICAgICovXG4gICAgICAgIHRleHRfOiAnJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e3RhZzogJ2xhYmVsJ31cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAnbGFiZWwnLCBkcmFnZ2FibGU6IGZhbHNlfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZkb20uaHRtbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTGFiZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBMYWJlbDtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgIGZyb20gJy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFuIGV4dGVuZGVkIENvbnRhaW5lciBzdXBwb3J0aW5nIG11bHRpcGxlIGRvY2tlZCBoZWFkZXIgdG9vbGJhcnNcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlBhbmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgUGFuZWwgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5QYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5QYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1wYW5lbCcsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBoZWFkZXJEZWZhdWx0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJEZWZhdWx0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBoZWFkZXJzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1zPXtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgICAgICAgKi9cbiAgICAgICAgX2xheW91dDoge1xuICAgICAgICAgICAgbnR5cGU6ICd2Ym94JyxcbiAgICAgICAgICAgIGFsaWduOiAnc3RyZXRjaCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHZlcnRpY2FsSGVhZGVyc0ZpcnN0PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB2ZXJ0aWNhbEhlYWRlcnNGaXJzdDogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oYXNIZWFkZXJzKCkgJiYgbWUudmVydGljYWxIZWFkZXJzRmlyc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lLmxheW91dCA9IHtcbiAgICAgICAgICAgICAgICBudHlwZTogJ2hib3gnLFxuICAgICAgICAgICAgICAgIGFsaWduOiAnc3RyZXRjaCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyIHRoZSBoZWFkZXIgY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZihoZWFkZXIpID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGZsZXg6ICcwIDEgYXV0bydcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWhlYWRlci5tb2R1bGUgJiYgIWhlYWRlci5udHlwZSkge1xuICAgICAgICAgICAgY29uZmlnLmNscyAgID0gWyduZW8tcGFuZWwtaGVhZGVyLXRvb2xiYXInLCAnbmVvLXRvb2xiYXInXTtcbiAgICAgICAgICAgIGNvbmZpZy5udHlwZSA9ICd0b29sYmFyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWFkZXIudGV4dCkge1xuICAgICAgICAgICAgY29uZmlnLml0ZW1zID0gW3tcbiAgICAgICAgICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tcGFuZWwtaGVhZGVyLXRleHQnLCAnbmVvLWxhYmVsJ10sXG4gICAgICAgICAgICAgICAgdGV4dCA6IGhlYWRlci50ZXh0XG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgZGVsZXRlIGhlYWRlci50ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzdW1pbmcgYWxsIGxhYmVscyBpbnNpZGUgYSBQYW5lbCBIZWFkZXIgYXJlIG1lYW50IHRvIGJlIHRpdGxlcyAtPiBsb29rIHRoZSBzYW1lIHdheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXIuaXRlbXMpKSB7XG4gICAgICAgICAgICBoZWFkZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5udHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNscyA9IFsnbmVvLXBhbmVsLWhlYWRlci10ZXh0JywgJ25lby1sYWJlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi5jb25maWcsIC4uLmhlYWRlcn07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250YWluZXJDb25maWcgPSBtZS5jb250YWluZXJDb25maWc7XG5cbiAgICAgICAgaWYgKCFtZS5oYXNIZWFkZXJzKCkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZyAmJiBtZS5zZXQoY29udGFpbmVyQ29uZmlnKTtcbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaGYgICAgICAgICAgICAgICAgICAgPSBtZS52ZXJ0aWNhbEhlYWRlcnNGaXJzdCA9PT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVycyAgICAgICAgICAgICAgPSBtZS5oZWFkZXJzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGJvdHRvbUhlYWRlcnMgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J2JvdHRvbSc6ICdyaWdodCcpfSksXG4gICAgICAgICAgICAgICAgbGVmdEhlYWRlcnMgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8nbGVmdCcgIDogJ3RvcCcpfSksXG4gICAgICAgICAgICAgICAgcmlnaHRIZWFkZXJzICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ncmlnaHQnIDogJ2JvdHRvbScpfSksXG4gICAgICAgICAgICAgICAgdG9wSGVhZGVycyAgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ndG9wJyAgIDogJ2xlZnQnKX0pLFxuICAgICAgICAgICAgICAgIGhhc0hvcml6b250YWxIZWFkZXJzID0gYm90dG9tSGVhZGVycy5sZW5ndGggPiAwIHx8IHRvcEhlYWRlcnMgIC5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGhhc1ZlcnRpY2FsSGVhZGVycyAgID0gbGVmdEhlYWRlcnMgIC5sZW5ndGggPiAwIHx8IHJpZ2h0SGVhZGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGl0ZW1zICAgICAgICAgICAgICAgID0gbWUuaXRlbXMsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zICAgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbmZpZztcblxuICAgICAgICAgICAgdG9wSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGFzVmVydGljYWxIZWFkZXJzICYmIChoZiAmJiBoYXNIb3Jpem9udGFsSGVhZGVycyB8fCAhaGYgJiYgaGFzSG9yaXpvbnRhbEhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgbGVmdEhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgICAgIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGZsZXggICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EZWZhdWx0czogbWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250YWluZXJDb25maWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zLnB1c2goey4uLm1lLmhlYWRlckRlZmF1bHRzLCAuLi5jb25maWd9KTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0SGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zIDogaG9yaXpvbnRhbEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG50eXBlOiAoaGYgPyAnaGJveCcgOiAndmJveCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZmxleCAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbURlZmF1bHRzOiBtZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goey4uLm1lLmhlYWRlckRlZmF1bHRzLCAuLi5jb25maWd9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm90dG9tSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IHZlcnRpY2FsSXRlbXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1EZWZhdWx0cyA9IG51bGw7XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmhlYWRlcnMpICYmIHRoaXMuaGVhZGVycy5sZW5ndGggPiAwO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoUGFuZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBQYW5lbDtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udGFpbmVyLlZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLlZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3ZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3ZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyAnbmVvLWJvZHktdmlld3BvcnQnIHRvIHRoZSBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFwcGx5Qm9keUNscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWluZyB0aGF0IGEgVmlld3BvcnQgaXMgdGhlIHRvcCBsZXZlbCB2aWV3IG9mIHlvdXIgYXBwLCBhbmQgeW91IHdhbnQgdG8gbW91bnQgaXQgcmlnaHQgYXdheS5cbiAgICAgICAgICogQ291bGQgYmUgd2l0aG91dCBhbnkgaXRlbXMuIFVzZSBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby12aWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby12aWV3cG9ydCddXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgdGhpcy5hcHBseUJvZHlDbHMgJiYgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICBhcHBOYW1lOiB0aGlzLmFwcE5hbWUsXG4gICAgICAgICAgICBjbHMgICAgOiBbJ25lby1ib2R5LXZpZXdwb3J0J11cbiAgICAgICAgfSlcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFZpZXdwb3J0KTtcblxuZXhwb3J0IGRlZmF1bHQgVmlld3BvcnQ7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRNYW5hZ2VyICBmcm9tICcuLi9tYW5hZ2VyL0RvbUV2ZW50Lm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgICBmcm9tICcuLi91dGlsL0xvZ2dlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udHJvbGxlci5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250cm9sbGVyLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb21wb25lbnQtY29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb21wb25lbnQtY29udHJvbGxlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHBhcmVudF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVmZXJlbmNlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZmVyZW5jZXM6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGxpc3RlbmVySWQ7XG5cbiAgICAgICAgbWUucmVmZXJlbmNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wb25lbnQuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJJZCA9IGNvbXBvbmVudC5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnVuKCdjb25zdHJ1Y3RlZCcsIGxpc3RlbmVySWQpO1xuICAgICAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBhcmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUgOiB0aGlzLmdldFBhcmVudCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnQgPSBtZS5wYXJlbnQ7XG5cbiAgICAgICAgcmV0dXJuIE5lby5pc0Z1bmN0aW9uKG1lW2hhbmRsZXJOYW1lXSkgP1xuICAgICAgICAgICAgbWUgOiBwYXJlbnQgP1xuICAgICAgICAgICAgcGFyZW50LmdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNhbWVMZXZlbE9ubHk9ZmFsc2Ugd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVk0gaW5zaWRlIHRoZSBjb21wb25lbnQgcGFyZW50IHRyZWUsXG4gICAgICogaW4gY2FzZSB0aGVyZSBpcyBub25lIG9uIHRoZSBzYW1lIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NhbWVMZXZlbE9ubHk9ZmFsc2VdXG4gICAgICovXG4gICAgZ2V0TW9kZWwoc2FtZUxldmVsT25seT1mYWxzZSkge1xuICAgICAgICBsZXQgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBzYW1lTGV2ZWxPbmx5ID8gY29tcG9uZW50Lm1vZGVsIDogY29tcG9uZW50LmdldE1vZGVsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IGNvbnRyb2xsZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCwgcGFyZW50SWQ7XG5cbiAgICAgICAgaWYgKG1lLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudElkICAgICAgICA9IG1lLmNvbXBvbmVudC5wYXJlbnRJZDtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50ID0gcGFyZW50SWQgJiYgTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudENvbXBvbmVudD8uZ2V0Q29udHJvbGxlcigpIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogdXBkYXRlIGNoYW5nZWQgcmVmZXJlbmNlcyAoZS5nLiBjb250YWluZXIucmVtb3ZlKCkgdGhlbiBjb250YWluZXIuYWRkKCkgdXNpbmcgdGhlIHNhbWUga2V5KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5yZWZlcmVuY2VzW25hbWVdO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5jb21wb25lbnQuZG93bih7cmVmZXJlbmNlOiBuYW1lfSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZWZlcmVuY2VzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSB5b3VyIHZpZXcgY29udHJvbGxlcnMgYXMgYSBzdGFydGluZyBwb2ludCBpbiBjYXNlIHlvdSBuZWVkIHJlZmVyZW5jZXNcbiAgICAgKiAoaW5zdGVhZCBvZiB1c2luZyBvbkNvbnN0cnVjdGVkKCkgaW5zaWRlIHlvdXIgY29udHJvbGxlcilcbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENvbnN0cnVjdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQ9dGhpcy5jb21wb25lbnRcbiAgICAgKi9cbiAgICBwYXJzZUNvbmZpZyhjb21wb25lbnQ9dGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBjb21wb25lbnQubGlzdGVuZXJzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gY29tcG9uZW50LnJlZmVyZW5jZSxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgaGFuZGxlclNjb3BlO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3Njb3BlJyAmJiBrZXkgIT09ICdkZWxlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgZm9yJywgZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldLmZuID0gaGFuZGxlclNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChoYW5kbGVyU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdChsaXN0ZW5lcikgJiYgbGlzdGVuZXIuaGFzT3duUHJvcGVydHkoJ2ZuJykgJiYgTmVvLmlzU3RyaW5nKGxpc3RlbmVyLmZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSBsaXN0ZW5lci5mbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIGZvcicsIGV2ZW50SGFuZGxlciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmZuID0gaGFuZGxlclNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChoYW5kbGVyU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIG1lLnJlZmVyZW5jZXNbcmVmZXJlbmNlXSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQ9dGhpcy5jb21wb25lbnRcbiAgICAgKi9cbiAgICBwYXJzZURvbUxpc3RlbmVycyhjb21wb25lbnQ9dGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMgPSBjb21wb25lbnQuZG9tTGlzdGVuZXJzLFxuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLCBzY29wZTtcblxuICAgICAgICBpZiAoZG9tTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMuZm9yRWFjaChkb21MaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZG9tTGlzdGVuZXIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScgJiYga2V5ICE9PSAnZGVsZWdhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdmbicpICYmIE5lby5pc1N0cmluZyh2YWx1ZS5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZS5mbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biBkb21FdmVudCBoYW5kbGVyIGZvcicsIGV2ZW50SGFuZGxlciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcltrZXldID0gc2NvcGVbZXZlbnRIYW5kbGVyXS5iaW5kKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgY2FsbGVkIGJ5IGNvbXBvbmVudC5CYXNlOiBkZXN0cm95KCkgaW4gY2FzZSB0aGUgY29tcG9uZW50IGhhcyBhIHJlZmVyZW5jZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVmZXJlbmNlcyA9IG1lLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gcmVmZXJlbmNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZXNba2V5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldFBhcmVudCgpPy5yZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiIsImltcG9ydCBCYXNlICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLkNoZWNrQm94XG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5CYXNlXG4gKi9cbmNsYXNzIENoZWNrQm94IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBsYWJlbFBvc2l0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsUG9zaXRpb25zPVsnbGVmdCcsJ3RvcCddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGFiZWxQb3NpdGlvbnMgPSBbJ2xlZnQnLCAndG9wJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQ2hlY2tCb3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLkNoZWNrQm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NoZWNrYm94ZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2hlY2tib3hmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jaGVja2JveGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNoZWNrYm94ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNoZWNrZWRfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWRlTGFiZWxfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlTGFiZWxfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpY29uQ2xzPVsnZmFyJywnZmEtc3F1YXJlJ11cbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6IFsnZmFyJywgJ2ZhLXNxdWFyZSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGljb25DbHNDaGVja2VkPVsnZmFzJywnZmEtY2hlY2snXVxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNsc0NoZWNrZWQ6IFsnZmFzJywgJ2ZhLWNoZWNrJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlucHV0VHlwZV89J2NoZWNrYm94J1xuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRUeXBlXzogJ2NoZWNrYm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBsYWJlbEJhc2VDbHM9WyduZW8tY2hlY2tib3gtbGFiZWwnXVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxCYXNlQ2xzOiBbJ25lby1jaGVja2JveC1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsQ2xzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2xlZnQnLCAndG9wJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsUG9zaXRpb25fPSdsZWZ0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxQb3NpdGlvbl86ICdsZWZ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGFiZWxUZXh0Xz0nTGFiZWxUZXh0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxUZXh0XzogJ0xhYmVsVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBsYWJlbFdpZHRoXz0xNTBcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsV2lkdGhfOiAxNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IFRoZSBuYW1lIChncm91cCkgb2YgdGhlIGlucHV0IGRvbSBub2RlXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lXzogJycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdmFsdWVMYWJlbFRleHRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlTGFiZWxUZXh0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAnbGFiZWwnLCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ3NwYW4nLCAgY2xzOiBbXX0sXG4gICAgICAgICAgICB7dGFnOiAnaW5wdXQnLCBjbHM6IFsnbmVvLWNoZWNrYm94LWlucHV0J119LFxuICAgICAgICAgICAge3RhZzogJ2knLCAgICAgY2xzOiBbJ25lby1jaGVja2JveC1pY29uJ119LFxuICAgICAgICAgICAge3RhZzogJ3NwYW4nLCAgY2xzOiBbJ25lby1jaGVja2JveC12YWx1ZS1sYWJlbCddfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFxuICAgICAgICAgICAge2NoYW5nZTogbWUub25JbnB1dFZhbHVlQ2hhbmdlLCBzY29wZTogbWV9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDaGVja2VkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpY29uQ2xzID0gbWUudmRvbS5jblsyXS5jbHMsXG4gICAgICAgICAgICBuZXdDbHMgID0gdmFsdWUgPyBtZS5pY29uQ2xzQ2hlY2tlZCA6IG1lLmljb25DbHMsXG4gICAgICAgICAgICBvbGRDbHMgID0gdmFsdWUgPyBtZS5pY29uQ2xzIDogbWUuaWNvbkNsc0NoZWNrZWQ7XG5cbiAgICAgICAgbWUudmRvbS5jblsxXS5jaGVja2VkID0gdmFsdWU7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGljb25DbHMsIG9sZENscyk7XG4gICAgICAgIE5lb0FycmF5LmFkZChpY29uQ2xzLCBuZXdDbHMpO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBtZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZUxhYmVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGVMYWJlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLmNuWzBdLnJlbW92ZURvbSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tO1xuXG4gICAgICAgIHZkb20uY25bMF0uaWQgPSBtZS5nZXRMYWJlbElkKCk7XG4gICAgICAgIHZkb20uY25bMV0uaWQgPSBtZS5nZXRJbnB1dEVsSWQoKTtcbiAgICAgICAgdmRvbS5jblsyXS5pZCA9IG1lLmdldEljb25FbElkKCk7XG4gICAgICAgIHZkb20uY25bM10uaWQgPSBtZS5nZXRWYWx1ZUxhYmVsSWQoKTtcblxuICAgICAgICAvLyBzaWxlbnQgdmRvbSB1cGRhdGUsIHRoZSBzdXBlciBjYWxsIHdpbGwgdHJpZ2dlciB0aGUgZW5naW5lXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlucHV0VHlwZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbnB1dFR5cGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5jblsxXS50eXBlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbENscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUudmRvbS5jblswXS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFBvc2l0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tbGFiZWwtJyArIG9sZFZhbHVlKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKCAgIGNscywgJ25lby1sYWJlbC0nICsgdmFsdWUpO1xuICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZkb20uY25bMF0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFdpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmhpZGVMYWJlbCkge1xuICAgICAgICAgICAgbWUudmRvbS5jblswXS53aWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgbWUudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLmNuWzFdLm5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmRvbS5jblsxXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlTGFiZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlTGFiZWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2YWx1ZUxhYmVsID0gbWUudmRvbS5jblszXSxcbiAgICAgICAgICAgIHNob3dMYWJlbCAgPSAhIXZhbHVlOyAvLyBoaWRlIHRoZSBsYWJlbCwgaW4gY2FzZSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJydcblxuICAgICAgICBpZiAoc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICB2YWx1ZUxhYmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVMYWJlbC5yZW1vdmVEb20gPSAhc2hvd0xhYmVsO1xuICAgICAgICBtZS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBsYWJlbENscyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TGFiZWxDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW9BcnJheS51bmlvbih2YWx1ZSB8fCBbXSwgdGhpcy5sYWJlbEJhc2VDbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGxhYmVsUG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNldExhYmVsUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdsYWJlbFBvc2l0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJY29uRWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pY29uYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElucHV0RWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pbnB1dGA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRMYWJlbElkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2xhYmVsYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFZhbHVlTGFiZWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X192YWx1ZS1sYWJlbGA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiBhIHVzZXIgY2hlY2tzIGEgY2hlY2tib3ggaW5wdXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbklucHV0VmFsdWVDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjaGVja2VkID0gZGF0YS50YXJnZXQuY2hlY2tlZDtcblxuICAgICAgICAvLyBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgaW4gc3luYyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgbWUudm5vZGUuY2hpbGROb2Rlc1ttZS5oaWRlTGFiZWwgPyAwIDogMV0uYXR0cmlidXRlcy5jaGVja2VkID0gYCR7Y2hlY2tlZH1gO1xuXG4gICAgICAgIG1lLmNoZWNrZWQgPSBjaGVja2VkO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ2hlY2tCb3gpO1xuXG5leHBvcnQgZGVmYXVsdCBDaGVja0JveDtcbiIsImltcG9ydCBDaGVja0JveCAgICAgICAgIGZyb20gJy4vQ2hlY2tCb3gubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcydcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuUmFkaW9cbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLkNoZWNrQm94XG4gKi9cbmNsYXNzIFJhZGlvIGV4dGVuZHMgQ2hlY2tCb3gge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuUmFkaW8nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLlJhZGlvJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3JhZGlvZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncmFkaW9maWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1yYWRpb2ZpZWxkJywnbmVvLWNoZWNrYm94ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcmFkaW9maWVsZCcsICduZW8tY2hlY2tib3hmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGljb25DbHM9WydmYXInLCdmYS1jaXJjbGUnXVxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNsczogWydmYXInLCAnZmEtY2lyY2xlJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlucHV0VHlwZT0ncmFkaW8nXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFR5cGU6ICdyYWRpbydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNoZWNrZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDaGVja2VkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldENoZWNrZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAvLyB1cGRhdGUgcmFkaW9zIHdpdGggdGhlIHNhbWUgbmFtZSB0byBiZSB1bmNoZWNrZWRcbiAgICAgICAgdmFsdWUgJiYgdGhpcy51bmNoZWNrR3JvdXBJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmFkaW9zIGRvIG5vdCBmaXJlIGEgY2hhbmdlIGV2ZW50IGZvciBcInVuY2hlY2tcIiwgc28gd2UgbmVlZCB0byBpdGVyYXRlIG92ZXIgb3RoZXIgcmFkaW9zIHdpdGggdGhlIHNhbWUgbmFtZS5cbiAgICAgKi9cbiAgICB1bmNoZWNrR3JvdXBJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHJhZGlvcztcblxuICAgICAgICAvLyBkaXNjdXNzOiB3ZSBjb3VsZCBsaW1pdCB0aGlzIHRvIHJhZGlvcyBpbnNpZGUgdGhlIHNhbWUgZm9ybSwgSUYgYSB0b3AgbGV2ZWwgZm9ybSBpcyB1c2VkXG4gICAgICAgIHJhZGlvcyA9IENvbXBvbmVudE1hbmFnZXIuZmluZCh7XG4gICAgICAgICAgICBudHlwZTogJ3JhZGlvZmllbGQnLFxuICAgICAgICAgICAgbmFtZSA6IG1lLm5hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmFkaW9zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5pZCAhPT0gbWUuaWQgJiYgaXRlbS5fY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoUmFkaW8pO1xuXG5leHBvcnQgZGVmYXVsdCBSYWRpbztcbiIsImltcG9ydCBCdXR0b24gICAgZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMYWJlbCAgICAgZnJvbSAnLi4vY29tcG9uZW50L0xhYmVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRvb2xiYXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgZG9ja1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkb2NrUG9zaXRpb25zPVsndG9wJywncmlnaHQnLCdib3R0b20nLCdsZWZ0J11cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRvY2tQb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50b29sYmFyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50b29sYmFyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRvb2xiYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkb2NrXz0ndG9wJ1xuICAgICAgICAgKi9cbiAgICAgICAgZG9ja186ICd0b3AnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHM9e250eXBlOididXR0b24nfVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbURlZmF1bHRzOiB7XG4gICAgICAgICAgICBudHlwZTogJ2J1dHRvbidcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX2xheW91dD17bnR5cGU6ICdoYm94JywgYWxpZ246ICdjZW50ZXInLCBwYWNrIDogJ3N0YXJ0J31cbiAgICAgICAgICovXG4gICAgICAgIF9sYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlOiAnaGJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBwYWNrIDogJ3N0YXJ0J1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lfG51bGx9IHNvcnRab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzb3J0Wm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZUNvbmZpZzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXBwTmFtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFpvbmUuYXBwTmFtZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkb2NrIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgPSBtZS5jbHMsXG4gICAgICAgICAgICBkb2NrUG9zaXRpb25zID0gbWUuZ2V0U3RhdGljQ29uZmlnKCdkb2NrUG9zaXRpb25zJyk7XG5cbiAgICAgICAgZG9ja1Bvc2l0aW9ucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBOZW9BcnJheVtrZXkgPT09IHZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWRvY2stJyArIGtleSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmNscyAgICA9IGNscztcbiAgICAgICAgbWUubGF5b3V0ID0gbWUuZ2V0TGF5b3V0Q29uZmlnKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLnNvcnRab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IGRvY2sgcG9zaXRpb24gbWF0Y2hlcyBhIHZhbHVlIG9mIHRoZSBzdGF0aWMgZG9ja1Bvc2l0aW9ucyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZG9jaycsICdkb2NrUG9zaXRpb25zJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSAnLT4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2luZGV4XSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4ICA6IDFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSXRlbXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF5b3V0IGNvbmZpZyBkZXBlbmRpbmcgb24gdGhpcy5kb2NrXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKCkge1xuICAgICAgICBsZXQgbGF5b3V0Q29uZmlnO1xuXG4gICAgICAgIHN3aXRjaCh0aGlzLmRvY2spIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGU6ICdoYm94JyxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBwYWNrIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgIDogJ3Zib3gnLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4tcmV2ZXJzZScsXG4gICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICA6ICd2Ym94JyxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXlvdXRDb25maWc7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhCYXNlKTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIFRoZSBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCBET01SZWN0IE9iamVjdHNcbiAqIEBjbGFzcyBOZW8udXRpbC5SZWN0YW5nbGVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5SZWN0YW5nbGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlJlY3RhbmdsZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcmVjdDEgZG9lcyBub3QgaGF2ZSBhbiBpbnRlcnNlY3Rpb24gd2l0aCByZWN0MlxuICAgICAqICFpbmNsdWRlcygpIGlzIHRydWUgZm9yIGludGVyc2VjdGlvbnMgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBleGNsdWRlcyhyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA8IHJlY3QyLnRvcCAgICAgLy8gcmVjdDIgaXMgYmVsb3cgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLmxlZnQgICA+IHJlY3QyLnJpZ2h0ICAgLy8gcmVjdDIgaXMgbGVmdCBvZiByZWN0MVxuICAgICAgICAgICAgfHwgcmVjdDEucmlnaHQgIDwgcmVjdDIubGVmdCAgICAvLyByZWN0MiBpcyByaWdodCBvZiByZWN0MVxuICAgICAgICAgICAgfHwgcmVjdDEudG9wICAgID4gcmVjdDIuYm90dG9tOyAvLyByZWN0MiBpcyBhYm92ZSByZWN0MVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG92ZXJsYXBwaW5nIGFyZWEgb2YgcmVjdDEgJiByZWN0MlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhcmVhICh4ICogeSlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SW50ZXJzZWN0aW9uKHJlY3QxLCByZWN0Mikge1xuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlLmdldEludGVyc2VjdGlvbkRldGFpbHMocmVjdDEsIHJlY3QyKS5hcmVhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG92ZXJsYXBwaW5nIGFyZWEgb2YgcmVjdDEgJiByZWN0MlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHgsIHkgJiBhcmVhXG4gICAgICovXG4gICAgc3RhdGljIGdldEludGVyc2VjdGlvbkRldGFpbHMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIGxldCB3aWR0aCAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0MS5yaWdodCwgIHJlY3QyLnJpZ2h0KSAgLSBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSksXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSkgLSBNYXRoLm1heChyZWN0MS50b3AsICByZWN0Mi50b3ApKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJlYTogaGVpZ2h0ICogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiByZWN0MiBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIHJlY3QxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3QxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3QyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGluY2x1ZGVzKHJlY3QxLCByZWN0Mikge1xuICAgICAgICByZXR1cm4gcmVjdDEuYm90dG9tID49IHJlY3QyLmJvdHRvbVxuICAgICAgICAgICAgJiYgcmVjdDEubGVmdCAgIDw9IHJlY3QyLmxlZnRcbiAgICAgICAgICAgICYmIHJlY3QxLnJpZ2h0ICA+PSByZWN0Mi5yaWdodFxuICAgICAgICAgICAgJiYgcmVjdDEudG9wICAgIDw9IHJlY3QyLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcmVjdDIgaXMgbm90IGNvbnRhaW5lZCBpbnNpZGUgcmVjdDEuXG4gICAgICogVGhpcyBjb3VsZCBiZSBhbiBpbnRlcnNlY3Rpb24gb3IgYmVpbmcgZnVsbHkgZXhjbHVkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3QxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3QyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpZGUgYm90dG9tLCBsZWZ0LCByaWdodCBvciB0b3BcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbGVhdmVzU2lkZShyZWN0MSwgcmVjdDIsIHNpZGUpIHtcbiAgICAgICAgaWYgKFJlY3RhbmdsZS5pbmNsdWRlcyhyZWN0MSwgcmVjdDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPCByZWN0Mi5ib3R0b207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEubGVmdCA+IHJlY3QyLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLnJpZ2h0IDwgcmVjdDIucmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS50b3AgPiByZWN0Mi50b3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGEgRE9NUmVjdCBvYmplY3QgdG8gYSBuZXcgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt4PW51bGxdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gW3k9bnVsbF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtb3ZlZFJlY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgbW92ZUJ5KHJlY3QsIHg9bnVsbCwgeT1udWxsKSB7XG4gICAgICAgIGxldCBtb3ZlZFJlY3QgPSB7Li4ucmVjdH07XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih4KSkge1xuICAgICAgICAgICAgbW92ZWRSZWN0LmxlZnQgICs9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QucmlnaHQgKz0geDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC54ICAgICArPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih5KSkge1xuICAgICAgICAgICAgbW92ZWRSZWN0LmJvdHRvbSArPSB5O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnRvcCAgICArPSB5O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnkgICAgICArPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVkUmVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGEgRE9NUmVjdCBvYmplY3QgdG8gYSBuZXcgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt4PW51bGxdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gW3k9bnVsbF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtb3ZlZFJlY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgbW92ZVRvKHJlY3QsIHg9bnVsbCwgeT1udWxsKSB7XG4gICAgICAgIGxldCBtb3ZlZFJlY3QgPSB7Li4ucmVjdH07XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih4KSkge1xuICAgICAgICAgICAgbW92ZWRSZWN0LmxlZnQgID0geDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5yaWdodCA9IHggKyBtb3ZlZFJlY3Qud2lkdGg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueCAgICAgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih5KSkge1xuICAgICAgICAgICAgbW92ZWRSZWN0LmJvdHRvbSA9IHkgKyBtb3ZlZFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnRvcCAgICA9IHk7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueSAgICAgID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlZFJlY3Q7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhSZWN0YW5nbGUpO1xuXG5leHBvcnQgZGVmYXVsdCBSZWN0YW5nbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=