"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_list_plugin_Animate_mjs"],{

/***/ "./src/list/plugin/Animate.mjs":
/*!*************************************!*\
  !*** ./src/list/plugin/Animate.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Animate)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Css.mjs */ "./src/util/Css.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.list.plugin.Animate
 * @extends Neo.plugin.Base
 */
class Animate extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.list.plugin.Animate'
         * @protected
         */
        className: 'Neo.list.plugin.Animate',
        /**
         * Read only
         * @member {Number|null} columns=null
         */
        columns: null,
        /**
         * Value in px
         * @member {Number} itemHeight=200
         */
        itemHeight: 200,
        /**
         * Value in px
         * @member {Number} itemMargin=10
         */
        itemMargin: 10,
        /**
         * Value in px
         * @member {Number} itemWidth=300
         */
        itemWidth: 300,
        /**
         * @member {DOMRect|null} ownerRect=null
         */
        ownerRect: null,
        /**
         * Read only
         * @member {Number|null} rows=null
         */
        rows: null,
        /**
         * Time in ms. Please ensure to match the CSS based value, in case you change the default.
         * @member {Number} transitionDuration_=500
         */
        transitionDuration_: 2000,
        /**
         * The id of the setTimeout() call which gets triggered after a transition is done.
         * @member {Number|null} transitionTimeoutId=null
         */
        transitionTimeoutId: null
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me    = this,
            owner = me.owner;

        me.adjustCreateItem();

        owner.onStoreFilter = me.onStoreFilter.bind(me);

        owner.store.on({
            sort : me.onStoreSort,
            scope: me
        });
    }

    /**
     *
     */
    adjustCreateItem() {
        let me    = this,
            owner = me.owner;

        me.ownerCreateItem = owner.createItem.bind(owner);
        owner.createItem   = me.createItem.bind(owner, me);
    }

    /**
     * Triggered after the transitionDuration config got changed.
     *
     * We do not want to apply the style to each list item itself,
     * so we are using Neo.util.Css
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetTransitionDuration(value, oldValue) {
        Neo.isNumber(oldValue) && _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].deleteRules(`#${this.owner.id} .neo-list-item`);

        _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].insertRules([
            `#${this.owner.id} .neo-list-item {`,
                `transition: opacity ${value}ms ease-in-out, transform ${value}ms ease-in-out`,
            '}'
        ].join(''));
    }

    /**
     * @param {Neo.list.plugin.Animate} me
     * @param {Object} record
     * @param {Number} index
     * @returns {Object}
     */
    createItem(me, record, index) {
        let item     = me.ownerCreateItem(record, index),
            position = me.getItemPosition(record, index),
            style    = item.style || {};

        if (!me.ownerRect) {
            return null;
        }

        Object.assign(style, {
            height   : `${me.itemHeight}px`,
            position : 'absolute',
            transform: `translate(${position.x}px, ${position.y}px)`,
            width    : `${me.itemWidth}px`
        });

        item.style = style;

        return item;
    }

    /**
     *
     * @param {Object} record
     * @param {Number} index
     * @returns {{x: Number, y: Number}}
     */
    getItemPosition(record, index) {
        let me     = this,
            column = index % me.columns,
            margin = me.itemMargin,
            row    = Math.floor(index / me.columns),
            x      = column * (margin + me.itemWidth)  + margin,
            y      = row    * (margin + me.itemHeight) + margin;

        return {x, y};
    }

    /**
     *
     * @param {Object} obj
     * @param {String[]} map
     * @param {Boolean} intercept
     * @returns {Number}
     */
    getItemIndex(obj, map, intercept) {
        if (!intercept) {
            return obj.index;
        }

        let owner = this.owner,
            key   = owner.store.keyProperty;

        return map.indexOf(owner.getItemId(obj.record[key]));
    }

    /**
     *
     */
    onOwnerMounted() {
        let me = this;

        me.owner.getDomRect().then(rect => {
            Object.assign(me, {
                columns  : Math.floor(rect.width / me.itemWidth),
                ownerRect: rect,
                rows     : Math.floor(rect.height / me.itemHeight)
            });
        });
    }

    /**
     * @param {Object} data
     * @param {Boolean} data.isFiltered
     * @param {Object[]} data.items
     * @param {Object[]} data.oldItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreFilter(data) {
        let me                  = this,
            owner               = me.owner,
            key                 = owner.store.keyProperty,
            hasAddedItems       = false,
            addedItems          = [],
            movedItems          = [],
            removedItems        = [],
            transitionTimeoutId = me.transitionTimeoutId,
            intercept           = !!transitionTimeoutId,
            vdom                = owner.vdom,
            index, item, map, position, vdomIndex;

        if (transitionTimeoutId) {
            clearTimeout(transitionTimeoutId);
            me.transitionTimeoutId = null;
        }

        map = intercept ? vdom.cn.map(e => e.id) : [];

        data.items.forEach((record, index) => {
            item = {index, record};

            if (!data.oldItems.includes(record)) {
                // flag items which are still inside the DOM (running remove OP)
                if (intercept && map.includes(owner.getItemId(record[key]))) {
                    item.reAdded = true;
                }

                addedItems.push(item);
            } else {
                movedItems.push(item);
            }
        });

        data.oldItems.forEach((record, index) => {
            if (!data.items.includes(record)) {
                removedItems.push({index, record});
            }
        });

        addedItems.forEach(obj => {
            if (!obj.reAdded) {
                index = me.getItemIndex(obj, map, intercept);

                if (index > -1) {
                    hasAddedItems = true;

                    vdom.cn.splice(index, 0, me.createItem(me, obj.record, obj.index));

                    obj.item = vdom.cn[index];
                    obj.item.style.opacity = 0;
                }
            }
        });

        if (hasAddedItems) {
            owner.vdom = vdom;
        }

        // ensure to get into the next animation frame
        setTimeout(() => {
            // get the latest version of the vdom, since this is a delayed callback
            vdom = owner.vdom;

            // new items are already added into the vdom, while old items are not yet removed
            // => we need a map to ensure getting the correct index
            map = vdom.cn.map(e => e.id);

            addedItems.forEach(obj => {
                index = me.getItemIndex(obj, map, intercept);

                if (index > -1) {
                    // we can change the opacity for re-added items too => the vdom engine will ignore this
                    vdom.cn[index].style.opacity = 1;
                }
            });

            movedItems.forEach(obj => {
                index = me.getItemIndex(obj, map, true); // honor removed items, even without interceptions

                if (index > -1) {
                    position = me.getItemPosition(obj.record, obj.index);

                    Object.assign(vdom.cn[index].style, {
                        opacity  : 1,
                        transform: `translate(${position.x}px, ${position.y}px)`
                    });
                }
            });

            removedItems.forEach(obj => {
                index = me.getItemIndex(obj, map, intercept);

                if (index > -1) {
                    obj.item = vdom.cn[index];
                    obj.item.style.opacity = 0;
                }
            });

            owner.vdom = vdom;

            me.triggerTransitionCallback();
        }, 50);
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        let me          = this,
            hasChange   = false,
            keyProperty = data.scope.keyProperty,
            owner       = me.owner,
            newVdomCn   = [],
            vdom        = owner.vdom,
            vdomMap     = vdom.cn.map(e => e.id),
            fromIndex, itemId;

        if (vdomMap.length > 0) {
            data.items.forEach((item, index) => {
                itemId    = owner.getItemId(item[keyProperty]);
                fromIndex = vdomMap.indexOf(itemId);

                newVdomCn.push(vdom.cn[fromIndex]);

                if (fromIndex !== index) {
                    hasChange = true;
                }
            });

            if (hasChange) {
                owner.vdom.cn = newVdomCn;

                owner.promiseVdomUpdate().then(() => {
                    // we need to ensure to get this call into the next animation frame
                    setTimeout(() => {
                        owner.createItems();
                    }, 50);
                });
            }
        }
    }

    /**
     *
     */
    triggerTransitionCallback() {
        let me = this;

        me.transitionTimeoutId = setTimeout(() => {
            me.transitionTimeoutId = null;

            me.owner.createItems();
        }, me.transitionDuration);
    }
}

Neo.applyClassConfig(Animate);




/***/ }),

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.owner.mounted) {
            me.onOwnerMounted();
        } else {
            me.owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

Neo.applyClassConfig(Base);




/***/ }),

/***/ "./src/util/Css.mjs":
/*!**************************!*\
  !*** ./src/util/Css.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Css
 * @extends Neo.core.Base
 */
class Css extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.util.Css'
         * @protected
         */
        className: 'Neo.util.Css'
    }}

    /**
     * Pass the selectorText of the rules which you want to remove
     * @param {String[]|String} rules
     */
    static deleteRules(rules) {
        if (!Array.isArray(rules)) {
            rules = [rules];
        }

        Neo.main.addon.Stylesheet.deleteCssRules({
            rules: rules
        });
    }

    /**
     * @param {String[]|String} rules
     */
    static insertRules(rules) {
        if (!Array.isArray(rules)) {
            rules = [rules];
        }

        Neo.main.addon.Stylesheet.insertCssRules({
            rules: rules
        });
    }
}

Neo.applyClassConfig(Css);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Css);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19saXN0X3BsdWdpbl9BbmltYXRlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0g7QUFDQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUIsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUVBQW1CLEtBQUssZUFBZTs7QUFFekUsUUFBUSxpRUFBbUI7QUFDM0IsZ0JBQWdCLGVBQWUsZ0JBQWdCO0FBQy9DLHVDQUF1QyxNQUFNLDRCQUE0QixNQUFNO0FBQy9FLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFB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QSxrQkFBa0Isc0RBQUk7QUFDdEIsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLGlFQUFlLEdBQUcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbGlzdC9wbHVnaW4vQW5pbWF0ZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9wbHVnaW4vQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0Nzcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4uLy4uL3BsdWdpbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ3NzVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9Dc3MubWpzJztcbmltcG9ydCBWZG9tVXRpbCBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxpc3QucGx1Z2luLkFuaW1hdGVcbiAqIEBleHRlbmRzIE5lby5wbHVnaW4uQmFzZVxuICovXG5jbGFzcyBBbmltYXRlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LnBsdWdpbi5BbmltYXRlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGlzdC5wbHVnaW4uQW5pbWF0ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGNvbHVtbnM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaXRlbUhlaWdodD0yMDBcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1IZWlnaHQ6IDIwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaXRlbU1hcmdpbj0xMFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbU1hcmdpbjogMTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGl0ZW1XaWR0aD0zMDBcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1XaWR0aDogMzAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RE9NUmVjdHxudWxsfSBvd25lclJlY3Q9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXJSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZCBvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSByb3dzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHJvd3M6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGluIG1zLiBQbGVhc2UgZW5zdXJlIHRvIG1hdGNoIHRoZSBDU1MgYmFzZWQgdmFsdWUsIGluIGNhc2UgeW91IGNoYW5nZSB0aGUgZGVmYXVsdC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0cmFuc2l0aW9uRHVyYXRpb25fPTUwMFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uXzogMjAwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgc2V0VGltZW91dCgpIGNhbGwgd2hpY2ggZ2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgYSB0cmFuc2l0aW9uIGlzIGRvbmUuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0cmFuc2l0aW9uVGltZW91dElkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25UaW1lb3V0SWQ6IG51bGxcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyID0gbWUub3duZXI7XG5cbiAgICAgICAgbWUuYWRqdXN0Q3JlYXRlSXRlbSgpO1xuXG4gICAgICAgIG93bmVyLm9uU3RvcmVGaWx0ZXIgPSBtZS5vblN0b3JlRmlsdGVyLmJpbmQobWUpO1xuXG4gICAgICAgIG93bmVyLnN0b3JlLm9uKHtcbiAgICAgICAgICAgIHNvcnQgOiBtZS5vblN0b3JlU29ydCxcbiAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkanVzdENyZWF0ZUl0ZW0oKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyO1xuXG4gICAgICAgIG1lLm93bmVyQ3JlYXRlSXRlbSA9IG93bmVyLmNyZWF0ZUl0ZW0uYmluZChvd25lcik7XG4gICAgICAgIG93bmVyLmNyZWF0ZUl0ZW0gICA9IG1lLmNyZWF0ZUl0ZW0uYmluZChvd25lciwgbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhbnNpdGlvbkR1cmF0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIFdlIGRvIG5vdCB3YW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0byBlYWNoIGxpc3QgaXRlbSBpdHNlbGYsXG4gICAgICogc28gd2UgYXJlIHVzaW5nIE5lby51dGlsLkNzc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvbkR1cmF0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBOZW8uaXNOdW1iZXIob2xkVmFsdWUpICYmIENzc1V0aWwuZGVsZXRlUnVsZXMoYCMke3RoaXMub3duZXIuaWR9IC5uZW8tbGlzdC1pdGVtYCk7XG5cbiAgICAgICAgQ3NzVXRpbC5pbnNlcnRSdWxlcyhbXG4gICAgICAgICAgICBgIyR7dGhpcy5vd25lci5pZH0gLm5lby1saXN0LWl0ZW0ge2AsXG4gICAgICAgICAgICAgICAgYHRyYW5zaXRpb246IG9wYWNpdHkgJHt2YWx1ZX1tcyBlYXNlLWluLW91dCwgdHJhbnNmb3JtICR7dmFsdWV9bXMgZWFzZS1pbi1vdXRgLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmxpc3QucGx1Z2luLkFuaW1hdGV9IG1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlSXRlbShtZSwgcmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgaXRlbSAgICAgPSBtZS5vd25lckNyZWF0ZUl0ZW0ocmVjb3JkLCBpbmRleCksXG4gICAgICAgICAgICBwb3NpdGlvbiA9IG1lLmdldEl0ZW1Qb3NpdGlvbihyZWNvcmQsIGluZGV4KSxcbiAgICAgICAgICAgIHN0eWxlICAgID0gaXRlbS5zdHlsZSB8fCB7fTtcblxuICAgICAgICBpZiAoIW1lLm93bmVyUmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQgICA6IGAke21lLml0ZW1IZWlnaHR9cHhgLFxuICAgICAgICAgICAgcG9zaXRpb24gOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7cG9zaXRpb24ueH1weCwgJHtwb3NpdGlvbi55fXB4KWAsXG4gICAgICAgICAgICB3aWR0aCAgICA6IGAke21lLml0ZW1XaWR0aH1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5zdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fVxuICAgICAqL1xuICAgIGdldEl0ZW1Qb3NpdGlvbihyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29sdW1uID0gaW5kZXggJSBtZS5jb2x1bW5zLFxuICAgICAgICAgICAgbWFyZ2luID0gbWUuaXRlbU1hcmdpbixcbiAgICAgICAgICAgIHJvdyAgICA9IE1hdGguZmxvb3IoaW5kZXggLyBtZS5jb2x1bW5zKSxcbiAgICAgICAgICAgIHggICAgICA9IGNvbHVtbiAqIChtYXJnaW4gKyBtZS5pdGVtV2lkdGgpICArIG1hcmdpbixcbiAgICAgICAgICAgIHkgICAgICA9IHJvdyAgICAqIChtYXJnaW4gKyBtZS5pdGVtSGVpZ2h0KSArIG1hcmdpbjtcblxuICAgICAgICByZXR1cm4ge3gsIHl9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG1hcFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW50ZXJjZXB0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRJdGVtSW5kZXgob2JqLCBtYXAsIGludGVyY2VwdCkge1xuICAgICAgICBpZiAoIWludGVyY2VwdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvd25lciA9IHRoaXMub3duZXIsXG4gICAgICAgICAgICBrZXkgICA9IG93bmVyLnN0b3JlLmtleVByb3BlcnR5O1xuXG4gICAgICAgIHJldHVybiBtYXAuaW5kZXhPZihvd25lci5nZXRJdGVtSWQob2JqLnJlY29yZFtrZXldKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk93bmVyTW91bnRlZCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5vd25lci5nZXREb21SZWN0KCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zICA6IE1hdGguZmxvb3IocmVjdC53aWR0aCAvIG1lLml0ZW1XaWR0aCksXG4gICAgICAgICAgICAgICAgb3duZXJSZWN0OiByZWN0LFxuICAgICAgICAgICAgICAgIHJvd3MgICAgIDogTWF0aC5mbG9vcihyZWN0LmhlaWdodCAvIG1lLml0ZW1IZWlnaHQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaXNGaWx0ZXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZEl0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIG9uU3RvcmVGaWx0ZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgID0gbWUub3duZXIsXG4gICAgICAgICAgICBrZXkgICAgICAgICAgICAgICAgID0gb3duZXIuc3RvcmUua2V5UHJvcGVydHksXG4gICAgICAgICAgICBoYXNBZGRlZEl0ZW1zICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBhZGRlZEl0ZW1zICAgICAgICAgID0gW10sXG4gICAgICAgICAgICBtb3ZlZEl0ZW1zICAgICAgICAgID0gW10sXG4gICAgICAgICAgICByZW1vdmVkSXRlbXMgICAgICAgID0gW10sXG4gICAgICAgICAgICB0cmFuc2l0aW9uVGltZW91dElkID0gbWUudHJhbnNpdGlvblRpbWVvdXRJZCxcbiAgICAgICAgICAgIGludGVyY2VwdCAgICAgICAgICAgPSAhIXRyYW5zaXRpb25UaW1lb3V0SWQsXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgICAgICAgID0gb3duZXIudmRvbSxcbiAgICAgICAgICAgIGluZGV4LCBpdGVtLCBtYXAsIHBvc2l0aW9uLCB2ZG9tSW5kZXg7XG5cbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmFuc2l0aW9uVGltZW91dElkKTtcbiAgICAgICAgICAgIG1lLnRyYW5zaXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwID0gaW50ZXJjZXB0ID8gdmRvbS5jbi5tYXAoZSA9PiBlLmlkKSA6IFtdO1xuXG4gICAgICAgIGRhdGEuaXRlbXMuZm9yRWFjaCgocmVjb3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaXRlbSA9IHtpbmRleCwgcmVjb3JkfTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhLm9sZEl0ZW1zLmluY2x1ZGVzKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBmbGFnIGl0ZW1zIHdoaWNoIGFyZSBzdGlsbCBpbnNpZGUgdGhlIERPTSAocnVubmluZyByZW1vdmUgT1ApXG4gICAgICAgICAgICAgICAgaWYgKGludGVyY2VwdCAmJiBtYXAuaW5jbHVkZXMob3duZXIuZ2V0SXRlbUlkKHJlY29yZFtrZXldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5yZUFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdmVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGF0YS5vbGRJdGVtcy5mb3JFYWNoKChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuaXRlbXMuaW5jbHVkZXMocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHtpbmRleCwgcmVjb3JkfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFkZGVkSXRlbXMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgaWYgKCFvYmoucmVBZGRlZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbWUuZ2V0SXRlbUluZGV4KG9iaiwgbWFwLCBpbnRlcmNlcHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQWRkZWRJdGVtcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbi5zcGxpY2UoaW5kZXgsIDAsIG1lLmNyZWF0ZUl0ZW0obWUsIG9iai5yZWNvcmQsIG9iai5pbmRleCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai5pdGVtID0gdmRvbS5jbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIG9iai5pdGVtLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0FkZGVkSXRlbXMpIHtcbiAgICAgICAgICAgIG93bmVyLnZkb20gPSB2ZG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRvIGdldCBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgdGhlIHZkb20sIHNpbmNlIHRoaXMgaXMgYSBkZWxheWVkIGNhbGxiYWNrXG4gICAgICAgICAgICB2ZG9tID0gb3duZXIudmRvbTtcblxuICAgICAgICAgICAgLy8gbmV3IGl0ZW1zIGFyZSBhbHJlYWR5IGFkZGVkIGludG8gdGhlIHZkb20sIHdoaWxlIG9sZCBpdGVtcyBhcmUgbm90IHlldCByZW1vdmVkXG4gICAgICAgICAgICAvLyA9PiB3ZSBuZWVkIGEgbWFwIHRvIGVuc3VyZSBnZXR0aW5nIHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICAgICAgICBtYXAgPSB2ZG9tLmNuLm1hcChlID0+IGUuaWQpO1xuXG4gICAgICAgICAgICBhZGRlZEl0ZW1zLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1lLmdldEl0ZW1JbmRleChvYmosIG1hcCwgaW50ZXJjZXB0KTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjaGFuZ2UgdGhlIG9wYWNpdHkgZm9yIHJlLWFkZGVkIGl0ZW1zIHRvbyA9PiB0aGUgdmRvbSBlbmdpbmUgd2lsbCBpZ25vcmUgdGhpc1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuW2luZGV4XS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbW92ZWRJdGVtcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBtZS5nZXRJdGVtSW5kZXgob2JqLCBtYXAsIHRydWUpOyAvLyBob25vciByZW1vdmVkIGl0ZW1zLCBldmVuIHdpdGhvdXQgaW50ZXJjZXB0aW9uc1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBtZS5nZXRJdGVtUG9zaXRpb24ob2JqLnJlY29yZCwgb2JqLmluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uY25baW5kZXhdLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ICA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtwb3NpdGlvbi54fXB4LCAke3Bvc2l0aW9uLnl9cHgpYFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1lLmdldEl0ZW1JbmRleChvYmosIG1hcCwgaW50ZXJjZXB0KTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5pdGVtID0gdmRvbS5jbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIG9iai5pdGVtLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvd25lci52ZG9tID0gdmRvbTtcblxuICAgICAgICAgICAgbWUudHJpZ2dlclRyYW5zaXRpb25DYWxsYmFjaygpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIG9uU3RvcmVTb3J0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSAgID0gZmFsc2UsXG4gICAgICAgICAgICBrZXlQcm9wZXJ0eSA9IGRhdGEuc2NvcGUua2V5UHJvcGVydHksXG4gICAgICAgICAgICBvd25lciAgICAgICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgbmV3VmRvbUNuICAgPSBbXSxcbiAgICAgICAgICAgIHZkb20gICAgICAgID0gb3duZXIudmRvbSxcbiAgICAgICAgICAgIHZkb21NYXAgICAgID0gdmRvbS5jbi5tYXAoZSA9PiBlLmlkKSxcbiAgICAgICAgICAgIGZyb21JbmRleCwgaXRlbUlkO1xuXG4gICAgICAgIGlmICh2ZG9tTWFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRhdGEuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtSWQgICAgPSBvd25lci5nZXRJdGVtSWQoaXRlbVtrZXlQcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IHZkb21NYXAuaW5kZXhPZihpdGVtSWQpO1xuXG4gICAgICAgICAgICAgICAgbmV3VmRvbUNuLnB1c2godmRvbS5jbltmcm9tSW5kZXhdKTtcblxuICAgICAgICAgICAgICAgIGlmIChmcm9tSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBvd25lci52ZG9tLmNuID0gbmV3VmRvbUNuO1xuXG4gICAgICAgICAgICAgICAgb3duZXIucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBlbnN1cmUgdG8gZ2V0IHRoaXMgY2FsbCBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdHJpZ2dlclRyYW5zaXRpb25DYWxsYmFjaygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dElkID0gbnVsbDtcblxuICAgICAgICAgICAgbWUub3duZXIuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgfSwgbWUudHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKEFuaW1hdGUpO1xuXG5leHBvcnQge0FuaW1hdGUgYXMgZGVmYXVsdH07XG4iLCJpbXBvcnQgQ29yZUJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5wbHVnaW4uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnBsdWdpbi5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm93bmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJNb3VudGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5vd25lci5vbignbW91bnRlZCcsIG1lLm9uT3duZXJNb3VudGVkLCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKEJhc2UpO1xuXG5leHBvcnQge0Jhc2UgYXMgZGVmYXVsdH07XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQ3NzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIENzcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5Dc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLkNzcydcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogUGFzcyB0aGUgc2VsZWN0b3JUZXh0IG9mIHRoZSBydWxlcyB3aGljaCB5b3Ugd2FudCB0byByZW1vdmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gcnVsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlUnVsZXMocnVsZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgcnVsZXMgPSBbcnVsZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldC5kZWxldGVDc3NSdWxlcyh7XG4gICAgICAgICAgICBydWxlczogcnVsZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IHJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGluc2VydFJ1bGVzKHJ1bGVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShydWxlcykpIHtcbiAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQuaW5zZXJ0Q3NzUnVsZXMoe1xuICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQ3NzKTtcblxuZXhwb3J0IGRlZmF1bHQgQ3NzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9