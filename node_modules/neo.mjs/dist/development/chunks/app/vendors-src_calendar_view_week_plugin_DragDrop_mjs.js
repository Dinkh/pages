(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_week_plugin_DragDrop_mjs"],{

/***/ "./src/calendar/view/week/EventDragZone.mjs":
/*!**************************************************!*\
  !*** ./src/calendar/view/week/EventDragZone.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventDragZone)
/* harmony export */ });
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../draggable/DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.calendar.view.week.EventDragZone
 * @extends Neo.draggable.DragZone
 */
class EventDragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.EventDragZone'
         * @protected
         */
        className: 'Neo.calendar.view.week.EventDragZone',
        /**
         * @member {Boolean} addDragProxyCls=false
         */
        addDragProxyCls: false,
        /**
         * @member {Boolean} enableResizingAcrossOppositeEdge=true
         */
        enableResizingAcrossOppositeEdge: true,
        /**
         * @member {Number} axisEndTime=0
         */
        axisEndTime: 0,
        /**
         * @member {Number} axisStartTime=0
         */
        axisStartTime: 0,
        /**
         * @member {Number} columnHeight=0
         */
        columnHeight: 0,
        /**
         * @member {Number} columnTop=0
         */
        columnTop: 0,
        /**
         * @member {Number} currentInterval=0
         */
        currentInterval: 0,
        /**
         * time in minutes
         * @member {Number} eventDuration=0
         */
        eventDuration: 0,
        /**
         * @member {Object} eventRecord=null
         */
        eventRecord: null,
        /**
         * Internal flag.
         * If we resize across the opposite edge and then back, we need to update the related edge position once.
         * @member {Boolean} forceUpdate=false
         * @protected
         */
        forceUpdate: false,
        /**
         * Internal flag
         * @member {Boolean} hasOverflow=false
         * @protected
         */
        hasOverflow: false,
        /**
         * time in minutes
         * @member {Number} intervalSize=15
         */
        intervalSize: 15,
        /**
         * @member {Boolean} keepEndDate=false
         */
        keepEndDate: false,
        /**
         * @member {Boolean} keepStartDate=false
         */
        keepStartDate: false,
        /**
         * @member {Boolean} moveHorizontal=false
         */
        moveHorizontal: false,
        /**
         * @member {Boolean} moveInMainThread=false
         */
        moveInMainThread: false,
        /**
         * Internal flag.
         * @member {Date} newEndDate=null
         * @protected
         */
        newEndDate: null,
        /**
         * Internal flag.
         * @member {Date} newStartDate=null
         * @protected
         */
        newStartDate: null,
        /**
         * @member {Number} scrollFactorLeft=3
         */
        scrollFactorLeft: 3,
        /**
         * @member {Boolean} useProxyWrapper=false
         */
        useProxyWrapper: false
    }}

    /**
     *
     */
    addBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {add: ['neo-cursor-move']}});
    }

    /**
     * Resolves the 24:00 issue, where an event would end on the next day
     * @param {Date} date
     * @returns {Date}
     */
    adjustEndDate(date) {
        if (date.getHours() === 0 && date.getMinutes() === 0) {
            // if an event ends at 24:00, change it to 23:59 => otherwise the day increases by 1
            date.setMinutes(date.getMinutes() - 1);
        } else if (!(date.getHours() === 23 && date.getMinutes() === 59) && date.getMinutes() % this.intervalSize !== 0) {
            // otherwise switch non interval based values back
            date.setMinutes(date.getMinutes() + 1);
        }

        return date;
    }

    /**
     * Triggered after the proxyParentId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetProxyParentId(value, oldValue) {
        if (value && oldValue !== undefined) {
            let me = this;

            // check if the node did not get removed yet
            if (me.dragProxy?.vdom.cn[0].id) {
                Neo.applyDeltas(me.appName, {
                    action  : 'moveNode',
                    id      : me.dragProxy.id,
                    index   : 0,
                    parentId: value
                });
            }
        }
    }

    /**
     *
     * @param {Object} data
     */
    createDragProxy(data) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            vdom      = me.dragProxyConfig?.vdom,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__.default.clone(vdom ? vdom : me.dragElement);

            clone.cn[2].removeDom = false;

        const config = {
            module          : _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.default,
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,

            ...me.dragProxyConfig,

            vdom: me.useProxyWrapper ? {cn: [clone]} : clone // we want to override dragProxyConfig.vdom if needed
        };

        config.cls = config.cls || [];

        config.cls.push('neo-focus');

        if (component) {
            config.cls.push(component.getTheme());
        }

        if (clone.cls && !me.useProxyWrapper) {
            config.cls.push(...clone.cls);
        }

        if (me.addDragProxyCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__.default.add(config.cls, me.dragProxyCls);
        }

        Object.assign(config.style, {
            height: `${data.height}px`,
            top   : `${data.y - me.columnTop}px`,
            width : `${data.width}px`
        });

        me.dragProxy = Neo.create(config);
    }

    /**
     * DragEnd equals drop, since we can only drag to valid positions
     * todo: ESC key
     * @param {Object} data
     */
    dragEnd(data) {
        super.dragEnd(data);

        let me     = this,
            owner  = me.owner,
            record = me.eventRecord,
            endDate, startDate;

        if (me.keepStartDate) {
            endDate   = me.newEndDate;
            startDate = me.newStartDate || record.startDate;
        } else {
            startDate = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__.default.findVdomChild(owner.vdom, me.proxyParentId).vdom.flag + 'T00:00:00');
            startDate.setHours(me.axisStartTime);
            startDate.setMinutes(me.currentInterval * me.intervalSize);

            if (me.keepEndDate) {
                endDate   = me.newEndDate   || record.endDate;
                startDate = me.newStartDate || startDate;
            } else {
                endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(startDate);
                endDate.setMinutes(endDate.getMinutes() + me.eventDuration);
            }
        }

        endDate = me.adjustEndDate(endDate);

        record.setSilent({
            endDate,
            startDate
        });

        Object.assign(me, {
            currentInterval: 0,
            hasOverflow    : false,
            keepEndDate    : false,
            keepStartDate  : false,
            newEndDate     : null,
            newStartDate   : null,
            proxyParentId  : null
        });

        // todo: updating a record field which is included inside a sorter should trigger collection.doSort()
        // see: https://github.com/neomjs/neo/issues/2392

        owner.getModel().getStore('events').doSort();
        owner.updateEvents();
    }

    /**
     *
     * @param {Object} data
     */
    dragMove(data) {
        let me              = this,
            axisEndTime     = me.axisEndTime,
            axisStartTime   = me.axisStartTime,
            columnHeight    = me.columnHeight,
            eventDuration   = me.eventDuration,
            i               = 0,
            intervalSize    = me.intervalSize,
            keepEndDate     = me.keepEndDate,
            keepStartDate   = me.keepStartDate,
            path            = data.targetPath,
            len             = path.length,
            owner           = me.owner,
            record          = me.eventRecord,
            switchDirection = false,
            timeAxis        = owner.timeAxis,
            axisStartDate, currentInterval, deltas, duration, endDate, eventIntervals, height, intervalHeight,
            intervals, limitInterval, minimumEventIntervals, position, startDate, startInterval;

        if (me.dragProxy) {
            if (!keepEndDate && !keepStartDate) {
                for (; i < len; i++) {
                    if (path[i].cls.includes('neo-c-w-column')) {
                        me.proxyParentId = path[i].id;
                        break;
                    }
                }
            }

            intervals      = (axisEndTime - axisStartTime) * 60 / intervalSize; // 15 minutes each
            intervalHeight = columnHeight / intervals;

            position = Math.min(columnHeight, data.clientY - me.offsetY - me.columnTop);

            currentInterval = Math.floor(position / intervalHeight);

            endDate   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(record.endDate);
            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(record.startDate);

            // events can have a smaller start time than the axis min value.
            // resizing via the north handle needs to adjust the duration to honor this.
            if (keepEndDate) {
                if (axisStartTime > startDate.getHours()) {
                    startDate.setHours(axisStartTime);
                    startDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000; // duration in minutes
                }
            }

            // events can have a bigger end time than the axis max value.
            // resizing via the south handle needs to adjust the duration to honor this.
            if (keepStartDate) {
                if (axisEndTime < endDate.getHours()) {
                    endDate.setHours(axisEndTime);
                    endDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000; // duration in minutes
                }
            }

            if (!keepEndDate) {
                // events must not end after the last visible interval
                currentInterval = Math.min(currentInterval, intervals - (eventDuration / intervalSize));
            }

            deltas = [{
                id   : me.dragProxy.id,
                style: {}
            }];

            if (keepEndDate || keepStartDate) {
                axisStartDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__.default.clone(record.startDate);
                axisStartDate.setHours(axisStartTime);
                axisStartDate.setMinutes(0);

                minimumEventIntervals = owner.minimumEventDuration / intervalSize;
                startInterval         = (record.startDate - axisStartDate) / intervalSize / 60 / 1000;

                if (keepEndDate) {
                    limitInterval = startInterval + (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        if (me.forceUpdate && currentInterval > limitInterval -minimumEventIntervals && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return;
                        } else if (currentInterval >= limitInterval + minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(currentInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(limitInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                            deltas[0].style.top = `calc(${limitInterval * intervalHeight / columnHeight * 100}% + 1px)`;
                        } else {
                            me.forceUpdate  = false;
                            me.newStartDate = null;
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.min(currentInterval, limitInterval - minimumEventIntervals);
                    }

                } else if (keepStartDate) {
                    limitInterval = startInterval - (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        // events must not start before the first visible interval
                        currentInterval = Math.max(-(eventDuration / intervalSize), currentInterval);

                        if (currentInterval <= limitInterval - minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(eventDuration + limitInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(eventDuration + currentInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours

                            position = (eventDuration / intervalSize + currentInterval) * intervalHeight; // snap to valid intervals
                            position = position / columnHeight * 100;

                            deltas[0].style.top = `calc(${position}% + 1px)`;
                        } else if (me.forceUpdate && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return;
                        } else if (me.forceUpdate && currentInterval >= limitInterval + minimumEventIntervals) {
                            if (me.currentInterval !== currentInterval) {
                                me.forceUpdate  = false;
                                me.newStartDate = null;
                                deltas[0].style.top = `calc(${startInterval * intervalHeight / columnHeight * 100}% + 1px)`;
                            }
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.max(currentInterval, limitInterval + minimumEventIntervals);
                    }
                }
            }

            if (!keepStartDate) {
                // events must not start before the first visible interval
                currentInterval = Math.max(0, currentInterval);
            }

            if (me.currentInterval !== currentInterval) {
                if (!switchDirection) {
                    if (!keepEndDate) {
                        endDate.setHours(axisStartTime);
                        endDate.setMinutes(eventDuration + currentInterval * intervalSize);
                    }

                    if (keepStartDate) {
                        me.newEndDate = endDate;
                        duration = (endDate - record.startDate) / 60 / 60 / 1000; // duration in hours
                    } else {
                        startDate.setHours(axisStartTime);
                        startDate.setMinutes(currentInterval * intervalSize);

                        position = currentInterval * intervalHeight; // snap to valid intervals
                        position = position / columnHeight * 100;

                        deltas[0].style.top = `calc(${position}% + 1px)`;
                    }

                    if (keepEndDate) {
                        duration = (record.endDate - startDate) / 60 / 60 / 1000; // duration in hours
                    }
                }

                endDate = me.adjustEndDate(endDate);

                deltas.push({
                    id       : me.dragProxy.vdom.cn[2].id,
                    innerHTML: owner.intlFormat_time.format(endDate)
                });

                if (keepEndDate || keepStartDate) {
                    height = Math.round(duration / (axisEndTime - axisStartTime) * 100 * 1000) / 1000;
                    deltas[0].style.height = `calc(${height}% - 2px)`;
                }

                deltas.push({
                    id       : me.dragProxy.vdom.cn[0].id,
                    innerHTML: owner.intlFormat_time.format(startDate)
                });

                // check if the node got added yet
                if (me.dragProxy.vdom.cn[0].id) {
                    eventIntervals = (duration && duration * 60 || eventDuration) / timeAxis.interval;

                    if (eventIntervals <= 2) {
                        if (timeAxis.rowHeight / eventIntervals < 25 && !me.hasOverflow) {
                            deltas.push({
                                id : me.dragProxy.id,
                                cls: {add: ['neo-overflow']}
                            });

                            me.hasOverflow = true;
                        }
                    } else if (me.hasOverflow) {
                        deltas.push({
                            id : me.dragProxy.id,
                            cls: {remove: ['neo-overflow']}
                        });

                        me.hasOverflow = false;
                    }

                    Neo.applyDeltas(me.appName, deltas);
                }
            }

            me.currentInterval = currentInterval;
        }
    }

    /**
     *
     * @param {Object} data
     */
    dragStart(data) {
        let me = this,
            eventDuration, offsetX, offsetY;

        Neo.main.DomAccess.getBoundingClientRect({
            id: [me.getDragElementRoot().id, data.path[1].id]
        }).then(rects => {
            eventDuration = (me.eventRecord.endDate - me.eventRecord.startDate) / 60 / 1000;
            offsetX       = data.clientX - rects[0].left;
            offsetY       = data.clientY - rects[0].top;

            Object.assign(me, {
                columnHeight   : rects[1].height,
                columnTop      : rects[1].top,
                dragElementRect: rects[0],
                eventDuration  : Math.round(eventDuration / me.intervalSize) * me.intervalSize,
                offsetX,
                offsetY
            });

            me.createDragProxy(rects[0]);

            me.fire('dragStart', {
                dragElementRect: rects[0],
                id             : me.id,
                offsetX,
                offsetY
            });

            me.dragMove(data);
        });
    }

    /**
     *
     */
    removeBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {remove: ['neo-cursor-move']}});
    }
}

Neo.applyClassConfig(EventDragZone);




/***/ }),

/***/ "./src/calendar/view/week/plugin/DragDrop.mjs":
/*!****************************************************!*\
  !*** ./src/calendar/view/week/plugin/DragDrop.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragDrop)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EventDragZone.mjs */ "./src/calendar/view/week/EventDragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @class Neo.calendar.view.week.plugin.DragDrop
 * @extends Neo.plugin.Base
 */
class DragDrop extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.calendar.view.week.plugin.DragDrop'
         * @protected
         */
        className: 'Neo.calendar.view.week.plugin.DragDrop',
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me           = this,
            columnOpts   = {scope: me, delegate: '.neo-c-w-column'},
            eventOpts    = {scope: me, delegate: '.neo-event'},
            owner        = me.owner,
            domListeners = owner.domListeners;

        domListeners.push(
            {'drag:end'  : me.onColumnDragEnd,   ...columnOpts},
            {'drag:end'  : me.onEventDragEnd,    ...eventOpts},
            {'drag:move' : me.onColumnDragMove,  ...columnOpts},
            {'drag:move' : me.onEventDragMove,   ...eventOpts},
            {'drag:start': me.onColumnDragStart, ...columnOpts},
            {'drag:start': me.onEventDragStart,  ...eventOpts}
        );

        owner.domListeners = domListeners;
    }

    /**
     * Adjusts drag events which start on an event resize handle
     * @param {Object} data
     * @returns {Object}
     */
    adjustResizeEvent(data) {
        data.path.shift();
        data.targetPath.shift();
        data.target = data.path[0];

        return data;
    }

    /**
     *
     * @param {Object} opts
     * @param {Object} opts.dragElement
     * @param {Boolean} opts.enableResizingAcrossOppositeEdge
     * @param {Object} opts.eventRecord
     * @param {String} opts.proxyParentId
     * @returns {Neo.calendar.view.week.EventDragZone}
     */
    getEventDragZone(opts) {
        let me            = this,
            owner         = me.owner,
            eventDragZone = owner.eventDragZone,
            timeAxis      = owner.timeAxis,

            config = {
                axisEndTime                     : timeAxis.getTime(owner.endTime),
                axisStartTime                   : timeAxis.getTime(owner.startTime),
                dragElement                     : opts.dragElement,
                enableResizingAcrossOppositeEdge: opts.enableResizingAcrossOppositeEdge,
                eventRecord                     : opts.eventRecord,
                proxyParentId                   : opts.proxyParentId
            };

        if (!eventDragZone) {
            owner.eventDragZone = eventDragZone = Neo.create({
                module           : _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__.default,
                appName          : me.appName,
                owner            : owner,
                scrollContainerId: owner.getScrollContainer().id,
                ...config,

                dragProxyConfig: {
                    style: {
                        transition: 'none',
                        willChange: 'height'
                    }
                }
            });
        } else {
            eventDragZone.set(config);
        }

        return eventDragZone;
    }

    /**
     *
     * @param {Object} path
     * @returns {Boolean}
     */
    isTopLevelColumn(path) {
        return path[0].cls.includes('neo-c-w-column');
    }

    /**
     *
     * @param {Object} eventData
     * @returns {Boolean}
     */
    isTopLevelEvent(eventData) {
        return eventData.path[0].cls.includes('neo-event');
    }

    /**
     *
     * @param {Object} data
     */
    onColumnDragEnd(data) {
        let me           = this,
            owner        = me.owner,
            recordSymbol = Symbol.for('addedRecord'),
            record       = me[recordSymbol];

        if (record && me.isTopLevelColumn(data.path)) {
            me.isDragging = false;

            delete me[recordSymbol];

            Neo.applyDeltas(me.appName, {
                id   : owner.getEventId(record.id),
                style: {opacity: 1}
            }).then(() => {
                owner.eventDragZone.dragEnd();
                owner.getPlugin({flag:'resizable'}).onDragEnd(data);
            });
        }
    }

    /**
     *
     * @param {Object} data
     */
    onColumnDragMove(data) {
        if (this.isTopLevelColumn(data.path)) {
            this.owner.eventDragZone?.dragMove(data);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onColumnDragStart(data) {
        let me = this;

        if (me.isTopLevelColumn(data.targetPath)) {
            let owner           = me.owner,
                axisStartTime   = owner.timeAxis.getTime(owner.startTime),
                calendarStore   = owner.calendarStore,
                columnRect      = data.path[0].rect,
                intervalSize    = 15,
                intervals       = (owner.timeAxis.getTime(owner.endTime) - axisStartTime) * 60 / intervalSize,
                intervalHeight  = columnRect.height / intervals,
                position        = Math.min(columnRect.height, data.clientY - columnRect.top),
                currentInterval = Math.floor(position / intervalHeight),
                startDate       = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__.default.findVdomChild(owner.vdom, data.path[0].id).vdom.flag + 'T00:00:00'),
                dragElement, endDate, eventDragZone, eventId, record;

            me.isDragging = true;

            startDate.setHours(axisStartTime);
            startDate.setMinutes(Math.min(currentInterval * intervalSize, intervals * intervalSize - owner.minimumEventDuration));

            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__.default.clone(startDate);

            endDate.setMinutes(endDate.getMinutes() + owner.minimumEventDuration);

            // 24:00 fix
            endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.setMinutes(endDate.getMinutes() - 1);

            record = owner.eventStore.add({
                calendarId: owner.data.activeCalendarId || calendarStore.getAt(0)[calendarStore.keyProperty],
                endDate,
                startDate,
                title     : 'New Event'
            })[0];

            // we need to cache a reference to make the record accessible for onColumnDragEnd()
            me[Symbol.for('addedRecord')] = record;

            // wait until the new event got mounted
            setTimeout(() => {
                eventId     = owner.getEventId(record.id);
                dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__.default.findVdomChild(owner.vdom, eventId).vdom;

                eventDragZone = me.getEventDragZone({
                    dragElement,
                    enableResizingAcrossOppositeEdge: true,
                    eventRecord                     : record,
                    proxyParentId                   : data.path[0].id
                });

                owner.getPlugin({flag:'resizable'}).onDragStart(data);
                eventDragZone.dragStart(data);

                setTimeout(() => {
                    me.isDragging && Neo.applyDeltas(me.appName, {
                        id   : eventId,
                        style: {opacity: 0}
                    });
                }, 50);
            }, 50);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onEventDragEnd(data) {
        let me    = this,
            owner = me.owner;

        if (owner.enableDrag) {
            owner.eventDragZone.dragEnd();

            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data);
                owner.getPlugin({flag:'resizable'}).onDragEnd(data);
            } else {
                owner.eventDragZone.removeBodyCursorCls();
            }

            me.isDragging = false;
        }
    }

    /**
     *
     * @param {Object} data
     */
    onEventDragMove(data) {
        let me    = this,
            owner = me.owner;

        if (owner.enableDrag) {
            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data);
            }

            owner.eventDragZone.dragMove(data);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onEventDragStart(data) {
        let me        = this,
            owner     = me.owner,
            modelData = owner.data;

        if (owner.enableDrag) {
            let isTopLevelEvent = me.isTopLevelEvent(data),
                dragElement, eventDragZone;

            if (!isTopLevelEvent) {
                data = me.adjustResizeEvent(data);
            }

            me.isDragging = true;

            dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__.default.findVdomChild(owner.vdom, data.path[0].id).vdom;

            eventDragZone = me.getEventDragZone({
                dragElement,
                enableResizingAcrossOppositeEdge: modelData.events.enableResizingAcrossOppositeEdge,
                eventRecord                     : owner.eventStore.get(dragElement.flag),
                proxyParentId                   : data.path[1].id
            });

            if (isTopLevelEvent) {
                eventDragZone.addBodyCursorCls();
            } else {
                owner.getPlugin({flag:'resizable'}).onDragStart(data);
            }

            eventDragZone.dragStart(data);
        }
    }
}

Neo.applyClassConfig(DragDrop);




/***/ }),

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me = this;

        me.owner.on('mounted', me.onOwnerMounted, me);
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

Neo.applyClassConfig(Base);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9FdmVudERyYWdab25lLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9wbHVnaW4vRHJhZ0Ryb3AubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNtQjtBQUNWO0FBQ1I7QUFDRDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQVE7QUFDcEMsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFv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Q0E7QUFDQSxhQUFhO0FBQ2IsaUNBQWlDLGlCQUFpQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFNkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDblRXOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVE7QUFDM0Isd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUV5QiIsImZpbGUiOiJjaHVua3MvYXBwL3ZlbmRvcnMtc3JjX2NhbGVuZGFyX3ZpZXdfd2Vla19wbHVnaW5fRHJhZ0Ryb3BfbWpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERhdGVVdGlsICAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vZHJhZ2dhYmxlL0RyYWdQcm94eUNvbXBvbmVudC5tanMnO1xuaW1wb3J0IERyYWdab25lICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9kcmFnZ2FibGUvRHJhZ1pvbmUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLkRyYWdab25lXG4gKi9cbmNsYXNzIEV2ZW50RHJhZ1pvbmUgZXh0ZW5kcyBEcmFnWm9uZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsuRXZlbnREcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFkZERyYWdQcm94eUNscz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRHJhZ1Byb3h5Q2xzOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBheGlzRW5kVGltZT0wXG4gICAgICAgICAqL1xuICAgICAgICBheGlzRW5kVGltZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXhpc1N0YXJ0VGltZT0wXG4gICAgICAgICAqL1xuICAgICAgICBheGlzU3RhcnRUaW1lOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb2x1bW5IZWlnaHQ9MFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uSGVpZ2h0OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb2x1bW5Ub3A9MFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uVG9wOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjdXJyZW50SW50ZXJ2YWw9MFxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudEludGVydmFsOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogdGltZSBpbiBtaW51dGVzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZXZlbnREdXJhdGlvbj0wXG4gICAgICAgICAqL1xuICAgICAgICBldmVudER1cmF0aW9uOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBldmVudFJlY29yZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFJlY29yZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuXG4gICAgICAgICAqIElmIHdlIHJlc2l6ZSBhY3Jvc3MgdGhlIG9wcG9zaXRlIGVkZ2UgYW5kIHRoZW4gYmFjaywgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJlbGF0ZWQgZWRnZSBwb3NpdGlvbiBvbmNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmb3JjZVVwZGF0ZT1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmb3JjZVVwZGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc092ZXJmbG93PWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGhhc092ZXJmbG93OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpbWUgaW4gbWludXRlc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGludGVydmFsU2l6ZT0xNVxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJ2YWxTaXplOiAxNSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGtlZXBFbmREYXRlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZWVwRW5kRGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBrZWVwU3RhcnREYXRlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZWVwU3RhcnREYXRlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVIb3Jpem9udGFsPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV9IG5ld0VuZERhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBuZXdFbmREYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZX0gbmV3U3RhcnREYXRlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmV3U3RhcnREYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxGYWN0b3JMZWZ0PTNcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEZhY3RvckxlZnQ6IDMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VQcm94eVdyYXBwZXI9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHVzZVByb3h5V3JhcHBlcjogZmFsc2VcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRCb2R5Q3Vyc29yQ2xzKCkge1xuICAgICAgICBOZW8uYXBwbHlEZWx0YXModGhpcy5hcHBOYW1lLCB7aWQ6ICdkb2N1bWVudC5ib2R5JywgY2xzOiB7YWRkOiBbJ25lby1jdXJzb3ItbW92ZSddfX0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSAyNDowMCBpc3N1ZSwgd2hlcmUgYW4gZXZlbnQgd291bGQgZW5kIG9uIHRoZSBuZXh0IGRheVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqL1xuICAgIGFkanVzdEVuZERhdGUoZGF0ZSkge1xuICAgICAgICBpZiAoZGF0ZS5nZXRIb3VycygpID09PSAwICYmIGRhdGUuZ2V0TWludXRlcygpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiBhbiBldmVudCBlbmRzIGF0IDI0OjAwLCBjaGFuZ2UgaXQgdG8gMjM6NTkgPT4gb3RoZXJ3aXNlIHRoZSBkYXkgaW5jcmVhc2VzIGJ5IDFcbiAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0ZS5nZXRIb3VycygpID09PSAyMyAmJiBkYXRlLmdldE1pbnV0ZXMoKSA9PT0gNTkpICYmIGRhdGUuZ2V0TWludXRlcygpICUgdGhpcy5pbnRlcnZhbFNpemUgIT09IDApIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzd2l0Y2ggbm9uIGludGVydmFsIGJhc2VkIHZhbHVlcyBiYWNrXG4gICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcHJveHlQYXJlbnRJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQcm94eVBhcmVudElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5vZGUgZGlkIG5vdCBnZXQgcmVtb3ZlZCB5ZXRcbiAgICAgICAgICAgIGlmIChtZS5kcmFnUHJveHk/LnZkb20uY25bMF0uaWQpIHtcbiAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ21vdmVOb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmRyYWdQcm94eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggICA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNyZWF0ZURyYWdQcm94eShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChtZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZCkgfHwgbWUub3duZXIsXG4gICAgICAgICAgICB2ZG9tICAgICAgPSBtZS5kcmFnUHJveHlDb25maWc/LnZkb20sXG4gICAgICAgICAgICBjbG9uZSAgICAgPSBWRG9tVXRpbC5jbG9uZSh2ZG9tID8gdmRvbSA6IG1lLmRyYWdFbGVtZW50KTtcblxuICAgICAgICAgICAgY2xvbmUuY25bMl0ucmVtb3ZlRG9tID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgIDogRHJhZ1Byb3h5Q29tcG9uZW50LFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IG1lLm1vdmVJbk1haW5UaHJlYWQsXG4gICAgICAgICAgICBwYXJlbnRJZCAgICAgICAgOiBtZS5wcm94eVBhcmVudElkLFxuXG4gICAgICAgICAgICAuLi5tZS5kcmFnUHJveHlDb25maWcsXG5cbiAgICAgICAgICAgIHZkb206IG1lLnVzZVByb3h5V3JhcHBlciA/IHtjbjogW2Nsb25lXX0gOiBjbG9uZSAvLyB3ZSB3YW50IHRvIG92ZXJyaWRlIGRyYWdQcm94eUNvbmZpZy52ZG9tIGlmIG5lZWRlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbmZpZy5jbHMgPSBjb25maWcuY2xzIHx8IFtdO1xuXG4gICAgICAgIGNvbmZpZy5jbHMucHVzaCgnbmVvLWZvY3VzJyk7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKGNvbXBvbmVudC5nZXRUaGVtZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9uZS5jbHMgJiYgIW1lLnVzZVByb3h5V3JhcHBlcikge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKC4uLmNsb25lLmNscyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuYWRkRHJhZ1Byb3h5Q2xzKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY29uZmlnLmNscywgbWUuZHJhZ1Byb3h5Q2xzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLnN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIHRvcCAgIDogYCR7ZGF0YS55IC0gbWUuY29sdW1uVG9wfXB4YCxcbiAgICAgICAgICAgIHdpZHRoIDogYCR7ZGF0YS53aWR0aH1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZHJhZ1Byb3h5ID0gTmVvLmNyZWF0ZShjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYWdFbmQgZXF1YWxzIGRyb3AsIHNpbmNlIHdlIGNhbiBvbmx5IGRyYWcgdG8gdmFsaWQgcG9zaXRpb25zXG4gICAgICogdG9kbzogRVNDIGtleVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmRyYWdFbmQoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmV2ZW50UmVjb3JkLFxuICAgICAgICAgICAgZW5kRGF0ZSwgc3RhcnREYXRlO1xuXG4gICAgICAgIGlmIChtZS5rZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICBlbmREYXRlICAgPSBtZS5uZXdFbmREYXRlO1xuICAgICAgICAgICAgc3RhcnREYXRlID0gbWUubmV3U3RhcnREYXRlIHx8IHJlY29yZC5zdGFydERhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydERhdGUgPSBuZXcgRGF0ZShWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG93bmVyLnZkb20sIG1lLnByb3h5UGFyZW50SWQpLnZkb20uZmxhZyArICdUMDA6MDA6MDAnKTtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhtZS5heGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKG1lLmN1cnJlbnRJbnRlcnZhbCAqIG1lLmludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5rZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGVuZERhdGUgICA9IG1lLm5ld0VuZERhdGUgICB8fCByZWNvcmQuZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUgPSBtZS5uZXdTdGFydERhdGUgfHwgc3RhcnREYXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmREYXRlID0gRGF0ZVV0aWwuY2xvbmUoc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZW5kRGF0ZS5nZXRNaW51dGVzKCkgKyBtZS5ldmVudER1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVuZERhdGUgPSBtZS5hZGp1c3RFbmREYXRlKGVuZERhdGUpO1xuXG4gICAgICAgIHJlY29yZC5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgZW5kRGF0ZSxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWw6IDAsXG4gICAgICAgICAgICBoYXNPdmVyZmxvdyAgICA6IGZhbHNlLFxuICAgICAgICAgICAga2VlcEVuZERhdGUgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBTdGFydERhdGUgIDogZmFsc2UsXG4gICAgICAgICAgICBuZXdFbmREYXRlICAgICA6IG51bGwsXG4gICAgICAgICAgICBuZXdTdGFydERhdGUgICA6IG51bGwsXG4gICAgICAgICAgICBwcm94eVBhcmVudElkICA6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdG9kbzogdXBkYXRpbmcgYSByZWNvcmQgZmllbGQgd2hpY2ggaXMgaW5jbHVkZWQgaW5zaWRlIGEgc29ydGVyIHNob3VsZCB0cmlnZ2VyIGNvbGxlY3Rpb24uZG9Tb3J0KClcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjM5MlxuXG4gICAgICAgIG93bmVyLmdldE1vZGVsKCkuZ2V0U3RvcmUoJ2V2ZW50cycpLmRvU29ydCgpO1xuICAgICAgICBvd25lci51cGRhdGVFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGF4aXNFbmRUaW1lICAgICA9IG1lLmF4aXNFbmRUaW1lLFxuICAgICAgICAgICAgYXhpc1N0YXJ0VGltZSAgID0gbWUuYXhpc1N0YXJ0VGltZSxcbiAgICAgICAgICAgIGNvbHVtbkhlaWdodCAgICA9IG1lLmNvbHVtbkhlaWdodCxcbiAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gICA9IG1lLmV2ZW50RHVyYXRpb24sXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgaW50ZXJ2YWxTaXplICAgID0gbWUuaW50ZXJ2YWxTaXplLFxuICAgICAgICAgICAga2VlcEVuZERhdGUgICAgID0gbWUua2VlcEVuZERhdGUsXG4gICAgICAgICAgICBrZWVwU3RhcnREYXRlICAgPSBtZS5rZWVwU3RhcnREYXRlLFxuICAgICAgICAgICAgcGF0aCAgICAgICAgICAgID0gZGF0YS50YXJnZXRQYXRoLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICAgID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBvd25lciAgICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIHJlY29yZCAgICAgICAgICA9IG1lLmV2ZW50UmVjb3JkLFxuICAgICAgICAgICAgc3dpdGNoRGlyZWN0aW9uID0gZmFsc2UsXG4gICAgICAgICAgICB0aW1lQXhpcyAgICAgICAgPSBvd25lci50aW1lQXhpcyxcbiAgICAgICAgICAgIGF4aXNTdGFydERhdGUsIGN1cnJlbnRJbnRlcnZhbCwgZGVsdGFzLCBkdXJhdGlvbiwgZW5kRGF0ZSwgZXZlbnRJbnRlcnZhbHMsIGhlaWdodCwgaW50ZXJ2YWxIZWlnaHQsXG4gICAgICAgICAgICBpbnRlcnZhbHMsIGxpbWl0SW50ZXJ2YWwsIG1pbmltdW1FdmVudEludGVydmFscywgcG9zaXRpb24sIHN0YXJ0RGF0ZSwgc3RhcnRJbnRlcnZhbDtcblxuICAgICAgICBpZiAobWUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBFbmREYXRlICYmICFrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aFtpXS5jbHMuaW5jbHVkZXMoJ25lby1jLXctY29sdW1uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnByb3h5UGFyZW50SWQgPSBwYXRoW2ldLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludGVydmFscyAgICAgID0gKGF4aXNFbmRUaW1lIC0gYXhpc1N0YXJ0VGltZSkgKiA2MCAvIGludGVydmFsU2l6ZTsgLy8gMTUgbWludXRlcyBlYWNoXG4gICAgICAgICAgICBpbnRlcnZhbEhlaWdodCA9IGNvbHVtbkhlaWdodCAvIGludGVydmFscztcblxuICAgICAgICAgICAgcG9zaXRpb24gPSBNYXRoLm1pbihjb2x1bW5IZWlnaHQsIGRhdGEuY2xpZW50WSAtIG1lLm9mZnNldFkgLSBtZS5jb2x1bW5Ub3ApO1xuXG4gICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gaW50ZXJ2YWxIZWlnaHQpO1xuXG4gICAgICAgICAgICBlbmREYXRlICAgPSBEYXRlVXRpbC5jbG9uZShyZWNvcmQuZW5kRGF0ZSk7XG4gICAgICAgICAgICBzdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShyZWNvcmQuc3RhcnREYXRlKTtcblxuICAgICAgICAgICAgLy8gZXZlbnRzIGNhbiBoYXZlIGEgc21hbGxlciBzdGFydCB0aW1lIHRoYW4gdGhlIGF4aXMgbWluIHZhbHVlLlxuICAgICAgICAgICAgLy8gcmVzaXppbmcgdmlhIHRoZSBub3J0aCBoYW5kbGUgbmVlZHMgdG8gYWRqdXN0IHRoZSBkdXJhdGlvbiB0byBob25vciB0aGlzLlxuICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNTdGFydFRpbWUgPiBzdGFydERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDEwMDA7IC8vIGR1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV2ZW50cyBjYW4gaGF2ZSBhIGJpZ2dlciBlbmQgdGltZSB0aGFuIHRoZSBheGlzIG1heCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIHZpYSB0aGUgc291dGggaGFuZGxlIG5lZWRzIHRvIGFkanVzdCB0aGUgZHVyYXRpb24gdG8gaG9ub3IgdGhpcy5cbiAgICAgICAgICAgIGlmIChrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNFbmRUaW1lIDwgZW5kRGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoYXhpc0VuZFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnREdXJhdGlvbiA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gbWludXRlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBtdXN0IG5vdCBlbmQgYWZ0ZXIgdGhlIGxhc3QgdmlzaWJsZSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWluKGN1cnJlbnRJbnRlcnZhbCwgaW50ZXJ2YWxzIC0gKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsdGFzID0gW3tcbiAgICAgICAgICAgICAgICBpZCAgIDogbWUuZHJhZ1Byb3h5LmlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7fVxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSB8fCBrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0RGF0ZSA9IERhdGVVdGlsLmNsb25lKHJlY29yZC5zdGFydERhdGUpO1xuICAgICAgICAgICAgICAgIGF4aXNTdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0RGF0ZS5zZXRNaW51dGVzKDApO1xuXG4gICAgICAgICAgICAgICAgbWluaW11bUV2ZW50SW50ZXJ2YWxzID0gb3duZXIubWluaW11bUV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemU7XG4gICAgICAgICAgICAgICAgc3RhcnRJbnRlcnZhbCAgICAgICAgID0gKHJlY29yZC5zdGFydERhdGUgLSBheGlzU3RhcnREYXRlKSAvIGludGVydmFsU2l6ZSAvIDYwIC8gMTAwMDtcblxuICAgICAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW1pdEludGVydmFsID0gc3RhcnRJbnRlcnZhbCArIChldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZS5mb3JjZVVwZGF0ZSAmJiBjdXJyZW50SW50ZXJ2YWwgPiBsaW1pdEludGVydmFsIC1taW5pbXVtRXZlbnRJbnRlcnZhbHMgJiYgY3VycmVudEludGVydmFsIDwgbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzaXplIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGRpcmVjdGlvbiwga2VlcCB0aGUgbWluIGludGVydmFsIHVudGlsIHdlIHNuYXAgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEludGVydmFsID49IGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2hEaXJlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZvcmNlVXBkYXRlICA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcyhjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUgPSBtZS5hZGp1c3RFbmREYXRlKGVuZERhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3RW5kRGF0ZSA9IGVuZERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMobGltaXRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdTdGFydERhdGUgPSBzdGFydERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS50b3AgPSBgY2FsYygke2xpbWl0SW50ZXJ2YWwgKiBpbnRlcnZhbEhlaWdodCAvIGNvbHVtbkhlaWdodCAqIDEwMH0lICsgMXB4KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZvcmNlVXBkYXRlICA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld1N0YXJ0RGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5taW4oY3VycmVudEludGVydmFsLCBsaW1pdEludGVydmFsIC0gbWluaW11bUV2ZW50SW50ZXJ2YWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW50ZXJ2YWwgPSBzdGFydEludGVydmFsIC0gKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnRzIG11c3Qgbm90IHN0YXJ0IGJlZm9yZSB0aGUgZmlyc3QgdmlzaWJsZSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5tYXgoLShldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKSwgY3VycmVudEludGVydmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnRlcnZhbCA8PSBsaW1pdEludGVydmFsIC0gbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoRGlyZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZXZlbnREdXJhdGlvbiArIGxpbWl0SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUgPSBtZS5hZGp1c3RFbmREYXRlKGVuZERhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3RW5kRGF0ZSA9IGVuZERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMoZXZlbnREdXJhdGlvbiArIGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdTdGFydERhdGUgPSBzdGFydERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSArIGN1cnJlbnRJbnRlcnZhbCkgKiBpbnRlcnZhbEhlaWdodDsgLy8gc25hcCB0byB2YWxpZCBpbnRlcnZhbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIC8gY29sdW1uSGVpZ2h0ICogMTAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLnRvcCA9IGBjYWxjKCR7cG9zaXRpb259JSArIDFweClgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5mb3JjZVVwZGF0ZSAmJiBjdXJyZW50SW50ZXJ2YWwgPCBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSByZXNpemUgYmFjayB0byB0aGUgb3JpZ2luYWwgZGlyZWN0aW9uLCBrZWVwIHRoZSBtaW4gaW50ZXJ2YWwgdW50aWwgd2Ugc25hcCBiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5mb3JjZVVwZGF0ZSAmJiBjdXJyZW50SW50ZXJ2YWwgPj0gbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZS5jdXJyZW50SW50ZXJ2YWwgIT09IGN1cnJlbnRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3U3RhcnREYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLnRvcCA9IGBjYWxjKCR7c3RhcnRJbnRlcnZhbCAqIGludGVydmFsSGVpZ2h0IC8gY29sdW1uSGVpZ2h0ICogMTAwfSUgKyAxcHgpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5tYXgoY3VycmVudEludGVydmFsLCBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzIG11c3Qgbm90IHN0YXJ0IGJlZm9yZSB0aGUgZmlyc3QgdmlzaWJsZSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWF4KDAsIGN1cnJlbnRJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZS5jdXJyZW50SW50ZXJ2YWwgIT09IGN1cnJlbnRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGlmICghc3dpdGNoRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZXZlbnREdXJhdGlvbiArIGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3RW5kRGF0ZSA9IGVuZERhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IChlbmREYXRlIC0gcmVjb3JkLnN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gY3VycmVudEludGVydmFsICogaW50ZXJ2YWxIZWlnaHQ7IC8vIHNuYXAgdG8gdmFsaWQgaW50ZXJ2YWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIC8gY29sdW1uSGVpZ2h0ICogMTAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUudG9wID0gYGNhbGMoJHtwb3NpdGlvbn0lICsgMXB4KWA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKHJlY29yZC5lbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwOyAvLyBkdXJhdGlvbiBpbiBob3Vyc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZW5kRGF0ZSA9IG1lLmFkanVzdEVuZERhdGUoZW5kRGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUuZHJhZ1Byb3h5LnZkb20uY25bMl0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogb3duZXIuaW50bEZvcm1hdF90aW1lLmZvcm1hdChlbmREYXRlKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlIHx8IGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIChheGlzRW5kVGltZSAtIGF4aXNTdGFydFRpbWUpICogMTAwICogMTAwMCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUuaGVpZ2h0ID0gYGNhbGMoJHtoZWlnaHR9JSAtIDJweClgO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5kcmFnUHJveHkudmRvbS5jblswXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBvd25lci5pbnRsRm9ybWF0X3RpbWUuZm9ybWF0KHN0YXJ0RGF0ZSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBub2RlIGdvdCBhZGRlZCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAobWUuZHJhZ1Byb3h5LnZkb20uY25bMF0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnRlcnZhbHMgPSAoZHVyYXRpb24gJiYgZHVyYXRpb24gKiA2MCB8fCBldmVudER1cmF0aW9uKSAvIHRpbWVBeGlzLmludGVydmFsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEludGVydmFscyA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZUF4aXMucm93SGVpZ2h0IC8gZXZlbnRJbnRlcnZhbHMgPCAyNSAmJiAhbWUuaGFzT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIDogbWUuZHJhZ1Byb3h5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IHthZGQ6IFsnbmVvLW92ZXJmbG93J119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5oYXNPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuaGFzT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA6IG1lLmRyYWdQcm94eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IHtyZW1vdmU6IFsnbmVvLW92ZXJmbG93J119XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuaGFzT3ZlcmZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCBkZWx0YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuY3VycmVudEludGVydmFsID0gY3VycmVudEludGVydmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBldmVudER1cmF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5nZXRCb3VuZGluZ0NsaWVudFJlY3Qoe1xuICAgICAgICAgICAgaWQ6IFttZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZCwgZGF0YS5wYXRoWzFdLmlkXVxuICAgICAgICB9KS50aGVuKHJlY3RzID0+IHtcbiAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gPSAobWUuZXZlbnRSZWNvcmQuZW5kRGF0ZSAtIG1lLmV2ZW50UmVjb3JkLnN0YXJ0RGF0ZSkgLyA2MCAvIDEwMDA7XG4gICAgICAgICAgICBvZmZzZXRYICAgICAgID0gZGF0YS5jbGllbnRYIC0gcmVjdHNbMF0ubGVmdDtcbiAgICAgICAgICAgIG9mZnNldFkgICAgICAgPSBkYXRhLmNsaWVudFkgLSByZWN0c1swXS50b3A7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5IZWlnaHQgICA6IHJlY3RzWzFdLmhlaWdodCxcbiAgICAgICAgICAgICAgICBjb2x1bW5Ub3AgICAgICA6IHJlY3RzWzFdLnRvcCxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3RzWzBdLFxuICAgICAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gIDogTWF0aC5yb3VuZChldmVudER1cmF0aW9uIC8gbWUuaW50ZXJ2YWxTaXplKSAqIG1lLmludGVydmFsU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jcmVhdGVEcmFnUHJveHkocmVjdHNbMF0pO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdkcmFnU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnRSZWN0OiByZWN0c1swXSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmRyYWdNb3ZlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUJvZHlDdXJzb3JDbHMoKSB7XG4gICAgICAgIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtpZDogJ2RvY3VtZW50LmJvZHknLCBjbHM6IHtyZW1vdmU6IFsnbmVvLWN1cnNvci1tb3ZlJ119fSk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhFdmVudERyYWdab25lKTtcblxuZXhwb3J0IHtFdmVudERyYWdab25lIGFzIGRlZmF1bHR9O1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vcGx1Z2luL0Jhc2UubWpzJztcbmltcG9ydCBEYXRlVXRpbCAgICAgIGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvRGF0ZS5tanMnO1xuaW1wb3J0IEV2ZW50RHJhZ1pvbmUgZnJvbSAnLi4vRXZlbnREcmFnWm9uZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LndlZWsucGx1Z2luLkRyYWdEcm9wXG4gKiBAZXh0ZW5kcyBOZW8ucGx1Z2luLkJhc2VcbiAqL1xuY2xhc3MgRHJhZ0Ryb3AgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5wbHVnaW4uRHJhZ0Ryb3AnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LndlZWsucGx1Z2luLkRyYWdEcm9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzRHJhZ2dpbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb2x1bW5PcHRzICAgPSB7c2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tYy13LWNvbHVtbid9LFxuICAgICAgICAgICAgZXZlbnRPcHRzICAgID0ge3Njb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWV2ZW50J30sXG4gICAgICAgICAgICBvd25lciAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IG93bmVyLmRvbUxpc3RlbmVycztcblxuICAgICAgICBkb21MaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uQ29sdW1uRHJhZ0VuZCwgICAuLi5jb2x1bW5PcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uRXZlbnREcmFnRW5kLCAgICAuLi5ldmVudE9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25Db2x1bW5EcmFnTW92ZSwgIC4uLmNvbHVtbk9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25FdmVudERyYWdNb3ZlLCAgIC4uLmV2ZW50T3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkNvbHVtbkRyYWdTdGFydCwgLi4uY29sdW1uT3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkV2ZW50RHJhZ1N0YXJ0LCAgLi4uZXZlbnRPcHRzfVxuICAgICAgICApO1xuXG4gICAgICAgIG93bmVyLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGRyYWcgZXZlbnRzIHdoaWNoIHN0YXJ0IG9uIGFuIGV2ZW50IHJlc2l6ZSBoYW5kbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYWRqdXN0UmVzaXplRXZlbnQoZGF0YSkge1xuICAgICAgICBkYXRhLnBhdGguc2hpZnQoKTtcbiAgICAgICAgZGF0YS50YXJnZXRQYXRoLnNoaWZ0KCk7XG4gICAgICAgIGRhdGEudGFyZ2V0ID0gZGF0YS5wYXRoWzBdO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kcmFnRWxlbWVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0cy5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmV2ZW50UmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucHJveHlQYXJlbnRJZFxuICAgICAqIEByZXR1cm5zIHtOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmV9XG4gICAgICovXG4gICAgZ2V0RXZlbnREcmFnWm9uZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUgPSBvd25lci5ldmVudERyYWdab25lLFxuICAgICAgICAgICAgdGltZUF4aXMgICAgICA9IG93bmVyLnRpbWVBeGlzLFxuXG4gICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYXhpc0VuZFRpbWUgICAgICAgICAgICAgICAgICAgICA6IHRpbWVBeGlzLmdldFRpbWUob3duZXIuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0VGltZSAgICAgICAgICAgICAgICAgICA6IHRpbWVBeGlzLmdldFRpbWUob3duZXIuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICAgICAgICAgICAgICAgICAgIDogb3B0cy5kcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICBlbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZTogb3B0cy5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZSxcbiAgICAgICAgICAgICAgICBldmVudFJlY29yZCAgICAgICAgICAgICAgICAgICAgIDogb3B0cy5ldmVudFJlY29yZCxcbiAgICAgICAgICAgICAgICBwcm94eVBhcmVudElkICAgICAgICAgICAgICAgICAgIDogb3B0cy5wcm94eVBhcmVudElkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZXZlbnREcmFnWm9uZSkge1xuICAgICAgICAgICAgb3duZXIuZXZlbnREcmFnWm9uZSA9IGV2ZW50RHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgIDogRXZlbnREcmFnWm9uZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgIDogb3duZXIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQ6IG93bmVyLmdldFNjcm9sbENvbnRhaW5lcigpLmlkLFxuICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcblxuICAgICAgICAgICAgICAgIGRyYWdQcm94eUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lsbENoYW5nZTogJ2hlaWdodCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudERyYWdab25lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RvcExldmVsQ29sdW1uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbMF0uY2xzLmluY2x1ZGVzKCduZW8tYy13LWNvbHVtbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVG9wTGV2ZWxFdmVudChldmVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50RGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWV2ZW50Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29sdW1uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgICAgICAgID0gbWUub3duZXIsXG4gICAgICAgICAgICByZWNvcmRTeW1ib2wgPSBTeW1ib2wuZm9yKCdhZGRlZFJlY29yZCcpLFxuICAgICAgICAgICAgcmVjb3JkICAgICAgID0gbWVbcmVjb3JkU3ltYm9sXTtcblxuICAgICAgICBpZiAocmVjb3JkICYmIG1lLmlzVG9wTGV2ZWxDb2x1bW4oZGF0YS5wYXRoKSkge1xuICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBkZWxldGUgbWVbcmVjb3JkU3ltYm9sXTtcblxuICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICBpZCAgIDogb3duZXIuZ2V0RXZlbnRJZChyZWNvcmQuaWQpLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7b3BhY2l0eTogMX1cbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG93bmVyLmV2ZW50RHJhZ1pvbmUuZHJhZ0VuZCgpO1xuICAgICAgICAgICAgICAgIG93bmVyLmdldFBsdWdpbih7ZmxhZzoncmVzaXphYmxlJ30pLm9uRHJhZ0VuZChkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29sdW1uRHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc1RvcExldmVsQ29sdW1uKGRhdGEucGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIuZXZlbnREcmFnWm9uZT8uZHJhZ01vdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db2x1bW5EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc1RvcExldmVsQ29sdW1uKGRhdGEudGFyZ2V0UGF0aCkpIHtcbiAgICAgICAgICAgIGxldCBvd25lciAgICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgICAgICBheGlzU3RhcnRUaW1lICAgPSBvd25lci50aW1lQXhpcy5nZXRUaW1lKG93bmVyLnN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTdG9yZSAgID0gb3duZXIuY2FsZW5kYXJTdG9yZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5SZWN0ICAgICAgPSBkYXRhLnBhdGhbMF0ucmVjdCxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbFNpemUgICAgPSAxNSxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbHMgICAgICAgPSAob3duZXIudGltZUF4aXMuZ2V0VGltZShvd25lci5lbmRUaW1lKSAtIGF4aXNTdGFydFRpbWUpICogNjAgLyBpbnRlcnZhbFNpemUsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxIZWlnaHQgID0gY29sdW1uUmVjdC5oZWlnaHQgLyBpbnRlcnZhbHMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gICAgICAgID0gTWF0aC5taW4oY29sdW1uUmVjdC5oZWlnaHQsIGRhdGEuY2xpZW50WSAtIGNvbHVtblJlY3QudG9wKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gaW50ZXJ2YWxIZWlnaHQpLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSAgICAgICA9IG5ldyBEYXRlKFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQob3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tLmZsYWcgKyAnVDAwOjAwOjAwJyksXG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsIGVuZERhdGUsIGV2ZW50RHJhZ1pvbmUsIGV2ZW50SWQsIHJlY29yZDtcblxuICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKE1hdGgubWluKGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSwgaW50ZXJ2YWxzICogaW50ZXJ2YWxTaXplIC0gb3duZXIubWluaW11bUV2ZW50RHVyYXRpb24pKTtcblxuICAgICAgICAgICAgZW5kRGF0ZSA9IERhdGVVdGlsLmNsb25lKHN0YXJ0RGF0ZSk7XG5cbiAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcyhlbmREYXRlLmdldE1pbnV0ZXMoKSArIG93bmVyLm1pbmltdW1FdmVudER1cmF0aW9uKTtcblxuICAgICAgICAgICAgLy8gMjQ6MDAgZml4XG4gICAgICAgICAgICBlbmREYXRlLmdldEhvdXJzKCkgPT09IDAgJiYgZW5kRGF0ZS5nZXRNaW51dGVzKCkgPT09IDAgJiYgZW5kRGF0ZS5zZXRNaW51dGVzKGVuZERhdGUuZ2V0TWludXRlcygpIC0gMSk7XG5cbiAgICAgICAgICAgIHJlY29yZCA9IG93bmVyLmV2ZW50U3RvcmUuYWRkKHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcklkOiBvd25lci5kYXRhLmFjdGl2ZUNhbGVuZGFySWQgfHwgY2FsZW5kYXJTdG9yZS5nZXRBdCgwKVtjYWxlbmRhclN0b3JlLmtleVByb3BlcnR5XSxcbiAgICAgICAgICAgICAgICBlbmREYXRlLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICB0aXRsZSAgICAgOiAnTmV3IEV2ZW50J1xuICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2FjaGUgYSByZWZlcmVuY2UgdG8gbWFrZSB0aGUgcmVjb3JkIGFjY2Vzc2libGUgZm9yIG9uQ29sdW1uRHJhZ0VuZCgpXG4gICAgICAgICAgICBtZVtTeW1ib2wuZm9yKCdhZGRlZFJlY29yZCcpXSA9IHJlY29yZDtcblxuICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV3IGV2ZW50IGdvdCBtb3VudGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudElkICAgICA9IG93bmVyLmdldEV2ZW50SWQocmVjb3JkLmlkKTtcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQob3duZXIudmRvbSwgZXZlbnRJZCkudmRvbTtcblxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUgPSBtZS5nZXRFdmVudERyYWdab25lKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBldmVudFJlY29yZCAgICAgICAgICAgICAgICAgICAgIDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICBwcm94eVBhcmVudElkICAgICAgICAgICAgICAgICAgIDogZGF0YS5wYXRoWzBdLmlkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBvd25lci5nZXRQbHVnaW4oe2ZsYWc6J3Jlc2l6YWJsZSd9KS5vbkRyYWdTdGFydChkYXRhKTtcbiAgICAgICAgICAgICAgICBldmVudERyYWdab25lLmRyYWdTdGFydChkYXRhKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5pc0RyYWdnaW5nICYmIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgIDogZXZlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7b3BhY2l0eTogMH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnREcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyID0gbWUub3duZXI7XG5cbiAgICAgICAgaWYgKG93bmVyLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIG93bmVyLmV2ZW50RHJhZ1pvbmUuZHJhZ0VuZCgpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmlzVG9wTGV2ZWxFdmVudChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtZS5hZGp1c3RSZXNpemVFdmVudChkYXRhKTtcbiAgICAgICAgICAgICAgICBvd25lci5nZXRQbHVnaW4oe2ZsYWc6J3Jlc2l6YWJsZSd9KS5vbkRyYWdFbmQoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG93bmVyLmV2ZW50RHJhZ1pvbmUucmVtb3ZlQm9keUN1cnNvckNscygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyID0gbWUub3duZXI7XG5cbiAgICAgICAgaWYgKG93bmVyLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIGlmICghbWUuaXNUb3BMZXZlbEV2ZW50KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1lLmFkanVzdFJlc2l6ZUV2ZW50KGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvd25lci5ldmVudERyYWdab25lLmRyYWdNb3ZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnREcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyICAgICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgbW9kZWxEYXRhID0gb3duZXIuZGF0YTtcblxuICAgICAgICBpZiAob3duZXIuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgbGV0IGlzVG9wTGV2ZWxFdmVudCA9IG1lLmlzVG9wTGV2ZWxFdmVudChkYXRhKSxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCwgZXZlbnREcmFnWm9uZTtcblxuICAgICAgICAgICAgaWYgKCFpc1RvcExldmVsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbWUuYWRqdXN0UmVzaXplRXZlbnQoZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBkcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQob3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tO1xuXG4gICAgICAgICAgICBldmVudERyYWdab25lID0gbWUuZ2V0RXZlbnREcmFnWm9uZSh7XG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U6IG1vZGVsRGF0YS5ldmVudHMuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UsXG4gICAgICAgICAgICAgICAgZXZlbnRSZWNvcmQgICAgICAgICAgICAgICAgICAgICA6IG93bmVyLmV2ZW50U3RvcmUuZ2V0KGRyYWdFbGVtZW50LmZsYWcpLFxuICAgICAgICAgICAgICAgIHByb3h5UGFyZW50SWQgICAgICAgICAgICAgICAgICAgOiBkYXRhLnBhdGhbMV0uaWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNUb3BMZXZlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5hZGRCb2R5Q3Vyc29yQ2xzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG93bmVyLmdldFBsdWdpbih7ZmxhZzoncmVzaXphYmxlJ30pLm9uRHJhZ1N0YXJ0KGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudERyYWdab25lLmRyYWdTdGFydChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoRHJhZ0Ryb3ApO1xuXG5leHBvcnQge0RyYWdEcm9wIGFzIGRlZmF1bHR9O1xuIiwiaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIFBsdWdpbnMgYXJlIGludGVuZGVkIHRvIGdldCBwdXQgaW50byB0aGUgcGx1Z2lucyBjb25maWcgb2YgY29tcG9uZW50LkJhc2VcbiAqIHRvIGVuaGFuY2UgdGhlbSBvciBhZGQgYWRkaXRpb25hbCBmZWF0dXJlc1xuICogQGNsYXNzIE5lby5wbHVnaW4uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbFxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm93bmVyLm9uKCdtb3VudGVkJywgbWUub25Pd25lck1vdW50ZWQsIG1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKEJhc2UpO1xuXG5leHBvcnQge0Jhc2UgYXMgZGVmYXVsdH07XG4iXSwic291cmNlUm9vdCI6IiJ9