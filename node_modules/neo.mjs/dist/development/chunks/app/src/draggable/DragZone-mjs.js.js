(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src/draggable/DragZone-mjs.js"],{

/***/ "./src/draggable/DragProxyComponent.mjs":
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragProxyComponent)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {Boolean} autoRender=true
         */
        autoRender: true,
        /**
         * @member {String[]} cls=['neo-dragproxy']
         */
        cls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me = this;

        me.on('mounted', me.onMounted, me);
    }

    /**
     *
     * @param {String} id
     */
    onMounted(id) {
        if (this.moveInMainThread) {
            Neo.main.addon.DragDrop.setDragProxyElement({
                appName: this.appName,
                id     : id
            });
        }
    }
}

Neo.applyClassConfig(DragProxyComponent);



/***/ }),

/***/ "./src/draggable/DragZone.mjs":
/*!************************************!*\
  !*** ./src/draggable/DragZone.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragZone)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @class Neo.draggable.DragZone
 * @extends Neo.core.Base
 */
class DragZone extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getStaticConfig() {return {
        /**
         * True automatically applies the core/Observable.mjs mixin
         * @member {Boolean} observable=true
         * @static
         */
        observable: true
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragZone'
         * @protected
         */
        className: 'Neo.draggable.DragZone',
        /**
         * @member {String} ntype='dragzone'
         * @protected
         */
        ntype: 'dragzone',
        /**
         * Adds this.dragProxyCls => 'neo-dragproxy' to the top level dragProxyEl node
         * @member {Boolean} addDragProxyCls=true
         */
        addDragProxyCls: true,
        /**
         * drag:move will by default only fire in case moveInMainThread === false.
         * In case you want to move the dragProxy inside main but still get the event,
         * set this config to true.
         * @member {Boolean} alwaysFireDragMove=false
         */
        alwaysFireDragMove: false,
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName=null
         */
        appName: null,
        /**
         * @member {String|null} boundaryContainerId=null
         */
        boundaryContainerId: null,
        /**
         * Store data which you want to pass to drop related events here
         * @member {Object|null} data=null
         */
        data: null,
        /**
         * The vdom (tree) of the element you want to drag
         * @member {Object|null} dragElement=null
         */
        dragElement: null,
        /**
         * The bounding client rect of the dragElement
         * Will get set inside dragStart()
         * @member {Object|null} dragElementRect=null
         */
        dragElementRect: null,
        /**
         * @member {Neo.component.Base|null} dragProxy=null
         * @protected
         */
        dragProxy: null,
        /**
         * @member {Object|null} dragProxyConfig=null
         */
        dragProxyConfig_: null,
        /**
         * @member {String} dragProxyCls='neo-dragproxy'
         */
        dragProxyCls: 'neo-dragproxy',
        /**
         * You can either pass an array of (dom) ids or cls rules or both
         * @example
         * dropZoneIdentifier: {
         *     ids: ['foo','bar']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2'],
         *     ids: ['foo','bar']
         * }
         * @member {Object|null} dropZoneIdentifier=null
         */
        dropZoneIdentifier: null,
        /**
         * @member {Boolean} moveHorizontal=true
         */
        moveHorizontal: true,
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true,
        /**
         * @member {Boolean} moveVertical=true
         */
        moveVertical: true,
        /**
         * @member {Number} offsetX=0
         */
        offsetX: 0,
        /**
         * @member {Number} offsetY=0
         */
        offsetY: 0,
        /**
         * @member {Neo.component.Base} owner=null
         */
        owner: null,
        /**
         * @member {String} proxyParentId_='document.body'
         */
        proxyParentId_: 'document.body',
        /**
         * @member {String|null} scrollContainerId=null
         */
        scrollContainerId: null,
        /**
         * @member {Number} scrollFactorLeft=1
         */
        scrollFactorLeft: 1,
        /**
         * @member {Number} scrollFactorTop=1
         */
        scrollFactorTop: 1,
        /**
         * True creates a position:absolute wrapper div which contains the cloned element
         * @member {Boolean} useProxyWrapper=true
         */
        useProxyWrapper: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        if (!Neo.main.addon.DragDrop) {
            console.error('You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons', this.id);
        }
    }

    /**
     * Triggered when accessing the dragProxyConfig config
     * We are re-using this config to create multiple dragProxies,
     * so it is important to work with a clone. see: createDragProxy()
     * @param {Object} value
     * @protected
     */
    beforeGetDragProxyConfig(value) {
        return Neo.clone(value, true, true);
    }

    /**
     *
     * @param {Object} data
     */
    createDragProxy(data) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__.default.clone(me.dragElement),
            rect      = me.dragElementRect;

        const config = {
            module          : _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.default,
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            vdom            : me.useProxyWrapper ? {cn: [clone]} : clone,

            style: {
                height: `${data.height}px`,
                left  : `${me.moveHorizontal ? data.x : rect.x}px`,
                top   : `${me.moveVertical   ? data.y : rect.y}px`,
                width : `${data.width}px`
            },

            ...me.dragProxyConfig || {}
        };

        config.cls = config.cls || [];

        if (component) {
            config.cls.push(component.getTheme());
        }

        if (!me.useProxyWrapper) {
            config.cls.push(...clone.cls);
        }

        if (me.addDragProxyCls && config.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.add(config.cls, me.dragProxyCls);
        }

        me.dragProxy = Neo.create(config);
    }

    /**
     * Override for using custom animations
     */
    destroyDragProxy() {
        let me = this,
            id = me.dragProxy.id;

        setTimeout(() => {
            Neo.currentWorker.promiseMessage('main', {
                action : 'updateDom',
                appName: me.appName,
                deltas : [{action: 'removeNode', id: id}]
            });
        }, me.moveInMainThread ? 0 : 30);

        me.dragProxy.destroy();
    }

    /**
     *
     */
    dragEnd() {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.remove(cls, 'neo-is-dragging');
        owner.cls = cls;

        if (me.dragProxy) {
            me.destroyDragProxy();
            me.dragProxy = null;
        }

        Object.assign(me, {
            dragElementRect  : null,
            offsetX          : 0,
            offsetY          : 0,
            scrollContainerId: null
        });

        me.resetData();
    }

    /**
     *
     * @param {Object} data
     */
    dragMove(data) {
        let me = this,
            style;

        if (!me.moveInMainThread && me.dragProxy) {
            style = me.dragProxy.style;

            if (me.moveHorizontal) {
                style.left = `${data.clientX - me.offsetX}px`;
            }

            if (me.moveVertical) {
                style.top = `${data.clientY - me.offsetY}px`;
            }

            me.dragProxy.style = style;
        }
    }

    /**
     *
     * @param {Object} data
     */
    dragStart(data) {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls,
            offsetX, offsetY;

        me.setData();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.add(cls, 'neo-is-dragging');
        owner.cls = cls;

        Neo.main.addon.DragDrop.setConfigs({
            appName: me.appName,
            ...me.getMainThreadConfigs()
        });

        Neo.main.DomAccess.getBoundingClientRect({
            appName: me.appName,
            id:      me.getDragElementRoot().id
        }).then(rect => {
            offsetX = data.clientX - rect.left;
            offsetY = data.clientY - rect.top;

            Object.assign(me, {
                dragElementRect: rect,
                offsetX        : offsetX,
                offsetY        : offsetY
            });

            me.createDragProxy(rect);

            me.fire('dragStart', {
                dragElementRect: rect,
                id             : me.id,
                offsetX        : offsetX,
                offsetY        : offsetY
            });
        });
    }

    /**
     * Override this method in case you want to wrap your dragElement.
     * See: draggable.tree.DragZone
     * @returns {Object}
     */
    getDragElementRoot() {
        return this.dragElement;
    }

    /**
     * Override this method inside class extensions to add more configs
     * which get passed to main.addon.DragDrop onDragStart()
     * @returns {Object}
     * @protected
     */
    getMainThreadConfigs() {
        let me = this;

        return {
            alwaysFireDragMove : me.alwaysFireDragMove,
            boundaryContainerId: me.boundaryContainerId,
            dragElementRootId  : me.getDragElementRoot().id,
            dragProxyCls       : me.dragProxyCls,
            dragZoneId         : me.id,
            dropZoneIdentifier : me.dropZoneIdentifier,
            moveHorizontal     : me.moveHorizontal,
            moveVertical       : me.moveVertical,
            scrollContainerId  : me.scrollContainerId,
            scrollFactorLeft   : me.scrollFactorLeft,
            scrollFactorTop    : me.scrollFactorTop
        };
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDrop(data) {
        this.fire('drop', data);
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropEnter(data) {
        this.fire('drop:enter', data);
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropLeave(data) {
        this.fire('drop:leave', data);
    }

    /**
     *
     */
    resetData() {
        setTimeout(() => {
            this.data = null;
        }, 30);
    }

    /**
     * Extend this method for child classes to pass additional properties
     * @param {Object} data={}
     */
    setData(data={}) {
        let me = this;

        me.data = {
            dragElement: me.getDragElementRoot(),
            dragZoneId : me.id,
            ...data
        };
    }
}

Neo.applyClassConfig(DragZone);



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnUHJveHlDb21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL0RyYWdab25lLm1qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0RBQUk7QUFDckMsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURrRDtBQUNRO0FBQ1A7QUFDRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbURBQUk7QUFDM0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtB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LGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImNodW5rcy9hcHAvc3JjL2RyYWdnYWJsZS9EcmFnWm9uZS1tanMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIERyYWdQcm94eUNvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3Byb3h5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWdwcm94eScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b1JlbmRlcj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvUmVuZGVyOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ25lby1kcmFncHJveHknXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ25lby1kcmFncHJveHknXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVJbk1haW5UaHJlYWQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUluTWFpblRocmVhZDogdHJ1ZVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm9uKCdtb3VudGVkJywgbWUub25Nb3VudGVkLCBtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBvbk1vdW50ZWQoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMubW92ZUluTWFpblRocmVhZCkge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0RHJhZ1Byb3h5RWxlbWVudCh7XG4gICAgICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGlkICAgICA6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoRHJhZ1Byb3h5Q29tcG9uZW50KTtcblxuZXhwb3J0IHtEcmFnUHJveHlDb21wb25lbnQgYXMgZGVmYXVsdH07IiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi9EcmFnUHJveHlDb21wb25lbnQubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnWm9uZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBEcmFnWm9uZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBnZXRTdGF0aWNDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlL09ic2VydmFibGUubWpzIG1peGluXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBvYnNlcnZhYmxlOiB0cnVlXG4gICAgfX1cblxuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLkRyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2RyYWd6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWd6b25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgdGhpcy5kcmFnUHJveHlDbHMgPT4gJ25lby1kcmFncHJveHknIHRvIHRoZSB0b3AgbGV2ZWwgZHJhZ1Byb3h5RWwgbm9kZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhZGREcmFnUHJveHlDbHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRHJhZ1Byb3h5Q2xzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZzptb3ZlIHdpbGwgYnkgZGVmYXVsdCBvbmx5IGZpcmUgaW4gY2FzZSBtb3ZlSW5NYWluVGhyZWFkID09PSBmYWxzZS5cbiAgICAgICAgICogSW4gY2FzZSB5b3Ugd2FudCB0byBtb3ZlIHRoZSBkcmFnUHJveHkgaW5zaWRlIG1haW4gYnV0IHN0aWxsIGdldCB0aGUgZXZlbnQsXG4gICAgICAgICAqIHNldCB0aGlzIGNvbmZpZyB0byB0cnVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbHdheXNGaXJlRHJhZ01vdmU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGFsd2F5c0ZpcmVEcmFnTW92ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQXBwIHRoaXMgaW5zdGFuY2UgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBhcHBOYW1lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGJvdW5kYXJ5Q29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlIGRhdGEgd2hpY2ggeW91IHdhbnQgdG8gcGFzcyB0byBkcm9wIHJlbGF0ZWQgZXZlbnRzIGhlcmVcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRhdGE9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZG9tICh0cmVlKSBvZiB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBkcmFnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnRWxlbWVudD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRWxlbWVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvZiB0aGUgZHJhZ0VsZW1lbnRcbiAgICAgICAgICogV2lsbCBnZXQgc2V0IGluc2lkZSBkcmFnU3RhcnQoKVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJhZ0VsZW1lbnRSZWN0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdFbGVtZW50UmVjdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBkcmFnUHJveHk9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJhZ1Byb3h5Q29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdQcm94eUNvbmZpZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRyYWdQcm94eUNscz0nbmVvLWRyYWdwcm94eSdcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdQcm94eUNsczogJ25lby1kcmFncHJveHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiBlaXRoZXIgcGFzcyBhbiBhcnJheSBvZiAoZG9tKSBpZHMgb3IgY2xzIHJ1bGVzIG9yIGJvdGhcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogZHJvcFpvbmVJZGVudGlmaWVyOiB7XG4gICAgICAgICAqICAgICBpZHM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICogfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBkcm9wWm9uZUlkZW50aWZpZXI6IHtcbiAgICAgICAgICogICAgIGNsczogWydteS1jbGFzcy0xJywnbXktY2xhc3MtMiddXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogZHJvcFpvbmVJZGVudGlmaWVyOiB7XG4gICAgICAgICAqICAgICBjbHM6IFsnbXktY2xhc3MtMScsJ215LWNsYXNzLTInXSxcbiAgICAgICAgICogICAgIGlkczogWydmb28nLCdiYXInXVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcm9wWm9uZUlkZW50aWZpZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcFpvbmVJZGVudGlmaWVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUhvcml6b250YWw9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUhvcml6b250YWw6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlVmVydGljYWw9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVZlcnRpY2FsOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBvZmZzZXRYPTBcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG9mZnNldFk9MFxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHByb3h5UGFyZW50SWRfPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKi9cbiAgICAgICAgcHJveHlQYXJlbnRJZF86ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzY3JvbGxDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxDb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsRmFjdG9yTGVmdD0xXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxGYWN0b3JMZWZ0OiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxGYWN0b3JUb3A9MVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yVG9wOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBjcmVhdGVzIGEgcG9zaXRpb246YWJzb2x1dGUgd3JhcHBlciBkaXYgd2hpY2ggY29udGFpbnMgdGhlIGNsb25lZCBlbGVtZW50XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVByb3h5V3JhcHBlcj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VQcm94eVdyYXBwZXI6IHRydWVcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignWW91IGNhbiBub3QgdXNlIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmUgd2l0aG91dCBhZGRpbmcgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3AgdG8gdGhlIG1haW4gdGhyZWFkIGFkZG9ucycsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkcmFnUHJveHlDb25maWcgY29uZmlnXG4gICAgICogV2UgYXJlIHJlLXVzaW5nIHRoaXMgY29uZmlnIHRvIGNyZWF0ZSBtdWx0aXBsZSBkcmFnUHJveGllcyxcbiAgICAgKiBzbyBpdCBpcyBpbXBvcnRhbnQgdG8gd29yayB3aXRoIGEgY2xvbmUuIHNlZTogY3JlYXRlRHJhZ1Byb3h5KClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RHJhZ1Byb3h5Q29uZmlnKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uY2xvbmUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVEcmFnUHJveHkoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQobWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQpIHx8IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xvbmUgICAgID0gVkRvbVV0aWwuY2xvbmUobWUuZHJhZ0VsZW1lbnQpLFxuICAgICAgICAgICAgcmVjdCAgICAgID0gbWUuZHJhZ0VsZW1lbnRSZWN0O1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICA6IERyYWdQcm94eUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBtZS5tb3ZlSW5NYWluVGhyZWFkLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgIDogbWUucHJveHlQYXJlbnRJZCxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICA6IG1lLnVzZVByb3h5V3JhcHBlciA/IHtjbjogW2Nsb25lXX0gOiBjbG9uZSxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke21lLm1vdmVIb3Jpem9udGFsID8gZGF0YS54IDogcmVjdC54fXB4YCxcbiAgICAgICAgICAgICAgICB0b3AgICA6IGAke21lLm1vdmVWZXJ0aWNhbCAgID8gZGF0YS55IDogcmVjdC55fXB4YCxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAuLi5tZS5kcmFnUHJveHlDb25maWcgfHwge31cbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWcuY2xzID0gY29uZmlnLmNscyB8fCBbXTtcblxuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25maWcuY2xzLnB1c2goY29tcG9uZW50LmdldFRoZW1lKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS51c2VQcm94eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaCguLi5jbG9uZS5jbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmFkZERyYWdQcm94eUNscyAmJiBjb25maWcuY2xzKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY29uZmlnLmNscywgbWUuZHJhZ1Byb3h5Q2xzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYWdQcm94eSA9IE5lby5jcmVhdGUoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBmb3IgdXNpbmcgY3VzdG9tIGFuaW1hdGlvbnNcbiAgICAgKi9cbiAgICBkZXN0cm95RHJhZ1Byb3h5KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaWQgPSBtZS5kcmFnUHJveHkuaWQ7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGRlbHRhcyA6IFt7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBpZH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbWUubW92ZUluTWFpblRocmVhZCA/IDAgOiAzMCk7XG5cbiAgICAgICAgbWUuZHJhZ1Byb3h5LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRyYWdFbmQoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xzICAgPSBvd25lci5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1pcy1kcmFnZ2luZycpO1xuICAgICAgICBvd25lci5jbHMgPSBjbHM7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgbWUuZGVzdHJveURyYWdQcm94eSgpO1xuICAgICAgICAgICAgbWUuZHJhZ1Byb3h5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdCAgOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0WCAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBvZmZzZXRZICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnJlc2V0RGF0YSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBzdHlsZTtcblxuICAgICAgICBpZiAoIW1lLm1vdmVJbk1haW5UaHJlYWQgJiYgbWUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBzdHlsZSA9IG1lLmRyYWdQcm94eS5zdHlsZTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vdmVIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IGAke2RhdGEuY2xpZW50WCAtIG1lLm9mZnNldFh9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUubW92ZVZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gYCR7ZGF0YS5jbGllbnRZIC0gbWUub2Zmc2V0WX1weGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRyYWdQcm94eS5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xzICAgPSBvd25lci5jbHMsXG4gICAgICAgICAgICBvZmZzZXRYLCBvZmZzZXRZO1xuXG4gICAgICAgIG1lLnNldERhdGEoKTtcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWlzLWRyYWdnaW5nJyk7XG4gICAgICAgIG93bmVyLmNscyA9IGNscztcblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zZXRDb25maWdzKHtcbiAgICAgICAgICAgIGFwcE5hbWU6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAuLi5tZS5nZXRNYWluVGhyZWFkQ29uZmlncygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5nZXRCb3VuZGluZ0NsaWVudFJlY3Qoe1xuICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGlkOiAgICAgIG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkXG4gICAgICAgIH0pLnRoZW4ocmVjdCA9PiB7XG4gICAgICAgICAgICBvZmZzZXRYID0gZGF0YS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgb2Zmc2V0WSA9IGRhdGEuY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnRSZWN0OiByZWN0LFxuICAgICAgICAgICAgICAgIG9mZnNldFggICAgICAgIDogb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZICAgICAgICA6IG9mZnNldFlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jcmVhdGVEcmFnUHJveHkocmVjdCk7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ2RyYWdTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3QsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBvZmZzZXRYICAgICAgICA6IG9mZnNldFgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgOiBvZmZzZXRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gY2FzZSB5b3Ugd2FudCB0byB3cmFwIHlvdXIgZHJhZ0VsZW1lbnQuXG4gICAgICogU2VlOiBkcmFnZ2FibGUudHJlZS5EcmFnWm9uZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RHJhZ0VsZW1lbnRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgY2xhc3MgZXh0ZW5zaW9ucyB0byBhZGQgbW9yZSBjb25maWdzXG4gICAgICogd2hpY2ggZ2V0IHBhc3NlZCB0byBtYWluLmFkZG9uLkRyYWdEcm9wIG9uRHJhZ1N0YXJ0KClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRNYWluVGhyZWFkQ29uZmlncygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlIDogbWUuYWx3YXlzRmlyZURyYWdNb3ZlLFxuICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuYm91bmRhcnlDb250YWluZXJJZCxcbiAgICAgICAgICAgIGRyYWdFbGVtZW50Um9vdElkICA6IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkLFxuICAgICAgICAgICAgZHJhZ1Byb3h5Q2xzICAgICAgIDogbWUuZHJhZ1Byb3h5Q2xzLFxuICAgICAgICAgICAgZHJhZ1pvbmVJZCAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICBkcm9wWm9uZUlkZW50aWZpZXIgOiBtZS5kcm9wWm9uZUlkZW50aWZpZXIsXG4gICAgICAgICAgICBtb3ZlSG9yaXpvbnRhbCAgICAgOiBtZS5tb3ZlSG9yaXpvbnRhbCxcbiAgICAgICAgICAgIG1vdmVWZXJ0aWNhbCAgICAgICA6IG1lLm1vdmVWZXJ0aWNhbCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkICA6IG1lLnNjcm9sbENvbnRhaW5lcklkLFxuICAgICAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdCAgIDogbWUuc2Nyb2xsRmFjdG9yTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbEZhY3RvclRvcCAgICA6IG1lLnNjcm9sbEZhY3RvclRvcFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCB0aGlzIGNsYXNzIGFuZCBvdmVycmlkZSB0aGUgaGFuZGxlciBvciBsaXN0ZW4gdG8gdGhlIGV2ZW50IGZyb20gdGhlIG91dHNpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJvcChkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnZHJvcCcsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCB0aGlzIGNsYXNzIGFuZCBvdmVycmlkZSB0aGUgaGFuZGxlciBvciBsaXN0ZW4gdG8gdGhlIGV2ZW50IGZyb20gdGhlIG91dHNpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJvcEVudGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdkcm9wOmVudGVyJywgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIG92ZXJyaWRlIHRoZSBoYW5kbGVyIG9yIGxpc3RlbiB0byB0aGUgZXZlbnQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wTGVhdmUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ2Ryb3A6bGVhdmUnLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlc2V0RGF0YSgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICB9LCAzMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoaXMgbWV0aG9kIGZvciBjaGlsZCBjbGFzc2VzIHRvIHBhc3MgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9e31cbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGE9e30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kYXRhID0ge1xuICAgICAgICAgICAgZHJhZ0VsZW1lbnQ6IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLFxuICAgICAgICAgICAgZHJhZ1pvbmVJZCA6IG1lLmlkLFxuICAgICAgICAgICAgLi4uZGF0YVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoRHJhZ1pvbmUpO1xuXG5leHBvcnQge0RyYWdab25lIGFzIGRlZmF1bHR9OyJdLCJzb3VyY2VSb290IjoiIn0=