(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src/plugin/Resizable-mjs.js"],{

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ Base
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me = this;

        me.owner.on('mounted', me.onOwnerMounted, me);
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

Neo.applyClassConfig(Base);



/***/ }),

/***/ "./src/plugin/Resizable.mjs":
/*!**********************************!*\
  !*** ./src/plugin/Resizable.mjs ***!
  \**********************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ Resizable
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * @class Neo.plugin.Resizable
 * @extends Neo.plugin.Base
 */
class Resizable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getStaticConfig() {return {
        /**
         * Resize cursor styles use north, south based names, so we need a mapping.
         * The order has to match the static positions array.
         * @member {String[]} cursorPositions=['s', 'sw', 'se', 'w', 'e', 'n', 'nw', 'ne']
         * @protected
         * @static
         */
        cursorPositions: ['s', 'sw', 'se', 'w', 'e', 'n', 'nw', 'ne'],
        /**
         * remove - chars
         * @member {RegExp} nameRegEx=/-([a-z])/g
         * @protected
         * @static
         */
        nameRegEx: /-([a-z])/g,
        /**
         * Internal position names
         * @member {String[]} validDirections=['bottom','bottom-left','bottom-right','left','right','top','top-left','top-right']
         * @static
         */
        positions: ['bottom', 'bottom-left', 'bottom-right', 'left', 'right', 'top', 'top-left', 'top-right'],
        /**
         * Directions into which you want to drag => resize
         * @member {String[]} validDirections=['b','bl','br','l','r','t','tl','tr']
         * @static
         */
        validDirections: ['b', 'bl', 'br', 'l', 'r', 't', 'tl', 'tr']
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.plugin.Resizable'
         * @protected
         */
        className: 'Neo.plugin.Resizable',
        /**
         * @member {String} ntype='plugin-resizable'
         * @protected
         */
        ntype: 'plugin-resizable',
        /**
         * @member {String|null} boundaryContainerId='document.body'
         */
        boundaryContainerId: 'document.body',
        /**
         * The DOMRect of the boundaryContainer if set (measured on drag:start)
         * @member {Object} boundaryContainerRect=null
         * @protected
         */
        boundaryContainerRect: null,
        /**
         * @member {String} currentNodeName=null
         * @protected
         */
        currentNodeName: null,
        /**
         * Must be set by each owner
         * @member {String} delegationCls=null
         */
        delegationCls: null,
        /**
         * Directions into which you want to drag => resize
         * @member {String[]} directions_=['b','bl','br','l','r','t','tl','tr']
         */
        directions_: ['b', 'bl', 'br', 'l', 'r', 't', 'tl', 'tr'],
        /**
         * @member {Neo.draggable.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Number} gap=10
         * @protected
         */
        gap: 10,
        /**
         * The DOMRect of the element to drag (measured on drag:start)
         * @member {Object} initialRect=null
         * @protected
         */
        initialRect: null,
        /**
         * @member {Boolean} isDragging=false
         */
        isDragging: false,
        /**
         * maximum height when resizing in px
         * @member {Number|null} maxHeight=null
         */
        maxHeight: null,
        /**
         * maximum width when resizing in px
         * @member {Number|null} maxWidth=null
         */
        maxWidth: null,
        /**
         * minimum height when resizing in px
         * @member {Number} minHeight=200
         */
        minHeight: 200,
        /**
         * minimum width when resizing in px
         * @member {Number} minWidth=200
         */
        minWidth: 200,
        /**
         * @member {Object} nodeBottom=null
         * @protected
         */
        nodeBottom: null,
        /**
         * @member {Object} nodeBottomLeft=null
         * @protected
         */
        nodeBottomLeft: null,
        /**
         * @member {Object} nodeBottomRight=null
         * @protected
         */
        nodeBottomRight: null,
        /**
         * @member {Object} nodeLeft=null
         * @protected
         */
        nodeLeft: null,
        /**
         * @member {Object} nodeRight=null
         * @protected
         */
        nodeRight: null,
        /**
         * @member {Object} nodeTop=null
         * @protected
         */
        nodeTop: null,
        /**
         * @member {Object} nodeTopLeft=null
         * @protected
         */
        nodeTopLeft: null,
        /**
         * @member {Object} nodeTopRight=null
         * @protected
         */
        nodeTopRight: null
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me           = this,
            domListeners = me.owner.domListeners;

        domListeners.push(
            {'drag:end'  : me.onDragEnd,    scope: me, delegate: '.neo-resizable'},
            {'drag:move' : me.onDragMove,   scope: me, delegate: '.neo-resizable'},
            {'drag:start': me.onDragStart,  scope: me, delegate: '.neo-resizable'},
            {mousemove   : me.onMouseMove,  scope: me, local   : true},
            {mouseleave  : me.onMouseLeave, scope: me}
        );

        me.owner.domListeners = domListeners;
    }

    /**
     *
     * @param {String} name
     * @returns {Boolean} true
     */
    addNode(name) {
        let me       = this,
            nodeName = 'node' + Neo.capitalize(name.replace(Resizable.nameRegEx, (str, letter) => letter.toUpperCase()));

        me.currentNodeName = name;
        me[nodeName] = {cls: ['neo-resizable', `neo-resizable-${name}`]};
        me.owner.getVdomRoot().cn.push(me[nodeName]);

        return true;
    }

    /**
     * Triggered before the directions config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetDirections(value, oldValue) {
        if (Array.isArray(value)) {
            let i   = 0,
                len = value.length;

            for (; i < len; i++) {
                if (this.beforeSetEnumValue(value[i], oldValue, 'directions', 'validDirections') !== value[i]) {
                    return oldValue;
                }
            }
        }

        return value;
    }

    /**
     *
     * @param {Object} data
     */
    onDragEnd(data) {
        let me    = this,
            style = me.owner.wrapperStyle; // todo: delegation target

        Object.assign(me, {
            boundaryContainerRect: null,
            initialRect          : null,
            isDragging           : false
        });

        Object.assign(style, {
            opacity  : 1,
            transform: 'none',
            ...me.dragZone.dragProxy.wrapperStyle
        });

        me.owner.wrapperStyle = style;

        Neo.main.DomAccess.setStyle({
            id   : 'document.body',
            style: {cursor: null}
        });

        me.dragZone.dragEnd();
        me.removeAllNodes();
    }

    /**
     *
     * @param {Object} data
     */
    onDragMove(data) {
        let me        = this,
            node      = me.currentNodeName,
            ctRect    = me.boundaryContainerRect,
            maxHeight = me.maxHeight,
            maxWidth  = me.maxWidth,
            minHeight = me.minHeight,
            minWidth  = me.minWidth,
            rect      = me.initialRect,
            dist, size, style;

        if (!node) {
            me.onDragEnd({});
        } else if (me.dragZone.dragProxy) {
            style = me.dragZone.dragProxy.wrapperStyle;

            if (node.includes('bottom')) {
                size = Math.max(minHeight, data.clientY - rect.top);

                if (maxHeight) {
                    size = Math.min(size, maxHeight);
                }

                if (ctRect) {
                    size = Math.min(size, ctRect.bottom - rect.top);
                }

                style.height = `${size}px`;
            } else if (node.includes('top')) {
                dist = Math.min(rect.bottom - minHeight, data.clientY);
                size = Math.max(minHeight, rect.height + rect.top - data.clientY);

                if (maxHeight) {
                    dist = Math.max(dist, rect.bottom - maxHeight);
                    size = Math.min(size, maxHeight);
                }

                if (ctRect) {
                    dist = Math.max(dist, ctRect.top);
                    size = Math.min(size, rect.bottom - ctRect.top);
                }

                style.height = `${size}px`;
                style.top    = `${dist}px`;
            }

            if (node.includes('left')) {
                dist = Math.min(rect.right - minWidth, data.clientX);
                size = Math.max(minWidth, rect.width + rect.left - data.clientX);

                if (maxWidth) {
                    dist = Math.max(dist, rect.right - maxWidth);
                    size = Math.min(size, maxWidth);
                }

                if (ctRect) {
                    dist = Math.max(dist, ctRect.left);
                    size = Math.min(size, rect.right - ctRect.left);
                }

                style.left  = `${dist}px`;
                style.width = `${size}px`;
            } else if (node.includes('right')) {
                size = Math.max(minWidth, rect.width - rect.right + data.clientX);

                if (maxWidth) {
                    size = Math.min(size, maxWidth);
                }

                if (ctRect) {
                    size = Math.min(size, ctRect.right - rect.left);
                }

                style.width = `${size}px`;
            }

            me.dragZone.dragProxy.wrapperStyle = style;
        }
    }

    /**
     *
     * @param {Object} data
     */
    onDragStart(data) {
        let me          = this,
            containerId = me.boundaryContainerId,
            i           = 0,
            len         = data.path.length,
            owner       = me.owner,
            style       = owner.wrapperStyle, // todo: delegation target
            target;

        me.isDragging = true;

        style.opacity = 0.3;
        me.owner.wrapperStyle = style;

        for (; i < len; i++) {
            target = data.path[i];

            if (target.cls.includes(me.delegationCls)) {
                me.initialRect = target.rect;
            }

            if (containerId) {
                if (containerId === 'document.body' && target.tagName === 'body' || containerId === target.id) {
                    me.boundaryContainerRect = target.rect;
                    break; // assuming that the dragEl is not outside of the container
                }
            }
        }

        if (!me.boundaryContainerRect) {
            Neo.main.DomAccess.getBoundingClientRect({
                id: me.boundaryContainerRect
            }).then(rect => {
                me.boundaryContainerRect = rect;
            });
        }

        Neo.main.DomAccess.setStyle({
            id   : 'document.body',
            style: {cursor: `${Resizable.cursorPositions[Resizable.positions.indexOf(me.currentNodeName)]}-resize !important`}
        });

        if (!me.dragZone) {
            me.dragZone = Neo.create({
                module             : _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_1__.default,
                appName            : owner.appName,
                boundaryContainerId: owner.boundaryContainerId,
                dragElement        : owner.vdom,
                moveInMainThread   : false,
                owner              : owner
            });
        } else {
            me.dragZone.boundaryContainerId = owner.boundaryContainerId;
        }

        me.dragZone.dragStart(data);
    }

    /**
     *
     * @param {Object} data
     */
    onMouseMove(data) {
        let me   = this,
            dir  = me.directions,
            i    = 0,
            gap  = me.gap,
            h    = false,
            len  = data.path.length,
            vdom = me.owner.vdom,
            bottom, left, right, target, top;

        if (!me.isDragging && !me.owner.isDragging) {
            for (; i < len; i++) {
                if (data.path[i].cls.includes(me.delegationCls)) {
                    target = data.path[i];
                    break;
                }
            }

            bottom = data.clientY >= target.rect.y - gap + target.rect.height;
            left   = data.clientX <= target.rect.x + gap;
            right  = data.clientX >= target.rect.x - gap + target.rect.width;
            top    = data.clientY <= target.rect.y + gap;

            if (me.nodeBottom && (!bottom || bottom && left  || bottom && right)) {h = me.removeNode('bottom');}
            if (me.nodeLeft   && (!left   || bottom && left  || top    && left))  {h = me.removeNode('left');}
            if (me.nodeRight  && (!right  || bottom && right || top    && right)) {h = me.removeNode('right');}
            if (me.nodeTop    && (!top    || top    && left  || top    && right)) {h = me.removeNode('top');}

            if (me.nodeBottomLeft  && (!bottom || !left))  {h = me.removeNode('bottom-left');}
            if (me.nodeBottomRight && (!bottom || !right)) {h = me.removeNode('bottom-right');}
            if (me.nodeTopLeft     && (!top    || !left))  {h = me.removeNode('top-left');}
            if (me.nodeTopRight    && (!top    || !right)) {h = me.removeNode('top-right');}

            if      (dir.includes('bl') && bottom && left)  {if (!me.nodeBottomLeft)  {h = me.addNode('bottom-left');}}
            else if (dir.includes('br') && bottom && right) {if (!me.nodeBottomRight) {h = me.addNode('bottom-right');}}
            else if (dir.includes('tl') && top    && left)  {if (!me.nodeTopLeft)     {h = me.addNode('top-left');}}
            else if (dir.includes('tr') && top    && right) {if (!me.nodeTopRight)    {h = me.addNode('top-right');}}
            else if (dir.includes('b')  && bottom)          {if (!me.nodeBottom)      {h = me.addNode('bottom');}}
            else if (dir.includes('l')  && left)            {if (!me.nodeLeft)        {h = me.addNode('left');}}
            else if (dir.includes('r')  && right)           {if (!me.nodeRight)       {h = me.addNode('right');}}
            else if (dir.includes('t')  && top)             {if (!me.nodeTop)         {h = me.addNode('top');}}

            if (h) {
                me.owner.vdom = vdom;
            }
        }
    }

    /**
     *
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me = this;

        if (!me.isDragging) {
            // limit the event to delegation targets
            if (data.path[0].cls.includes(me.delegationCls)) {
                me.removeAllNodes();
            }
        }
    }

    /**
     * There should be max 1 node (resize handle) at any given time.
     * see: /issues/1139
     */
    removeAllNodes() {
        let me   = this,
            vdom = me.owner.vdom;

        if (me.currentNodeName) {
            me.removeNode(me.currentNodeName);
            me.owner.vdom = vdom;
        }
    }

    /**
     *
     * @param {String} name
     * @returns {Boolean} true in case the node existed
     */
    removeNode(name) {
        let me       = this,
            nodeName = 'node' + Neo.capitalize(name.replace(Resizable.nameRegEx, (str, letter) => letter.toUpperCase()));

        if (me[nodeName]) {
            me.currentNodeName = null;
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.remove(me.owner.getVdomRoot().cn, me[nodeName]);
            me[nodeName] = null;

            return true;
        }

        return false;
    }
}

Neo.applyClassConfig(Resizable);



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9SZXNpemFibGUubWpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFRO0FBQzNCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0NrQztBQUNlO0FBQ1I7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFJO0FBQzVCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDJEQUFlO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImNodW5rcy9hcHAvc3JjL3BsdWdpbi9SZXNpemFibGUtbWpzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIFBsdWdpbnMgYXJlIGludGVuZGVkIHRvIGdldCBwdXQgaW50byB0aGUgcGx1Z2lucyBjb25maWcgb2YgY29tcG9uZW50LkJhc2VcbiAqIHRvIGVuaGFuY2UgdGhlbSBvciBhZGQgYWRkaXRpb25hbCBmZWF0dXJlc1xuICogQGNsYXNzIE5lby5wbHVnaW4uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbFxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm93bmVyLm9uKCdtb3VudGVkJywgbWUub25Pd25lck1vdW50ZWQsIG1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKEJhc2UpO1xuXG5leHBvcnQge0Jhc2UgYXMgZGVmYXVsdH07IiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IERyYWdab25lIGZyb20gJy4uL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5SZXNpemFibGVcbiAqIEBleHRlbmRzIE5lby5wbHVnaW4uQmFzZVxuICovXG5jbGFzcyBSZXNpemFibGUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemUgY3Vyc29yIHN0eWxlcyB1c2Ugbm9ydGgsIHNvdXRoIGJhc2VkIG5hbWVzLCBzbyB3ZSBuZWVkIGEgbWFwcGluZy5cbiAgICAgICAgICogVGhlIG9yZGVyIGhhcyB0byBtYXRjaCB0aGUgc3RhdGljIHBvc2l0aW9ucyBhcnJheS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGN1cnNvclBvc2l0aW9ucz1bJ3MnLCAnc3cnLCAnc2UnLCAndycsICdlJywgJ24nLCAnbncnLCAnbmUnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGN1cnNvclBvc2l0aW9uczogWydzJywgJ3N3JywgJ3NlJywgJ3cnLCAnZScsICduJywgJ253JywgJ25lJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmUgLSBjaGFyc1xuICAgICAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IG5hbWVSZWdFeD0vLShbYS16XSkvZ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIG5hbWVSZWdFeDogLy0oW2Etel0pL2csXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBwb3NpdGlvbiBuYW1lc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdmFsaWREaXJlY3Rpb25zPVsnYm90dG9tJywnYm90dG9tLWxlZnQnLCdib3R0b20tcmlnaHQnLCdsZWZ0JywncmlnaHQnLCd0b3AnLCd0b3AtbGVmdCcsJ3RvcC1yaWdodCddXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uczogWydib3R0b20nLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0JywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGlyZWN0aW9ucyBpbnRvIHdoaWNoIHlvdSB3YW50IHRvIGRyYWcgPT4gcmVzaXplXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB2YWxpZERpcmVjdGlvbnM9WydiJywnYmwnLCdicicsJ2wnLCdyJywndCcsJ3RsJywndHInXVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICB2YWxpZERpcmVjdGlvbnM6IFsnYicsICdibCcsICdicicsICdsJywgJ3InLCAndCcsICd0bCcsICd0ciddXG4gICAgfX1cblxuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLlJlc2l6YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnBsdWdpbi5SZXNpemFibGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luLXJlc2l6YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4tcmVzaXphYmxlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBib3VuZGFyeUNvbnRhaW5lcklkPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERPTVJlY3Qgb2YgdGhlIGJvdW5kYXJ5Q29udGFpbmVyIGlmIHNldCAobWVhc3VyZWQgb24gZHJhZzpzdGFydClcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBib3VuZGFyeUNvbnRhaW5lclJlY3Q9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBib3VuZGFyeUNvbnRhaW5lclJlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGN1cnJlbnROb2RlTmFtZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnROb2RlTmFtZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11c3QgYmUgc2V0IGJ5IGVhY2ggb3duZXJcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkZWxlZ2F0aW9uQ2xzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRlbGVnYXRpb25DbHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXJlY3Rpb25zIGludG8gd2hpY2ggeW91IHdhbnQgdG8gZHJhZyA9PiByZXNpemVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGRpcmVjdGlvbnNfPVsnYicsJ2JsJywnYnInLCdsJywncicsJ3QnLCd0bCcsJ3RyJ11cbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbnNfOiBbJ2InLCAnYmwnLCAnYnInLCAnbCcsICdyJywgJ3QnLCAndGwnLCAndHInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUuRHJhZ1pvbmV8bnVsbH0gZHJhZ1pvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGdhcD0xMFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBnYXA6IDEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERPTVJlY3Qgb2YgdGhlIGVsZW1lbnQgdG8gZHJhZyAobWVhc3VyZWQgb24gZHJhZzpzdGFydClcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpbml0aWFsUmVjdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNEcmFnZ2luZz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXhpbXVtIGhlaWdodCB3aGVuIHJlc2l6aW5nIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtYXhIZWlnaHQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SGVpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4aW11bSB3aWR0aCB3aGVuIHJlc2l6aW5nIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtYXhXaWR0aD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtYXhXaWR0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltdW0gaGVpZ2h0IHdoZW4gcmVzaXppbmcgaW4gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtaW5IZWlnaHQ9MjAwXG4gICAgICAgICAqL1xuICAgICAgICBtaW5IZWlnaHQ6IDIwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltdW0gd2lkdGggd2hlbiByZXNpemluZyBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbldpZHRoPTIwMFxuICAgICAgICAgKi9cbiAgICAgICAgbWluV2lkdGg6IDIwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZUJvdHRvbT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5vZGVCb3R0b206IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG5vZGVCb3R0b21MZWZ0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZUJvdHRvbUxlZnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG5vZGVCb3R0b21SaWdodD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5vZGVCb3R0b21SaWdodDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZUxlZnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlTGVmdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZVJpZ2h0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZVJpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBub2RlVG9wPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZVRvcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZVRvcExlZnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlVG9wTGVmdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZVRvcFJpZ2h0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZVRvcFJpZ2h0OiBudWxsXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gbWUub3duZXIuZG9tTGlzdGVuZXJzO1xuXG4gICAgICAgIGRvbUxpc3RlbmVycy5wdXNoKFxuICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25EcmFnRW5kLCAgICBzY29wZTogbWUsIGRlbGVnYXRlOiAnLm5lby1yZXNpemFibGUnfSxcbiAgICAgICAgICAgIHsnZHJhZzptb3ZlJyA6IG1lLm9uRHJhZ01vdmUsICAgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tcmVzaXphYmxlJ30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkRyYWdTdGFydCwgIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLXJlc2l6YWJsZSd9LFxuICAgICAgICAgICAge21vdXNlbW92ZSAgIDogbWUub25Nb3VzZU1vdmUsICBzY29wZTogbWUsIGxvY2FsICAgOiB0cnVlfSxcbiAgICAgICAgICAgIHttb3VzZWxlYXZlICA6IG1lLm9uTW91c2VMZWF2ZSwgc2NvcGU6IG1lfVxuICAgICAgICApO1xuXG4gICAgICAgIG1lLm93bmVyLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWVcbiAgICAgKi9cbiAgICBhZGROb2RlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGVOYW1lID0gJ25vZGUnICsgTmVvLmNhcGl0YWxpemUobmFtZS5yZXBsYWNlKFJlc2l6YWJsZS5uYW1lUmVnRXgsIChzdHIsIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpKTtcblxuICAgICAgICBtZS5jdXJyZW50Tm9kZU5hbWUgPSBuYW1lO1xuICAgICAgICBtZVtub2RlTmFtZV0gPSB7Y2xzOiBbJ25lby1yZXNpemFibGUnLCBgbmVvLXJlc2l6YWJsZS0ke25hbWV9YF19O1xuICAgICAgICBtZS5vd25lci5nZXRWZG9tUm9vdCgpLmNuLnB1c2gobWVbbm9kZU5hbWVdKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkaXJlY3Rpb25zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RGlyZWN0aW9ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgaSAgID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWVbaV0sIG9sZFZhbHVlLCAnZGlyZWN0aW9ucycsICd2YWxpZERpcmVjdGlvbnMnKSAhPT0gdmFsdWVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0eWxlID0gbWUub3duZXIud3JhcHBlclN0eWxlOyAvLyB0b2RvOiBkZWxlZ2F0aW9uIHRhcmdldFxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVyUmVjdDogbnVsbCxcbiAgICAgICAgICAgIGluaXRpYWxSZWN0ICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIGlzRHJhZ2dpbmcgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgb3BhY2l0eSAgOiAxLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAnbm9uZScsXG4gICAgICAgICAgICAuLi5tZS5kcmFnWm9uZS5kcmFnUHJveHkud3JhcHBlclN0eWxlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLm93bmVyLndyYXBwZXJTdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zZXRTdHlsZSh7XG4gICAgICAgICAgICBpZCAgIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgc3R5bGU6IHtjdXJzb3I6IG51bGx9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdab25lLmRyYWdFbmQoKTtcbiAgICAgICAgbWUucmVtb3ZlQWxsTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSAgICAgID0gbWUuY3VycmVudE5vZGVOYW1lLFxuICAgICAgICAgICAgY3RSZWN0ICAgID0gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LFxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gbWUubWF4SGVpZ2h0LFxuICAgICAgICAgICAgbWF4V2lkdGggID0gbWUubWF4V2lkdGgsXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBtZS5taW5IZWlnaHQsXG4gICAgICAgICAgICBtaW5XaWR0aCAgPSBtZS5taW5XaWR0aCxcbiAgICAgICAgICAgIHJlY3QgICAgICA9IG1lLmluaXRpYWxSZWN0LFxuICAgICAgICAgICAgZGlzdCwgc2l6ZSwgc3R5bGU7XG5cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBtZS5vbkRyYWdFbmQoe30pO1xuICAgICAgICB9IGVsc2UgaWYgKG1lLmRyYWdab25lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgc3R5bGUgPSBtZS5kcmFnWm9uZS5kcmFnUHJveHkud3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5pbmNsdWRlcygnYm90dG9tJykpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgobWluSGVpZ2h0LCBkYXRhLmNsaWVudFkgLSByZWN0LnRvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIGN0UmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7c2l6ZX1weGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaW5jbHVkZXMoJ3RvcCcpKSB7XG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGgubWluKHJlY3QuYm90dG9tIC0gbWluSGVpZ2h0LCBkYXRhLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1heChtaW5IZWlnaHQsIHJlY3QuaGVpZ2h0ICsgcmVjdC50b3AgLSBkYXRhLmNsaWVudFkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5tYXgoZGlzdCwgcmVjdC5ib3R0b20gLSBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLm1heChkaXN0LCBjdFJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIHJlY3QuYm90dG9tIC0gY3RSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7c2l6ZX1weGA7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wICAgID0gYCR7ZGlzdH1weGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmluY2x1ZGVzKCdsZWZ0JykpIHtcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5taW4ocmVjdC5yaWdodCAtIG1pbldpZHRoLCBkYXRhLmNsaWVudFgpO1xuICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1heChtaW5XaWR0aCwgcmVjdC53aWR0aCArIHJlY3QubGVmdCAtIGRhdGEuY2xpZW50WCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGgubWF4KGRpc3QsIHJlY3QucmlnaHQgLSBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5tYXgoZGlzdCwgY3RSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgcmVjdC5yaWdodCAtIGN0UmVjdC5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ICA9IGAke2Rpc3R9cHhgO1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gYCR7c2l6ZX1weGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaW5jbHVkZXMoJ3JpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgobWluV2lkdGgsIHJlY3Qud2lkdGggLSByZWN0LnJpZ2h0ICsgZGF0YS5jbGllbnRYKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIGN0UmVjdC5yaWdodCAtIHJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHtzaXplfXB4YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZHJhZ1pvbmUuZHJhZ1Byb3h5LndyYXBwZXJTdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbnRhaW5lcklkID0gbWUuYm91bmRhcnlDb250YWluZXJJZCxcbiAgICAgICAgICAgIGkgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gZGF0YS5wYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIG93bmVyICAgICAgID0gbWUub3duZXIsXG4gICAgICAgICAgICBzdHlsZSAgICAgICA9IG93bmVyLndyYXBwZXJTdHlsZSwgLy8gdG9kbzogZGVsZWdhdGlvbiB0YXJnZXRcbiAgICAgICAgICAgIHRhcmdldDtcblxuICAgICAgICBtZS5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC4zO1xuICAgICAgICBtZS5vd25lci53cmFwcGVyU3R5bGUgPSBzdHlsZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBkYXRhLnBhdGhbaV07XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQuY2xzLmluY2x1ZGVzKG1lLmRlbGVnYXRpb25DbHMpKSB7XG4gICAgICAgICAgICAgICAgbWUuaW5pdGlhbFJlY3QgPSB0YXJnZXQucmVjdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcklkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcklkID09PSAnZG9jdW1lbnQuYm9keScgJiYgdGFyZ2V0LnRhZ05hbWUgPT09ICdib2R5JyB8fCBjb250YWluZXJJZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCA9IHRhcmdldC5yZWN0O1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYXNzdW1pbmcgdGhhdCB0aGUgZHJhZ0VsIGlzIG5vdCBvdXRzaWRlIG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCkge1xuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdFxuICAgICAgICAgICAgfSkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QgPSByZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2V0U3R5bGUoe1xuICAgICAgICAgICAgaWQgICA6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgICAgIHN0eWxlOiB7Y3Vyc29yOiBgJHtSZXNpemFibGUuY3Vyc29yUG9zaXRpb25zW1Jlc2l6YWJsZS5wb3NpdGlvbnMuaW5kZXhPZihtZS5jdXJyZW50Tm9kZU5hbWUpXX0tcmVzaXplICFpbXBvcnRhbnRgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW1lLmRyYWdab25lKSB7XG4gICAgICAgICAgICBtZS5kcmFnWm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IERyYWdab25lLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgICA6IG93bmVyLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogb3duZXIuYm91bmRhcnlDb250YWluZXJJZCxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICAgICAgOiBvd25lci52ZG9tLFxuICAgICAgICAgICAgICAgIG1vdmVJbk1haW5UaHJlYWQgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG93bmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmRyYWdab25lLmJvdW5kYXJ5Q29udGFpbmVySWQgPSBvd25lci5ib3VuZGFyeUNvbnRhaW5lcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZHJhZ1pvbmUuZHJhZ1N0YXJ0KGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRpciAgPSBtZS5kaXJlY3Rpb25zLFxuICAgICAgICAgICAgaSAgICA9IDAsXG4gICAgICAgICAgICBnYXAgID0gbWUuZ2FwLFxuICAgICAgICAgICAgaCAgICA9IGZhbHNlLFxuICAgICAgICAgICAgbGVuICA9IGRhdGEucGF0aC5sZW5ndGgsXG4gICAgICAgICAgICB2ZG9tID0gbWUub3duZXIudmRvbSxcbiAgICAgICAgICAgIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHRhcmdldCwgdG9wO1xuXG4gICAgICAgIGlmICghbWUuaXNEcmFnZ2luZyAmJiAhbWUub3duZXIuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBhdGhbaV0uY2xzLmluY2x1ZGVzKG1lLmRlbGVnYXRpb25DbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRhdGEucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3R0b20gPSBkYXRhLmNsaWVudFkgPj0gdGFyZ2V0LnJlY3QueSAtIGdhcCArIHRhcmdldC5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgICA9IGRhdGEuY2xpZW50WCA8PSB0YXJnZXQucmVjdC54ICsgZ2FwO1xuICAgICAgICAgICAgcmlnaHQgID0gZGF0YS5jbGllbnRYID49IHRhcmdldC5yZWN0LnggLSBnYXAgKyB0YXJnZXQucmVjdC53aWR0aDtcbiAgICAgICAgICAgIHRvcCAgICA9IGRhdGEuY2xpZW50WSA8PSB0YXJnZXQucmVjdC55ICsgZ2FwO1xuXG4gICAgICAgICAgICBpZiAobWUubm9kZUJvdHRvbSAmJiAoIWJvdHRvbSB8fCBib3R0b20gJiYgbGVmdCAgfHwgYm90dG9tICYmIHJpZ2h0KSkge2ggPSBtZS5yZW1vdmVOb2RlKCdib3R0b20nKTt9XG4gICAgICAgICAgICBpZiAobWUubm9kZUxlZnQgICAmJiAoIWxlZnQgICB8fCBib3R0b20gJiYgbGVmdCAgfHwgdG9wICAgICYmIGxlZnQpKSAge2ggPSBtZS5yZW1vdmVOb2RlKCdsZWZ0Jyk7fVxuICAgICAgICAgICAgaWYgKG1lLm5vZGVSaWdodCAgJiYgKCFyaWdodCAgfHwgYm90dG9tICYmIHJpZ2h0IHx8IHRvcCAgICAmJiByaWdodCkpIHtoID0gbWUucmVtb3ZlTm9kZSgncmlnaHQnKTt9XG4gICAgICAgICAgICBpZiAobWUubm9kZVRvcCAgICAmJiAoIXRvcCAgICB8fCB0b3AgICAgJiYgbGVmdCAgfHwgdG9wICAgICYmIHJpZ2h0KSkge2ggPSBtZS5yZW1vdmVOb2RlKCd0b3AnKTt9XG5cbiAgICAgICAgICAgIGlmIChtZS5ub2RlQm90dG9tTGVmdCAgJiYgKCFib3R0b20gfHwgIWxlZnQpKSAge2ggPSBtZS5yZW1vdmVOb2RlKCdib3R0b20tbGVmdCcpO31cbiAgICAgICAgICAgIGlmIChtZS5ub2RlQm90dG9tUmlnaHQgJiYgKCFib3R0b20gfHwgIXJpZ2h0KSkge2ggPSBtZS5yZW1vdmVOb2RlKCdib3R0b20tcmlnaHQnKTt9XG4gICAgICAgICAgICBpZiAobWUubm9kZVRvcExlZnQgICAgICYmICghdG9wICAgIHx8ICFsZWZ0KSkgIHtoID0gbWUucmVtb3ZlTm9kZSgndG9wLWxlZnQnKTt9XG4gICAgICAgICAgICBpZiAobWUubm9kZVRvcFJpZ2h0ICAgICYmICghdG9wICAgIHx8ICFyaWdodCkpIHtoID0gbWUucmVtb3ZlTm9kZSgndG9wLXJpZ2h0Jyk7fVxuXG4gICAgICAgICAgICBpZiAgICAgIChkaXIuaW5jbHVkZXMoJ2JsJykgJiYgYm90dG9tICYmIGxlZnQpICB7aWYgKCFtZS5ub2RlQm90dG9tTGVmdCkgIHtoID0gbWUuYWRkTm9kZSgnYm90dG9tLWxlZnQnKTt9fVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyLmluY2x1ZGVzKCdicicpICYmIGJvdHRvbSAmJiByaWdodCkge2lmICghbWUubm9kZUJvdHRvbVJpZ2h0KSB7aCA9IG1lLmFkZE5vZGUoJ2JvdHRvbS1yaWdodCcpO319XG4gICAgICAgICAgICBlbHNlIGlmIChkaXIuaW5jbHVkZXMoJ3RsJykgJiYgdG9wICAgICYmIGxlZnQpICB7aWYgKCFtZS5ub2RlVG9wTGVmdCkgICAgIHtoID0gbWUuYWRkTm9kZSgndG9wLWxlZnQnKTt9fVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyLmluY2x1ZGVzKCd0cicpICYmIHRvcCAgICAmJiByaWdodCkge2lmICghbWUubm9kZVRvcFJpZ2h0KSAgICB7aCA9IG1lLmFkZE5vZGUoJ3RvcC1yaWdodCcpO319XG4gICAgICAgICAgICBlbHNlIGlmIChkaXIuaW5jbHVkZXMoJ2InKSAgJiYgYm90dG9tKSAgICAgICAgICB7aWYgKCFtZS5ub2RlQm90dG9tKSAgICAgIHtoID0gbWUuYWRkTm9kZSgnYm90dG9tJyk7fX1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpci5pbmNsdWRlcygnbCcpICAmJiBsZWZ0KSAgICAgICAgICAgIHtpZiAoIW1lLm5vZGVMZWZ0KSAgICAgICAge2ggPSBtZS5hZGROb2RlKCdsZWZ0Jyk7fX1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpci5pbmNsdWRlcygncicpICAmJiByaWdodCkgICAgICAgICAgIHtpZiAoIW1lLm5vZGVSaWdodCkgICAgICAge2ggPSBtZS5hZGROb2RlKCdyaWdodCcpO319XG4gICAgICAgICAgICBlbHNlIGlmIChkaXIuaW5jbHVkZXMoJ3QnKSAgJiYgdG9wKSAgICAgICAgICAgICB7aWYgKCFtZS5ub2RlVG9wKSAgICAgICAgIHtoID0gbWUuYWRkTm9kZSgndG9wJyk7fX1cblxuICAgICAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgICAgICBtZS5vd25lci52ZG9tID0gdmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgLy8gbGltaXQgdGhlIGV2ZW50IHRvIGRlbGVnYXRpb24gdGFyZ2V0c1xuICAgICAgICAgICAgaWYgKGRhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMobWUuZGVsZWdhdGlvbkNscykpIHtcbiAgICAgICAgICAgICAgICBtZS5yZW1vdmVBbGxOb2RlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgc2hvdWxkIGJlIG1heCAxIG5vZGUgKHJlc2l6ZSBoYW5kbGUpIGF0IGFueSBnaXZlbiB0aW1lLlxuICAgICAqIHNlZTogL2lzc3Vlcy8xMTM5XG4gICAgICovXG4gICAgcmVtb3ZlQWxsTm9kZXMoKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gPSBtZS5vd25lci52ZG9tO1xuXG4gICAgICAgIGlmIChtZS5jdXJyZW50Tm9kZU5hbWUpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZU5vZGUobWUuY3VycmVudE5vZGVOYW1lKTtcbiAgICAgICAgICAgIG1lLm93bmVyLnZkb20gPSB2ZG9tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIG5vZGUgZXhpc3RlZFxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZU5hbWUgPSAnbm9kZScgKyBOZW8uY2FwaXRhbGl6ZShuYW1lLnJlcGxhY2UoUmVzaXphYmxlLm5hbWVSZWdFeCwgKHN0ciwgbGV0dGVyKSA9PiBsZXR0ZXIudG9VcHBlckNhc2UoKSkpO1xuXG4gICAgICAgIGlmIChtZVtub2RlTmFtZV0pIHtcbiAgICAgICAgICAgIG1lLmN1cnJlbnROb2RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobWUub3duZXIuZ2V0VmRvbVJvb3QoKS5jbiwgbWVbbm9kZU5hbWVdKTtcbiAgICAgICAgICAgIG1lW25vZGVOYW1lXSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoUmVzaXphYmxlKTtcblxuZXhwb3J0IHtSZXNpemFibGUgYXMgZGVmYXVsdH07Il0sInNvdXJjZVJvb3QiOiIifQ==