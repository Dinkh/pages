"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_table_Container_mjs"],{

/***/ "./src/selection/table/RowModel.mjs":
/*!******************************************!*\
  !*** ./src/selection/table/RowModel.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Model.mjs */ "./src/selection/Model.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @class Neo.selection.table.RowModel
 * @extends Neo.selection.Model
 */
class RowModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.selection.table.RowModel'
         * @protected
         */
        className: 'Neo.selection.table.RowModel',
        /**
         * @member {String} ntype='selection-table-rowmodel'
         * @protected
         */
        ntype: 'selection-table-rowmodel',
        /**
         * @member {String} cls='selection-rowmodel'
         * @protected
         */
        cls: 'neo-selection-rowmodel'
    }}

    /**
     *
     */
    addDomListener() {
        let me           = this,
            view         = me.view,
            domListeners = view.domListeners;

        domListeners.push({
            click   : me.onRowClick,
            delegate: '.neo-table-row',
            scope   : me
        });

        view.domListeners = domListeners;
    }

    /**
     * Finds the matching table row for a given row index
     * @param {Number} index row index
     * @returns {String|null} The table row node id
     */
    getRowId(index) {
        if (index < 0 || this.view.store.getCount() < index) {
            return null;
        }

        return this.view.vdom.cn[0].cn[1].cn[index].id;
    }

    /**
     * Finds the matching table row for a given event path
     * @param {Object} path The event path
     * @returns {Object|null} The node containing the table row class or null
     * @protected
     */
    static getRowNode(path) {
        let i    = 0,
            len  = path.length,
            node = null;

        for (; i < len; i++) {
            if (path[i].cls.includes('neo-table-row')) {
                node = path[i];
            }
        }

        return node;
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        this.onNavKeyRow(data, 1);
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        this.onNavKeyRow(data, -1);
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKeyRow(data, step) {
        let me         = this,
            node       = RowModel.getRowNode(data.path),
            view       = me.view,
            store      = view.store,
            vdomNode   = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].findVdomChild(view.vdom, node.id),
            newIndex   = (vdomNode.index + step) % store.getCount(),
            parentNode = vdomNode.parentNode,
            id;

        while (newIndex < 0) {
            newIndex += store.getCount();
        }

        id = parentNode.cn[newIndex].id;

        if (id) {
            me.select(id);
            view.focus(id);

            view.fire('select', {
                record: store.getAt(newIndex)
            });
        }
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        let me   = this,
            node = RowModel.getRowNode(data.path),
            id   = node && node.id,
            view = me.view,
            isSelected, record;

        if (id) {
            me.toggleSelection(id);

            isSelected = me.isSelected(id);
            record     = view.store.getAt(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].findVdomChild(view.vdom, id).index);

            !isSelected && view.onDeselect?.(record);

            view.fire(isSelected ? 'select' : 'deselect', {
                record: record
            });
        }
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me   = this,
            id   = me.id,
            view = me.view;

        if (view.keys) {
            view.keys._keys.push({
                fn   : 'onKeyDownDown',
                key  : 'Down',
                scope: id
            }, {
                fn   : 'onKeyDownUp',
                key  : 'Up',
                scope: id
            });
        }
    }

    /**
     *
     */
    unregister() {
        let me   = this,
            id   = me.id,
            view = me.view;

        if (view.keys) {
            view.keys.removeKeys([{
                fn   : 'onKeyDownDown',
                key  : 'Down',
                scope: id
            }, {
                fn   : 'onKeyDownUp',
                key  : 'Up',
                scope: id
            }]);
        }

        super.unregister();
    }
}

Neo.applyClassConfig(RowModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RowModel);


/***/ }),

/***/ "./src/table/Container.mjs":
/*!*********************************!*\
  !*** ./src/table/Container.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Css_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Css.mjs */ "./src/util/Css.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_table_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/table/RowModel.mjs */ "./src/selection/table/RowModel.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _View_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./View.mjs */ "./src/table/View.mjs");
/* harmony import */ var _header_export_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./header/_export.mjs */ "./src/table/header/_export.mjs");









/**
 * @class Neo.table.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.table.Container'
         * @protected
         */
        className: 'Neo.table.Container',
        /**
         * @member {String} ntype='table-container'
         * @protected
         */
        ntype: 'table-container',
        /**
         * todo: testing config, remove when Stores are ready
         * @member {Number} amountRows=20
         */
        amountRows: 20,
        /**
         * Default configs for each column
         * @member {Object} columnDefaults=null
         */
        columnDefaults: null,
        /**
         * todo: testing config, remove when Stores are ready
         * @member {Boolean} createRandomData=false
         */
        createRandomData: false,
        /**
         * @member {Array} cls=['neo-table-container']
         */
        cls: ['neo-table-container'],
        /**
         * @member {Array} columns_=[]
         */
        columns_: [],
        /**
         * Configs for Neo.table.header.Toolbar
         * @member {Object|null} [headerToolbarConfig=null]
         */
        headerToolbarConfig: null,
        /**
         * @member {String|null} headerToolbarId_=null
         */
        headerToolbarId_: null,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * @member {String} layout='base'
         */
        layout: 'base',
        /**
         * @member {Boolean} scrollbarsCssApplied=false
         * @protected
         */
        scrollbarsCssApplied: false,
        /**
         * @member {Neo.selection.Model} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * @member {Neo.data.Store} store_=null
         */
        store_: null,
        /**
         * todo: only works for chrome & safari -> add a check
         * @member {Boolean} useCustomScrollbars_=true
         */
        useCustomScrollbars_: true,
        /**
         * Configs for Neo.table.View
         * @member {Object|null} [viewConfig=null]
         */
        viewConfig: null,
        /**
         * @member {String|null} viewId_=null
         * @protected
         */
        viewId_: null,
        /**
         * @member {Array|null} items=null
         * @protected
         */
        items: null,
        /**
         * @member {Object} _vdom={cls: ['neo-table-wrapper'],cn : [{tag: 'table',cn : []}]}
         */
        _vdom:
        {cls: ['neo-table-wrapper'], cn: [
            {tag: 'table', cn: []}
        ]}
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.headerToolbarId = Neo.getId('table-header-toolbar');
        me.viewId          = Neo.getId('table-view');

        me.items = [{
            module           : _header_export_mjs__WEBPACK_IMPORTED_MODULE_7__.Toolbar,
            id               : me.headerToolbarId,
            showHeaderFilters: me.showHeaderFilters,
            ...me.headerToolbarConfig
        }, {
            module         : _View_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
            containerId    : me.id,
            id             : me.viewId,
            store          : me.store,
            useRowRecordIds: !me.createRandomData,
            ...me.viewConfig
        }];

        me.vdom.id = me.id + 'wrapper';

        me.createColumns(me.columns);
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        if (this.rendered) {
            value.register(this);
        }
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            Neo.getComponent(this.headerToolbarId).showHeaderFilters = value;
        }
    }

    /**
     * Triggered after the useCustomScrollbars config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseCustomScrollbars(value, oldValue) {
        if (value === true) {
            this.vdom.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(this.vdom.cls, ['neo-use-custom-scrollbar']);
        }
    }

    /**
     * @protected
     */
    applyCustomScrollbarsCss() {
        let me       = this,
            cssRules = [];

        if (me.dockLeftMargin) {
            cssRules.push('#' + me.id + 'wrapper' + '::-webkit-scrollbar-track:horizontal {margin-left: ' + me.dockLeftMargin + 'px;}');
        }

        if (me.dockRightMargin) {
            cssRules.push('#' + me.id + 'wrapper' + '::-webkit-scrollbar-track:horizontal {margin-right: ' + me.dockRightMargin + 'px;}');
        }
        if (cssRules.length > 0) {
            _util_Css_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].insertRules(cssRules);
        }

        me.scrollbarsCssApplied = true;
    }

    /**
     * Triggered before the columns config gets changed.
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetColumns(value, oldValue) {
        if (this.configsApplied) {
            return this.createColumns(value);
        }

        return value;
    }

    /**
     * Triggered before the headerToolbarId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetHeaderToolbarId(value, oldValue) {
        return value ? value : oldValue;
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        if (oldValue) {
            oldValue.destroy();
        }

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _selection_table_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    beforeSetStore(value, oldValue) {
        if (oldValue) {
            oldValue.destroy();
        }

        if (value) {
            let me = this;

            const listeners = {
                filter      : me.onStoreFilter,
                load        : me.onStoreLoad,
                recordChange: me.onStoreRecordChange,
                scope       : me
            };

            if (value instanceof _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]) {
                value.on(listeners);

                if (value.getCount() > 0) {
                    me.onStoreLoad(value.items);
                }
            } else {
                value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], {
                    listeners: listeners
                });
            }

            // in case we dynamically change the store, the view needs to get the new reference
            if (me.view) {
                me.view.store = value;
            }
        }

        return value;
    }

    /**
     * Triggered before the viewId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetViewId(value, oldValue) {
        return value ? value : oldValue;
    }

    /**
     * @param columns
     * @returns {*}
     */
    createColumns(columns) {
        let me             = this,
            columnDefaults = me.columnDefaults,
            sorters        = me.store?.sorters;

        if (!columns || !columns.length) {
            Neo.logError('Attempting to create a table.Container without defined columns', me.id);
        }

        columns.forEach(column => {
            if (column.dock && !column.width) {
                Neo.logError('Attempting to create a docked column without a defined width', column, me.id);
            }

            if (columnDefaults) {
                Neo.assignDefaults(column, columnDefaults);
            }

            if (sorters?.[0]) {
                if (column.dataField === sorters[0].property) {
                    column.isSorted = sorters[0].direction;
                }
            }

            column.listeners = {
                sort : me.onSortColumn,
                scope: me
            };
        });

        me.items[0].items = columns;

        return columns;
    }

    /**
     * @param {Number} countRows
     */
    createRandomViewData(countRows) {
        this.loadData(countRows);
    }

    /**
     * @param {Array} inputData
     */
    createViewData(inputData) {
        let me    = this,
            items = me.items;

        items[1].createViewData(inputData); // todo: save a reference to the view & headerContainer

        if (me.useCustomScrollbars && me.scrollbarsCssApplied === false) {
            me.applyCustomScrollbarsCss();
        }

        me.items = items;
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0];
    }

    /**
     * @returns {Neo.table.View}
     */
    getView() {
        return Neo.getComponent(this.viewId) || Neo.get(this.viewId);
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0];
    }

    /**
     * @param {Number} countRows
     */
    loadData(countRows) {
        let me           = this,
            columns      = me.items[0].items,
            countColumns = columns.length;

        Neo.manager.Store.createRandomData([countColumns, countRows]).then(data => {
            me.createViewData(data);
        });
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.selectionModel) {
            me.selectionModel.register(me);
        }

        if (me.createRandomData) {
            // todo: if mounting apply after mount
            setTimeout(() => {
                me.createRandomViewData(me.amountRows);
            }, 50);
        }
    }

    /**
     * @param {Object} opts
     * @param {String} opts.direction
     * @param {String} opts.property
     * @protected
     */
    onSortColumn(opts) {
        let me = this;

        me.store.sort(opts);
        me.removeSortingCss(opts.property);
        me.onStoreLoad(me.store.items);
    }

    /**
     *
     */
    onStoreFilter() {
        this.onStoreLoad(this.store.items);
    }

    /**
     * @param {Array} data
     * @protected
     */
    onStoreLoad(data) {
        let me = this,
            listenerId;

        if (me.rendered) {
            me.createViewData(data);

            if (me.store.sorters.length < 1) {
                me.removeSortingCss();
            }
        } else {
            listenerId = me.on('rendered', () => {
                me.un('rendered', listenerId);
                setTimeout(() => {
                    me.createViewData(data);
                }, 50);
            });
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {String} opts.field The name of the field which got changed
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {*} opts.oldValue
     * @param {Object} opts.record
     * @param {*} opts.value
     */
    onStoreRecordChange(opts) {
        Neo.getComponent(this.viewId).onStoreRecordChange(opts);
    }

    /**
     * @param {String} dataField
     * @protected
     */
    removeSortingCss(dataField) {
        this.items[0].items.forEach(column => {
            if (column.dataField !== dataField) {
                column.removeSortingCss();
            }
        });
    }
}

Neo.applyClassConfig(Container);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Container);


/***/ }),

/***/ "./src/table/View.mjs":
/*!****************************!*\
  !*** ./src/table/View.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.table.View
 * @extends Neo.component.Base
 */
class View extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.table.View'
         * @protected
         */
        className: 'Neo.table.View',
        /**
         * @member {String} ntype='table-view'
         * @protected
         */
        ntype: 'table-view',
        /**
         * @member {Array} cls=['neo-table-view']
         */
        cls: ['neo-table-view'],
        /**
         * @member {String|null} containerId=null
         * @protected
         */
        containerId: null,
        /**
         * @member {Object} recordVnodeMap={}
         */
        recordVnodeMap: {},
        /**
         * @member {Neo.data.Store|null} store=null
         */
        store: null,
        /**
         * @member {Boolean} useRowRecordIds=true
         */
        useRowRecordIds: true,
        /**
         * @member {Object} _vdom={tag: 'tbody', cn : []}
         */
        _vdom:
        {tag: 'tbody', cn: []}
    }}

    /**
     * @param {Array} inputData
     */
    createViewData(inputData) {
        let me         = this,
            amountRows = inputData.length,
            container  = Neo.getComponent(me.parentId),
            hasStore   = container.store?.model, // todo: remove as soon as all tables use stores (examples table)
            columns    = container.items[0].items,
            colCount   = columns.length,
            data       = [],
            i          = 0,
            vdom       = me.vdom,
            cellCls, cellId, config, column, dockLeftMargin, dockRightMargin, id, index, j, rendererOutput,
            record, rendererValue, selectedRows, trCls;

        me.recordVnodeMap = {}; // remove old data

        // console.log('createViewData', me.id, inputData);

        if (container.selectionModel.ntype === 'selection-table-rowmodel') {
            selectedRows = container.selectionModel.items || [];
        }

        for (; i < amountRows; i++) {
            record = inputData[i];
            id = me.getRowId(record, i);

            me.recordVnodeMap[id] = i;

            trCls = me.getTrClass(record, i);

            if (selectedRows?.includes(id)) {
                trCls.push('neo-selected');

                Neo.getComponent(me.containerId).fire('select', {
                    record: record
                });
            }

            data.push({
                tag     : 'tr',
                id      : id,
                cls     : trCls,
                cn      : [],
                tabIndex: '-1'
            });

            dockLeftMargin  = 0;
            dockRightMargin = 0;

            j = 0;

            for (; j < colCount; j++) {
                column         = columns[j];
                rendererValue  = record[column.dataField];

                if (rendererValue === undefined) {
                    rendererValue = '';
                }

                rendererOutput = column.renderer.call(column.rendererScope || container, {
                    dataField: column.dataField,
                    index    : i,
                    record   : record,
                    value    : rendererValue
                });

                cellCls = rendererOutput?.cls || ['neo-table-cell'];

                if (column.align !== 'left') {
                    cellCls.push('neo-' + column.align);
                }

                if (!Neo.isObject(rendererOutput)) {
                    rendererOutput = {
                        cls : cellCls,
                        html: rendererOutput?.toString()
                    };
                }

                // todo: remove the if part as soon as all tables use stores (examples table)
                if (hasStore) {
                    cellId = me.getCellId(record, column.dataField);
                } else {
                    cellId = vdom.cn[i]?.cn[j]?.id || Neo.getId('td');
                }

                config = {
                    tag      : 'td',
                    id       : cellId,
                    cls      : rendererOutput.cls   || ['neo-table-cell'],
                    innerHTML: rendererOutput.html  || '',
                    style    : rendererOutput.style || {},
                    tabIndex : '-1'
                };

                if (column.dock) {
                    config.cls = ['neo-locked', ...config.cls || []];

                    if (column.dock === 'left') {
                        config.style.left = dockLeftMargin + 'px';
                        dockLeftMargin += (column.width + 1); // todo: borders fix
                    }
                }

                if (column.flex) {
                    config.style.width = '100%';
                }

                data[i].cn.push(config);
            }

            j = 0;

            for (; j < colCount; j++) {
                index  = colCount - j -1;
                column = columns[index];

                if (column.dock === 'right') {
                    data[i].cn[index].style.right = dockRightMargin + 'px';
                    dockRightMargin += (column.width + 1); // todo: borders fix
                }
            }
        }

        vdom.cn = data;

        container.dockLeftMargin  = dockLeftMargin;
        container.dockRightMargin = dockRightMargin;

        me.promiseVdomUpdate().then(() => {
            if (selectedRows?.length > 0) {
                // this logic only works for selection.table.RowModel
                Neo.main.DomAccess.scrollToTableRow({id: selectedRows[0]});
            }
        });
    }

    /**
     * @param {Boolean} updateParentVdom
     * @param {Boolean} silent
     */
    destroy(updateParentVdom, silent) {
        this.store = null;
        super.destroy(updateParentVdom, silent);
    }

    /**
     * @param {Object} record
     * @param {String} dataField
     * @returns {String}
     */
    getCellId(record, dataField) {
        return this.id + '__' + record[this.store.keyProperty] + '__' + dataField;
    }

    /**
     * @param {String} rowId
     * @returns {Object}
     */
    getRecordByRowId(rowId) {
        return this.store.getAt(this.recordVnodeMap[rowId]);
    }

    /**
     * @param {Object} record
     * @param {Number} [index]
     * @returns {String}
     */
    getRowId(record, index) {
        let me    = this,
            store = me.store;

        if (me.useRowRecordIds) {
            return `${me.id}__tr__${record[store.keyProperty]}`;
        } else {
            index = Neo.isNumber(index) ? index : store.indexOf(record);
            return me.vdom.cn[index]?.id || Neo.getId('tr');
        }
    }

    /**
     * Override this method to apply custom CSS rules to table rows
     * @param {Object} record
     * @param {Number} rowIndex
     * @returns {String[]}
     */
    getTrClass(record, rowIndex) {
        return ['neo-table-row'];
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onStoreRecordChange(opts) {
        let me     = this,
            deltas = [],
            cellId, cellNode;

        opts.fields.forEach(field => {
            cellId   = me.getCellId(opts.record, field.name);
            cellNode = me.getVdomChild(cellId);

            cellNode.innerHTML = field.value; // keep the vdom in sync

            deltas.push({
                id       : cellId,
                innerHTML: field.value
            })
        });

        deltas.length > 0 && Neo.applyDeltas(me.appName, deltas);
    }
}

Neo.applyClassConfig(View);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);


/***/ }),

/***/ "./src/table/header/Button.mjs":
/*!*************************************!*\
  !*** ./src/table/header/Button.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");




/**
 * @class Neo.table.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getStaticConfig() {return {
        /**
         * Valid values for align
         * @member {String[]} alignValues: ['left', 'center', 'right']
         * @protected
         * @static
         */
        alignValues: ['left', 'center', 'right']
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.table.header.Button'
         * @protected
         */
        className: 'Neo.table.header.Button',
        /**
         * @member {String} ntype='table-header-button'
         * @protected
         */
        ntype: 'table-header-button',
        /**
         * Alignment of the matching table cells. Valid values are left, center, right
         * @member {String} align_='left'
         */
        align_: 'left',
        /**
         * @member {Array} cls=['neo-table-header-button']
         */
        cls: ['neo-table-header-button'],
        /**
         * @member {String|null} dataField=null
         */
        dataField: null,
        /**
         * Sort direction when clicking on an unsorted button
         * @member {String} defaultSortDirection='ASC'
         */
        defaultSortDirection: 'ASC',
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * @member {Object} editorConfig=null
         */
        editorConfig: null,
        /**
         * @member {Object} filterConfig=null
         */
        filterConfig: null,
        /**
         * @member {Neo.form.field.Base|null} filterField=null
         * @protected
         */
        filterField: null,
        /**
         * @member {String} iconCls='fa fa-arrow-circle-up'
         */
        iconCls: 'fa fa-arrow-circle-up',
        /**
         * @member {String} iconPosition='right'
         */
        iconPosition: 'right',
        /**
         * 'ASC', 'DESC' or null
         * @member {String|null} isSorted_=null
         * @protected
         */
        isSorted_: null,
        /**
         * Scope to execute the column renderer.
         * Defaults to the matching table.Container
         * @member {Neo.core.Base|null} rendererScope=null
         */
        rendererScope: null,
        /**
         * @member {Boolean} showHeaderFilter_=false
         */
        showHeaderFilter_: false,
        /**
         * @member {String} _vdom
         */
        _vdom:
        {tag: 'th', cn: [
            {tag: 'button', cn: [
                {tag: 'span', cls: ['neo-button-glyph']},
                {tag: 'span', cls: ['neo-button-text']}
            ]}
        ]}
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me        = this,
            listeners = {
                click: me.onButtonClick,
                scope: me
            };

        if (me.draggable) {
            Object.assign(listeners, {
                dragend  : me.onDragEnd,
                dragenter: me.onDragEnter,
                dragleave: me.onDragLeave,
                dragover : me.onDragOver,
                dragstart: me.onDragStart,
                drop     : me.onDrop,
            });
        }

        me.domListeners = listeners;
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me   = this,
            vdom = me.vdom;

        if (value === true) {
            me.getVdomRoot().draggable = true;
        } else {
            delete me.getVdomRoot().draggable;
        }

        me.vdom = vdom;
    }

    /**
     * Triggered after the isSorted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsSorted(value, oldValue) {
        let me        = this,
            cls       = me.cls,
            container = me.up('table-container');

        switch(value) {
            case null:
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');
                break;
            case 'ASC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-desc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-asc');
                break;
            case 'DESC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-asc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-desc');
                break;
        }

        me.cls = cls;

        // testing check until all example tables have a store
        if (!container || !container.store) {
            return;
        }

        me.mounted && me.fire('sort', {
            direction: value,
            property : me.dataField
        });
    }

    /**
     * Triggered after the showHeaderFilter config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilter(value, oldValue) {
        let me   = this,
            vdom = me.vdom;

        if (value) {
            if (!me.filterField) {
                me.filterField = Neo.create({
                    module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                    appName  : me.appName,
                    flag     : 'filter-field',
                    hideLabel: true,
                    parentId : me.id,

                    listeners: {
                        change        : me.changeFilterValue,
                        operatorChange: me.changeFilterOperator,
                        scope         : me
                    },

                    style: {
                        marginLeft : '.5em',
                        marginRight: '.5em'
                    },
                    ...me.editorConfig
                });

                me.vdom.cn.push(me.filterField.vdom);
            } else {
                delete me.filterField.vdom.removeDom;
            }
        } else if (me.filterField) {
            me.filterField.vdom.removeDom = true;
        }

        me.vdom = vdom;
    }

    /**
     * Triggered before the align config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'align', 'alignValues');
    }

    /**
     *
     */
    destroy(...args) {
        this.filterField?.destroy();

        super.destroy(...args);
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[0];
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0];
    }

    /**
     * @protected
     */
    onButtonClick() {
        let me = this,
            map;

        if (me.defaultSortDirection === 'DESC') {
            map = {
                ASC : null,
                DESC: 'ASC',
                null: 'DESC'
            };
        } else {
            map = {
                ASC : 'DESC',
                DESC: null,
                null: 'ASC'
            };
        }

        me.isSorted = map[me.isSorted + ''];
    }

    /**
     * @protected
     */
    onDragEnd() {
        let me    = this,
            style = me.style;

        delete style.opacity;
        me.style = style;
    }

    /**
     * @protected
     */
    onDragEnter() {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-drag-over');
        me.cls = cls;
    }

    /**
     * @protected
     */
    onDragLeave() {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-drag-over');
        me.cls = cls;
    }

    /**
     * @param {Object} event
     */
    onDragOver(event) {
        //console.log('onDragOver', event);
    }

    /**
     * @protected
     */
    onDragStart() {
        let me    = this,
            style = me.style;

        style.opacity = 0.4;
        me.style = style;
    }

    /**
     * @param {Object} data
     */
    onDrop(data) {
        let me             = this,
            headerToolbar  = Neo.getComponent(me.parentId),
            style          = me.style,
            tableContainer = Neo.getComponent(headerToolbar.parentId);

        me.onDragLeave();
        headerToolbar.switchItems(me.id, data.srcId);
        tableContainer.createViewData(tableContainer.store.data);

        style.opacity = 1;
        me.style = style;
    }

    /**
     * @param {Object} data
     */
    changeFilterOperator(data) {
        let me             = this,
            tableContainer = me.up('table-container'),
            store          = tableContainer?.store,
            operator       = data.value,
            filter, filters;

        if (store) {
            filter = store.getFilter(me.dataField);

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator,
                    value   : null,
                    ...me.filterConfig
                });

                store.filters = filters;
            } else {
                filter.operator = operator;
            }
        }
    }

    /**
     * @param {Object} data
     */
    changeFilterValue(data) {
        let me             = this,
            tableContainer = me.up('table-container'),
            store          = tableContainer?.store,
            value          = data.value,
            field, filter, filters, model;

        if (store) {
            filter = store.getFilter(me.dataField);
            model  = store.model;
            field  = model && model.getField(me.dataField);

            if (value && field.type.toLowerCase() === 'date') {
                value = new Date(value);
            }

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator: 'like',
                    value,
                    ...me.filterConfig
                });

                store.filters = filters;
            } else {
                filter.value = value;
            }
        }
    }

    /**
     * @protected
     */
    removeSortingCss() {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

        me.cls       = cls;
        me._isSorted = null;
    }

    /**
     * @param {Object} data
     * @param {String} data.dataField
     * @param {Number} data.index
     * @param {Object} data.record
     * @param {Number|String} data.value
     * @returns {*}
     */
    renderer(data) {
        return data.value;
    }
}

Neo.applyClassConfig(Button);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Button);


/***/ }),

/***/ "./src/table/header/Toolbar.mjs":
/*!**************************************!*\
  !*** ./src/table/header/Toolbar.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.table.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.table.header.Toolbar'
         * @protected
         */
        className: 'Neo.table.header.Toolbar',
        /**
         * @member {String} ntype='table-header-toolbar'
         * @protected
         */
        ntype: 'table-header-toolbar',
        /**
         * @member {Array} cls=['table-header-toolbar']
         */
        cls: ['table-header-toolbar'],
        /**
         * @member {String} layout='base'
         */
        layout: 'base',
        /**
         * @member {Object} itemDefaults={ntype : 'table-header-button'}
         */
        itemDefaults: {
            ntype : 'table-header-button'
        },
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * @member {Object} _vdom={tag: 'thead',cn : [{tag: 'tr',cn : []}]}
         */
        _vdom:
        {tag: 'thead', cn: [
            {tag: 'tr', cn: []}
        ]}
    }}

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            let me   = this,
                vdom = me.vdom;

            me.items.forEach(item => {
                item.setSilent({
                    showHeaderFilter: value
                });
            });

            me.vdom = vdom;
        }
    }

    /**
     *
     */
    createItems() {
        let me = this;

        me.itemDefaults.showHeaderFilter = me.showHeaderFilters;

        super.createItems();

        let dockLeftWidth  = 0,
            dockRightWidth = 0,
            items          = me.items,
            len            = items.length,
            vdom           = me.vdom,
            style;

        items.forEach((item, index) => {
            style = item.wrapperStyle;

            // todo: only add px if number
            if (item.maxWidth) {style.maxWidth = item.maxWidth + 'px'}
            if (item.minWidth) {style.minWidth = item.minWidth + 'px'}
            if (item.width)    {style.width    = item.width    + 'px'}

            if (item.dock) {
                item.vdom.cls = ['neo-locked'];

                if (item.dock === 'left') {
                    style.left = dockLeftWidth + 'px';
                }

                dockLeftWidth += (item.width + 1); // todo: borders fix
            } else {
                item.vdom.cls = []; // remove the button cls from the th tag
            }

            item.wrapperStyle = style;

            // inverse loop direction
            item = items[len - index -1];

            if (item.dock === 'right') {
                style = item.wrapperStyle;
                style.right = dockRightWidth + 'px';

                item.wrapperStyle = style;

                dockRightWidth += (item.width + 1); // todo: borders fix
            }
        });

        me.vdom = vdom;
    }

    /**
     * @param {String} dock
     * @returns {String} layoutConfig
     * @override
     */
    getLayoutConfig(dock) {
        return 'base';
    }

    /**
     * Specify a different vdom items root if needed (useful in case this container uses a wrapper node).
     * @returns {Object} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.vdom.cn[0].cn;
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[0];
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0];
    }
}

Neo.applyClassConfig(Toolbar);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toolbar);


/***/ }),

/***/ "./src/table/header/_export.mjs":
/*!**************************************!*\
  !*** ./src/table/header/_export.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Button": () => (/* reexport safe */ _Button_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "Toolbar": () => (/* reexport safe */ _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ "./src/table/header/Button.mjs");
/* harmony import */ var _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Toolbar.mjs */ "./src/table/header/Toolbar.mjs");





/***/ }),

/***/ "./src/util/Css.mjs":
/*!**************************!*\
  !*** ./src/util/Css.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Css
 * @extends Neo.core.Base
 */
class Css extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.util.Css'
         * @protected
         */
        className: 'Neo.util.Css'
    }}

    /**
     * Pass the selectorText of the rules which you want to remove
     * @param {String[]|String} rules
     */
    static deleteRules(rules) {
        if (!Array.isArray(rules)) {
            rules = [rules];
        }

        Neo.main.addon.Stylesheet.deleteCssRules({
            rules: rules
        });
    }

    /**
     * @param {String[]|String} rules
     */
    static insertRules(rules) {
        if (!Array.isArray(rules)) {
            rules = [rules];
        }

        Neo.main.addon.Stylesheet.insertCssRules({
            rules: rules
        });
    }
}

Neo.applyClassConfig(Css);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Css);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNPOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBSztBQUM1Qix3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRUFBc0I7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FB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QTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLE9BQU8sRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0pZO0FBQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDREE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFJO0FBQ3RCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxHQUFHLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi90YWJsZS9Sb3dNb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWJsZS9Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFibGUvVmlldy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWJsZS9oZWFkZXIvQnV0dG9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3RhYmxlL2hlYWRlci9Ub29sYmFyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3RhYmxlL2hlYWRlci9fZXhwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvQ3NzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTW9kZWwgICAgZnJvbSAnLi4vTW9kZWwubWpzJztcbmltcG9ydCBWRG9tVXRpbCBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi50YWJsZS5Sb3dNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICovXG5jbGFzcyBSb3dNb2RlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi50YWJsZS5Sb3dNb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi50YWJsZS5Sb3dNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tdGFibGUtcm93bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLXRhYmxlLXJvd21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xzPSdzZWxlY3Rpb24tcm93bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsczogJ25lby1zZWxlY3Rpb24tcm93bW9kZWwnXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmlldyAgICAgICAgID0gbWUudmlldyxcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IHZpZXcuZG9tTGlzdGVuZXJzO1xuXG4gICAgICAgIGRvbUxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgIGNsaWNrICAgOiBtZS5vblJvd0NsaWNrLFxuICAgICAgICAgICAgZGVsZWdhdGU6ICcubmVvLXRhYmxlLXJvdycsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlldy5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG1hdGNoaW5nIHRhYmxlIHJvdyBmb3IgYSBnaXZlbiByb3cgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggcm93IGluZGV4XG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBUaGUgdGFibGUgcm93IG5vZGUgaWRcbiAgICAgKi9cbiAgICBnZXRSb3dJZChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMudmlldy5zdG9yZS5nZXRDb3VudCgpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy52ZG9tLmNuWzBdLmNuWzFdLmNuW2luZGV4XS5pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWF0Y2hpbmcgdGFibGUgcm93IGZvciBhIGdpdmVuIGV2ZW50IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF0aCBUaGUgZXZlbnQgcGF0aFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIG5vZGUgY29udGFpbmluZyB0aGUgdGFibGUgcm93IGNsYXNzIG9yIG51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvd05vZGUocGF0aCkge1xuICAgICAgICBsZXQgaSAgICA9IDAsXG4gICAgICAgICAgICBsZW4gID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBub2RlID0gbnVsbDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jbHMuaW5jbHVkZXMoJ25lby10YWJsZS1yb3cnKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Eb3duKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbk5hdktleVJvdyhkYXRhLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blVwKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbk5hdktleVJvdyhkYXRhLCAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5Um93KGRhdGEsIHN0ZXApIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSAgICAgICA9IFJvd01vZGVsLmdldFJvd05vZGUoZGF0YS5wYXRoKSxcbiAgICAgICAgICAgIHZpZXcgICAgICAgPSBtZS52aWV3LFxuICAgICAgICAgICAgc3RvcmUgICAgICA9IHZpZXcuc3RvcmUsXG4gICAgICAgICAgICB2ZG9tTm9kZSAgID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZCh2aWV3LnZkb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgbmV3SW5kZXggICA9ICh2ZG9tTm9kZS5pbmRleCArIHN0ZXApICUgc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB2ZG9tTm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgaWQ7XG5cbiAgICAgICAgd2hpbGUgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgbmV3SW5kZXggKz0gc3RvcmUuZ2V0Q291bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkID0gcGFyZW50Tm9kZS5jbltuZXdJbmRleF0uaWQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3QoaWQpO1xuICAgICAgICAgICAgdmlldy5mb2N1cyhpZCk7XG5cbiAgICAgICAgICAgIHZpZXcuZmlyZSgnc2VsZWN0Jywge1xuICAgICAgICAgICAgICAgIHJlY29yZDogc3RvcmUuZ2V0QXQobmV3SW5kZXgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3dDbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBSb3dNb2RlbC5nZXRSb3dOb2RlKGRhdGEucGF0aCksXG4gICAgICAgICAgICBpZCAgID0gbm9kZSAmJiBub2RlLmlkLFxuICAgICAgICAgICAgdmlldyA9IG1lLnZpZXcsXG4gICAgICAgICAgICBpc1NlbGVjdGVkLCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBtZS50b2dnbGVTZWxlY3Rpb24oaWQpO1xuXG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gbWUuaXNTZWxlY3RlZChpZCk7XG4gICAgICAgICAgICByZWNvcmQgICAgID0gdmlldy5zdG9yZS5nZXRBdChWRG9tVXRpbC5maW5kVmRvbUNoaWxkKHZpZXcudmRvbSwgaWQpLmluZGV4KTtcblxuICAgICAgICAgICAgIWlzU2VsZWN0ZWQgJiYgdmlldy5vbkRlc2VsZWN0Py4ocmVjb3JkKTtcblxuICAgICAgICAgICAgdmlldy5maXJlKGlzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICdkZXNlbGVjdCcsIHtcbiAgICAgICAgICAgICAgICByZWNvcmQ6IHJlY29yZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKGNvbXBvbmVudCk7XG5cbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICA9IG1lLmlkLFxuICAgICAgICAgICAgdmlldyA9IG1lLnZpZXc7XG5cbiAgICAgICAgaWYgKHZpZXcua2V5cykge1xuICAgICAgICAgICAgdmlldy5rZXlzLl9rZXlzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZuICAgOiAnb25LZXlEb3duRG93bicsXG4gICAgICAgICAgICAgICAga2V5ICA6ICdEb3duJyxcbiAgICAgICAgICAgICAgICBzY29wZTogaWRcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBmbiAgIDogJ29uS2V5RG93blVwJyxcbiAgICAgICAgICAgICAgICBrZXkgIDogJ1VwJyxcbiAgICAgICAgICAgICAgICBzY29wZTogaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgID0gbWUuaWQsXG4gICAgICAgICAgICB2aWV3ID0gbWUudmlldztcblxuICAgICAgICBpZiAodmlldy5rZXlzKSB7XG4gICAgICAgICAgICB2aWV3LmtleXMucmVtb3ZlS2V5cyhbe1xuICAgICAgICAgICAgICAgIGZuICAgOiAnb25LZXlEb3duRG93bicsXG4gICAgICAgICAgICAgICAga2V5ICA6ICdEb3duJyxcbiAgICAgICAgICAgICAgICBzY29wZTogaWRcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBmbiAgIDogJ29uS2V5RG93blVwJyxcbiAgICAgICAgICAgICAgICBrZXkgIDogJ1VwJyxcbiAgICAgICAgICAgICAgICBzY29wZTogaWRcbiAgICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFJvd01vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgUm93TW9kZWw7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDc3MgICAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9Dc3MubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFJvd01vZGVsICAgICAgICBmcm9tICcuLi9zZWxlY3Rpb24vdGFibGUvUm93TW9kZWwubWpzJztcbmltcG9ydCBTdG9yZSAgICAgICAgICAgZnJvbSAnLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZpZXcgICAgICAgICAgICBmcm9tICcuL1ZpZXcubWpzJztcbmltcG9ydCAqIGFzIGhlYWRlciBmcm9tICcuL2hlYWRlci9fZXhwb3J0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby50YWJsZS5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYmxlLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYmxlLkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWJsZS1jb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFibGUtY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZG86IHRlc3RpbmcgY29uZmlnLCByZW1vdmUgd2hlbiBTdG9yZXMgYXJlIHJlYWR5XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYW1vdW50Um93cz0yMFxuICAgICAgICAgKi9cbiAgICAgICAgYW1vdW50Um93czogMjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGNvbmZpZ3MgZm9yIGVhY2ggY29sdW1uXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY29sdW1uRGVmYXVsdHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uRGVmYXVsdHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b2RvOiB0ZXN0aW5nIGNvbmZpZywgcmVtb3ZlIHdoZW4gU3RvcmVzIGFyZSByZWFkeVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjcmVhdGVSYW5kb21EYXRhPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVSYW5kb21EYXRhOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBjbHM9WyduZW8tdGFibGUtY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8tdGFibGUtY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gY29sdW1uc189W11cbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbnNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3MgZm9yIE5lby50YWJsZS5oZWFkZXIuVG9vbGJhclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gW2hlYWRlclRvb2xiYXJDb25maWc9bnVsbF1cbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlclRvb2xiYXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaGVhZGVyVG9vbGJhcklkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJUb29sYmFySWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGF5b3V0PSdiYXNlJ1xuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiAnYmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzY3JvbGxiYXJzQ3NzQXBwbGllZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxiYXJzQ3NzQXBwbGllZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBzZWxlY3Rpb25Nb2RlbF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uTW9kZWxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0hlYWRlckZpbHRlcnNfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SGVhZGVyRmlsdGVyc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV9IHN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b2RvOiBvbmx5IHdvcmtzIGZvciBjaHJvbWUgJiBzYWZhcmkgLT4gYWRkIGEgY2hlY2tcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQ3VzdG9tU2Nyb2xsYmFyc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQ3VzdG9tU2Nyb2xsYmFyc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWdzIGZvciBOZW8udGFibGUuVmlld1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gW3ZpZXdDb25maWc9bnVsbF1cbiAgICAgICAgICovXG4gICAgICAgIHZpZXdDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdmlld0lkXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZpZXdJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBpdGVtcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17Y2xzOiBbJ25lby10YWJsZS13cmFwcGVyJ10sY24gOiBbe3RhZzogJ3RhYmxlJyxjbiA6IFtdfV19XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NsczogWyduZW8tdGFibGUtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ3RhYmxlJywgY246IFtdfVxuICAgICAgICBdfVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmhlYWRlclRvb2xiYXJJZCA9IE5lby5nZXRJZCgndGFibGUtaGVhZGVyLXRvb2xiYXInKTtcbiAgICAgICAgbWUudmlld0lkICAgICAgICAgID0gTmVvLmdldElkKCd0YWJsZS12aWV3Jyk7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICA6IGhlYWRlci5Ub29sYmFyLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgICA6IG1lLmhlYWRlclRvb2xiYXJJZCxcbiAgICAgICAgICAgIHNob3dIZWFkZXJGaWx0ZXJzOiBtZS5zaG93SGVhZGVyRmlsdGVycyxcbiAgICAgICAgICAgIC4uLm1lLmhlYWRlclRvb2xiYXJDb25maWdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBWaWV3LFxuICAgICAgICAgICAgY29udGFpbmVySWQgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgIDogbWUudmlld0lkLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICAgOiBtZS5zdG9yZSxcbiAgICAgICAgICAgIHVzZVJvd1JlY29yZElkczogIW1lLmNyZWF0ZVJhbmRvbURhdGEsXG4gICAgICAgICAgICAuLi5tZS52aWV3Q29uZmlnXG4gICAgICAgIH1dO1xuXG4gICAgICAgIG1lLnZkb20uaWQgPSBtZS5pZCArICd3cmFwcGVyJztcblxuICAgICAgICBtZS5jcmVhdGVDb2x1bW5zKG1lLmNvbHVtbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIHZhbHVlLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93SGVhZGVyRmlsdGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dIZWFkZXJGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTmVvLmdldENvbXBvbmVudCh0aGlzLmhlYWRlclRvb2xiYXJJZCkuc2hvd0hlYWRlckZpbHRlcnMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlQ3VzdG9tU2Nyb2xsYmFycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUN1c3RvbVNjcm9sbGJhcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy52ZG9tLmNscyA9IE5lb0FycmF5LnVuaW9uKHRoaXMudmRvbS5jbHMsIFsnbmVvLXVzZS1jdXN0b20tc2Nyb2xsYmFyJ10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5Q3VzdG9tU2Nyb2xsYmFyc0NzcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNzc1J1bGVzID0gW107XG5cbiAgICAgICAgaWYgKG1lLmRvY2tMZWZ0TWFyZ2luKSB7XG4gICAgICAgICAgICBjc3NSdWxlcy5wdXNoKCcjJyArIG1lLmlkICsgJ3dyYXBwZXInICsgJzo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2s6aG9yaXpvbnRhbCB7bWFyZ2luLWxlZnQ6ICcgKyBtZS5kb2NrTGVmdE1hcmdpbiArICdweDt9Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuZG9ja1JpZ2h0TWFyZ2luKSB7XG4gICAgICAgICAgICBjc3NSdWxlcy5wdXNoKCcjJyArIG1lLmlkICsgJ3dyYXBwZXInICsgJzo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2s6aG9yaXpvbnRhbCB7bWFyZ2luLXJpZ2h0OiAnICsgbWUuZG9ja1JpZ2h0TWFyZ2luICsgJ3B4O30nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3NzUnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgQ3NzLmluc2VydFJ1bGVzKGNzc1J1bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNjcm9sbGJhcnNDc3NBcHBsaWVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb2x1bW5zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1ucyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaGVhZGVyVG9vbGJhcklkIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEhlYWRlclRvb2xiYXJJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUgOiBvbGRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFJvd01vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgb2xkVmFsdWUuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyICAgICAgOiBtZS5vblN0b3JlRmlsdGVyLFxuICAgICAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25TdG9yZUxvYWQsXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vblN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUub24obGlzdGVuZXJzKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vblN0b3JlTG9hZCh2YWx1ZS5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgU3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBkeW5hbWljYWxseSBjaGFuZ2UgdGhlIHN0b3JlLCB0aGUgdmlldyBuZWVkcyB0byBnZXQgdGhlIG5ldyByZWZlcmVuY2VcbiAgICAgICAgICAgIGlmIChtZS52aWV3KSB7XG4gICAgICAgICAgICAgICAgbWUudmlldy5zdG9yZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZpZXdJZCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWaWV3SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlIDogb2xkVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbHVtbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjcmVhdGVDb2x1bW5zKGNvbHVtbnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbkRlZmF1bHRzID0gbWUuY29sdW1uRGVmYXVsdHMsXG4gICAgICAgICAgICBzb3J0ZXJzICAgICAgICA9IG1lLnN0b3JlPy5zb3J0ZXJzO1xuXG4gICAgICAgIGlmICghY29sdW1ucyB8fCAhY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcignQXR0ZW1wdGluZyB0byBjcmVhdGUgYSB0YWJsZS5Db250YWluZXIgd2l0aG91dCBkZWZpbmVkIGNvbHVtbnMnLCBtZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZG9jayAmJiAhY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIGRvY2tlZCBjb2x1bW4gd2l0aG91dCBhIGRlZmluZWQgd2lkdGgnLCBjb2x1bW4sIG1lLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbHVtbkRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgTmVvLmFzc2lnbkRlZmF1bHRzKGNvbHVtbiwgY29sdW1uRGVmYXVsdHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc29ydGVycz8uWzBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRlcnNbMF0ucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmlzU29ydGVkID0gc29ydGVyc1swXS5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2x1bW4ubGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgIHNvcnQgOiBtZS5vblNvcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5pdGVtc1swXS5pdGVtcyA9IGNvbHVtbnM7XG5cbiAgICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50Um93c1xuICAgICAqL1xuICAgIGNyZWF0ZVJhbmRvbVZpZXdEYXRhKGNvdW50Um93cykge1xuICAgICAgICB0aGlzLmxvYWREYXRhKGNvdW50Um93cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXREYXRhXG4gICAgICovXG4gICAgY3JlYXRlVmlld0RhdGEoaW5wdXREYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IG1lLml0ZW1zO1xuXG4gICAgICAgIGl0ZW1zWzFdLmNyZWF0ZVZpZXdEYXRhKGlucHV0RGF0YSk7IC8vIHRvZG86IHNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgJiBoZWFkZXJDb250YWluZXJcblxuICAgICAgICBpZiAobWUudXNlQ3VzdG9tU2Nyb2xsYmFycyAmJiBtZS5zY3JvbGxiYXJzQ3NzQXBwbGllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1lLmFwcGx5Q3VzdG9tU2Nyb2xsYmFyc0NzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXRlbXMgPSBpdGVtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLnRhYmxlLlZpZXd9XG4gICAgICovXG4gICAgZ2V0VmlldygpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy52aWV3SWQpIHx8IE5lby5nZXQodGhpcy52aWV3SWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtOZW8udmRvbS5WTm9kZX1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlLmNoaWxkTm9kZXNbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50Um93c1xuICAgICAqL1xuICAgIGxvYWREYXRhKGNvdW50Um93cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbnMgICAgICA9IG1lLml0ZW1zWzBdLml0ZW1zLFxuICAgICAgICAgICAgY291bnRDb2x1bW5zID0gY29sdW1ucy5sZW5ndGg7XG5cbiAgICAgICAgTmVvLm1hbmFnZXIuU3RvcmUuY3JlYXRlUmFuZG9tRGF0YShbY291bnRDb2x1bW5zLCBjb3VudFJvd3NdKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNlbGVjdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3Rpb25Nb2RlbC5yZWdpc3RlcihtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuY3JlYXRlUmFuZG9tRGF0YSkge1xuICAgICAgICAgICAgLy8gdG9kbzogaWYgbW91bnRpbmcgYXBwbHkgYWZ0ZXIgbW91bnRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZVJhbmRvbVZpZXdEYXRhKG1lLmFtb3VudFJvd3MpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5kaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNvcnRDb2x1bW4ob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnN0b3JlLnNvcnQob3B0cyk7XG4gICAgICAgIG1lLnJlbW92ZVNvcnRpbmdDc3Mob3B0cy5wcm9wZXJ0eSk7XG4gICAgICAgIG1lLm9uU3RvcmVMb2FkKG1lLnN0b3JlLml0ZW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU3RvcmVGaWx0ZXIoKSB7XG4gICAgICAgIHRoaXMub25TdG9yZUxvYWQodGhpcy5zdG9yZS5pdGVtcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcklkO1xuXG4gICAgICAgIGlmIChtZS5yZW5kZXJlZCkge1xuICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5zdG9yZS5zb3J0ZXJzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICBtZS5yZW1vdmVTb3J0aW5nQ3NzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lcklkID0gbWUub24oJ3JlbmRlcmVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnVuKCdyZW5kZXJlZCcsIGxpc3RlbmVySWQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVWaWV3RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhIHJlY29yZCBmaWVsZC5cbiAgICAgKiBFLmcuIG15UmVjb3JkLmZvbyA9ICdiYXInO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHdoaWNoIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gb3B0cy5tb2RlbCBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHsqfSBvcHRzLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucmVjb3JkXG4gICAgICogQHBhcmFtIHsqfSBvcHRzLnZhbHVlXG4gICAgICovXG4gICAgb25TdG9yZVJlY29yZENoYW5nZShvcHRzKSB7XG4gICAgICAgIE5lby5nZXRDb21wb25lbnQodGhpcy52aWV3SWQpLm9uU3RvcmVSZWNvcmRDaGFuZ2Uob3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVTb3J0aW5nQ3NzKGRhdGFGaWVsZCkge1xuICAgICAgICB0aGlzLml0ZW1zWzBdLml0ZW1zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZGF0YUZpZWxkICE9PSBkYXRhRmllbGQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4ucmVtb3ZlU29ydGluZ0NzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKENvbnRhaW5lcik7XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lcjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRhYmxlLlZpZXdcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBWaWV3IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYmxlLlZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50YWJsZS5WaWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RhYmxlLXZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFibGUtdmlldycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gY2xzPVsnbmVvLXRhYmxlLXZpZXcnXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ25lby10YWJsZS12aWV3J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVjb3JkVm5vZGVNYXA9e31cbiAgICAgICAgICovXG4gICAgICAgIHJlY29yZFZub2RlTWFwOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLlN0b3JlfG51bGx9IHN0b3JlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlUm93UmVjb3JkSWRzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZVJvd1JlY29yZElkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e3RhZzogJ3Rib2R5JywgY24gOiBbXX1cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAndGJvZHknLCBjbjogW119XG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXdEYXRhKGlucHV0RGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbW91bnRSb3dzID0gaW5wdXREYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbnRhaW5lciAgPSBOZW8uZ2V0Q29tcG9uZW50KG1lLnBhcmVudElkKSxcbiAgICAgICAgICAgIGhhc1N0b3JlICAgPSBjb250YWluZXIuc3RvcmU/Lm1vZGVsLCAvLyB0b2RvOiByZW1vdmUgYXMgc29vbiBhcyBhbGwgdGFibGVzIHVzZSBzdG9yZXMgKGV4YW1wbGVzIHRhYmxlKVxuICAgICAgICAgICAgY29sdW1ucyAgICA9IGNvbnRhaW5lci5pdGVtc1swXS5pdGVtcyxcbiAgICAgICAgICAgIGNvbENvdW50ICAgPSBjb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgIGRhdGEgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgdmRvbSAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICBjZWxsQ2xzLCBjZWxsSWQsIGNvbmZpZywgY29sdW1uLCBkb2NrTGVmdE1hcmdpbiwgZG9ja1JpZ2h0TWFyZ2luLCBpZCwgaW5kZXgsIGosIHJlbmRlcmVyT3V0cHV0LFxuICAgICAgICAgICAgcmVjb3JkLCByZW5kZXJlclZhbHVlLCBzZWxlY3RlZFJvd3MsIHRyQ2xzO1xuXG4gICAgICAgIG1lLnJlY29yZFZub2RlTWFwID0ge307IC8vIHJlbW92ZSBvbGQgZGF0YVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjcmVhdGVWaWV3RGF0YScsIG1lLmlkLCBpbnB1dERhdGEpO1xuXG4gICAgICAgIGlmIChjb250YWluZXIuc2VsZWN0aW9uTW9kZWwubnR5cGUgPT09ICdzZWxlY3Rpb24tdGFibGUtcm93bW9kZWwnKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFJvd3MgPSBjb250YWluZXIuc2VsZWN0aW9uTW9kZWwuaXRlbXMgfHwgW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGFtb3VudFJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVjb3JkID0gaW5wdXREYXRhW2ldO1xuICAgICAgICAgICAgaWQgPSBtZS5nZXRSb3dJZChyZWNvcmQsIGkpO1xuXG4gICAgICAgICAgICBtZS5yZWNvcmRWbm9kZU1hcFtpZF0gPSBpO1xuXG4gICAgICAgICAgICB0ckNscyA9IG1lLmdldFRyQ2xhc3MocmVjb3JkLCBpKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkUm93cz8uaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdHJDbHMucHVzaCgnbmVvLXNlbGVjdGVkJyk7XG5cbiAgICAgICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KG1lLmNvbnRhaW5lcklkKS5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFnICAgICA6ICd0cicsXG4gICAgICAgICAgICAgICAgaWQgICAgICA6IGlkLFxuICAgICAgICAgICAgICAgIGNscyAgICAgOiB0ckNscyxcbiAgICAgICAgICAgICAgICBjbiAgICAgIDogW10sXG4gICAgICAgICAgICAgICAgdGFiSW5kZXg6ICctMSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb2NrTGVmdE1hcmdpbiAgPSAwO1xuICAgICAgICAgICAgZG9ja1JpZ2h0TWFyZ2luID0gMDtcblxuICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyBqIDwgY29sQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbiAgICAgICAgID0gY29sdW1uc1tqXTtcbiAgICAgICAgICAgICAgICByZW5kZXJlclZhbHVlICA9IHJlY29yZFtjb2x1bW4uZGF0YUZpZWxkXTtcblxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlclZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0ID0gY29sdW1uLnJlbmRlcmVyLmNhbGwoY29sdW1uLnJlbmRlcmVyU2NvcGUgfHwgY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogY29sdW1uLmRhdGFGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggICAgOiBpLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgICA6IHJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiByZW5kZXJlclZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjZWxsQ2xzID0gcmVuZGVyZXJPdXRwdXQ/LmNscyB8fCBbJ25lby10YWJsZS1jZWxsJ107XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbENscy5wdXNoKCduZW8tJyArIGNvbHVtbi5hbGlnbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNPYmplY3QocmVuZGVyZXJPdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogY2VsbENscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHJlbmRlcmVyT3V0cHV0Py50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBpZiBwYXJ0IGFzIHNvb24gYXMgYWxsIHRhYmxlcyB1c2Ugc3RvcmVzIChleGFtcGxlcyB0YWJsZSlcbiAgICAgICAgICAgICAgICBpZiAoaGFzU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbElkID0gbWUuZ2V0Q2VsbElkKHJlY29yZCwgY29sdW1uLmRhdGFGaWVsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbElkID0gdmRvbS5jbltpXT8uY25bal0/LmlkIHx8IE5lby5nZXRJZCgndGQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZyAgICAgIDogJ3RkJyxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBjZWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogcmVuZGVyZXJPdXRwdXQuY2xzICAgfHwgWyduZW8tdGFibGUtY2VsbCddLFxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUw6IHJlbmRlcmVyT3V0cHV0Lmh0bWwgIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSAgICA6IHJlbmRlcmVyT3V0cHV0LnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA6ICctMSdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jbHMgPSBbJ25lby1sb2NrZWQnLCAuLi5jb25maWcuY2xzIHx8IFtdXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmRvY2sgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0eWxlLmxlZnQgPSBkb2NrTGVmdE1hcmdpbiArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NrTGVmdE1hcmdpbiArPSAoY29sdW1uLndpZHRoICsgMSk7IC8vIHRvZG86IGJvcmRlcnMgZml4XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFbaV0uY24ucHVzaChjb25maWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgZm9yICg7IGogPCBjb2xDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggID0gY29sQ291bnQgLSBqIC0xO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0uY25baW5kZXhdLnN0eWxlLnJpZ2h0ID0gZG9ja1JpZ2h0TWFyZ2luICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgZG9ja1JpZ2h0TWFyZ2luICs9IChjb2x1bW4ud2lkdGggKyAxKTsgLy8gdG9kbzogYm9yZGVycyBmaXhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2ZG9tLmNuID0gZGF0YTtcblxuICAgICAgICBjb250YWluZXIuZG9ja0xlZnRNYXJnaW4gID0gZG9ja0xlZnRNYXJnaW47XG4gICAgICAgIGNvbnRhaW5lci5kb2NrUmlnaHRNYXJnaW4gPSBkb2NrUmlnaHRNYXJnaW47XG5cbiAgICAgICAgbWUucHJvbWlzZVZkb21VcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFJvd3M/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxvZ2ljIG9ubHkgd29ya3MgZm9yIHNlbGVjdGlvbi50YWJsZS5Sb3dNb2RlbFxuICAgICAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxUb1RhYmxlUm93KHtpZDogc2VsZWN0ZWRSb3dzWzBdfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlUGFyZW50VmRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50XG4gICAgICovXG4gICAgZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tLCBzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG51bGw7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2VsbElkKHJlY29yZCwgZGF0YUZpZWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19fJyArIHJlY29yZFt0aGlzLnN0b3JlLmtleVByb3BlcnR5XSArICdfXycgKyBkYXRhRmllbGQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJvd0lkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmRCeVJvd0lkKHJvd0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldEF0KHRoaXMucmVjb3JkVm5vZGVNYXBbcm93SWRdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFJvd0lkKHJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0b3JlID0gbWUuc3RvcmU7XG5cbiAgICAgICAgaWYgKG1lLnVzZVJvd1JlY29yZElkcykge1xuICAgICAgICAgICAgcmV0dXJuIGAke21lLmlkfV9fdHJfXyR7cmVjb3JkW3N0b3JlLmtleVByb3BlcnR5XX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBOZW8uaXNOdW1iZXIoaW5kZXgpID8gaW5kZXggOiBzdG9yZS5pbmRleE9mKHJlY29yZCk7XG4gICAgICAgICAgICByZXR1cm4gbWUudmRvbS5jbltpbmRleF0/LmlkIHx8IE5lby5nZXRJZCgndHInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGN1c3RvbSBDU1MgcnVsZXMgdG8gdGFibGUgcm93c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm93SW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0VHJDbGFzcyhyZWNvcmQsIHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiBbJ25lby10YWJsZS1yb3cnXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdHMuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBvcHRzLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKi9cbiAgICBvblN0b3JlUmVjb3JkQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkZWx0YXMgPSBbXSxcbiAgICAgICAgICAgIGNlbGxJZCwgY2VsbE5vZGU7XG5cbiAgICAgICAgb3B0cy5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBjZWxsSWQgICA9IG1lLmdldENlbGxJZChvcHRzLnJlY29yZCwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICBjZWxsTm9kZSA9IG1lLmdldFZkb21DaGlsZChjZWxsSWQpO1xuXG4gICAgICAgICAgICBjZWxsTm9kZS5pbm5lckhUTUwgPSBmaWVsZC52YWx1ZTsgLy8ga2VlcCB0aGUgdmRvbSBpbiBzeW5jXG5cbiAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IGNlbGxJZCxcbiAgICAgICAgICAgICAgICBpbm5lckhUTUw6IGZpZWxkLnZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBkZWx0YXMubGVuZ3RoID4gMCAmJiBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwgZGVsdGFzKTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuIiwiaW1wb3J0IEJhc2VCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUZXh0RmllbGQgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUuaGVhZGVyLkJ1dHRvblxuICogQGV4dGVuZHMgTmVvLmJ1dHRvbi5CYXNlXG4gKi9cbmNsYXNzIEJ1dHRvbiBleHRlbmRzIEJhc2VCdXR0b24ge1xuICAgIHN0YXRpYyBnZXRTdGF0aWNDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgYWxpZ25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGFsaWduVmFsdWVzOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnblZhbHVlczogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddXG4gICAgfX1cblxuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udGFibGUuaGVhZGVyLkJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYmxlLmhlYWRlci5CdXR0b24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndGFibGUtaGVhZGVyLWJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0YWJsZS1oZWFkZXItYnV0dG9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWdubWVudCBvZiB0aGUgbWF0Y2hpbmcgdGFibGUgY2VsbHMuIFZhbGlkIHZhbHVlcyBhcmUgbGVmdCwgY2VudGVyLCByaWdodFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGFsaWduXz0nbGVmdCdcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduXzogJ2xlZnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGNscz1bJ25lby10YWJsZS1oZWFkZXItYnV0dG9uJ11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8tdGFibGUtaGVhZGVyLWJ1dHRvbiddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRhdGFGaWVsZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0IGRpcmVjdGlvbiB3aGVuIGNsaWNraW5nIG9uIGFuIHVuc29ydGVkIGJ1dHRvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRlZmF1bHRTb3J0RGlyZWN0aW9uPSdBU0MnXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0U29ydERpcmVjdGlvbjogJ0FTQycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnZ2FibGVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnYWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGVkaXRvckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0b3JDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGZpbHRlckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZm9ybS5maWVsZC5CYXNlfG51bGx9IGZpbHRlckZpZWxkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGljb25DbHM9J2ZhIGZhLWFycm93LWNpcmNsZS11cCdcbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6ICdmYSBmYS1hcnJvdy1jaXJjbGUtdXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpY29uUG9zaXRpb249J3JpZ2h0J1xuICAgICAgICAgKi9cbiAgICAgICAgaWNvblBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogJ0FTQycsICdERVNDJyBvciBudWxsXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpc1NvcnRlZF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1NvcnRlZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY29wZSB0byBleGVjdXRlIHRoZSBjb2x1bW4gcmVuZGVyZXIuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHRoZSBtYXRjaGluZyB0YWJsZS5Db250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvcmUuQmFzZXxudWxsfSByZW5kZXJlclNjb3BlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyU2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SGVhZGVyRmlsdGVyXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0hlYWRlckZpbHRlcl86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICd0aCcsIGNuOiBbXG4gICAgICAgICAgICB7dGFnOiAnYnV0dG9uJywgY246IFtcbiAgICAgICAgICAgICAgICB7dGFnOiAnc3BhbicsIGNsczogWyduZW8tYnV0dG9uLWdseXBoJ119LFxuICAgICAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1idXR0b24tdGV4dCddfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IG1lLm9uQnV0dG9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZS5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgZHJhZ2VuZCAgOiBtZS5vbkRyYWdFbmQsXG4gICAgICAgICAgICAgICAgZHJhZ2VudGVyOiBtZS5vbkRyYWdFbnRlcixcbiAgICAgICAgICAgICAgICBkcmFnbGVhdmU6IG1lLm9uRHJhZ0xlYXZlLFxuICAgICAgICAgICAgICAgIGRyYWdvdmVyIDogbWUub25EcmFnT3ZlcixcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IG1lLm9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgICAgIGRyb3AgICAgIDogbWUub25Ecm9wLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5kb21MaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWUuZ2V0VmRvbVJvb3QoKS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG1lLmdldFZkb21Sb290KCkuZHJhZ2dhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudmRvbSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc1NvcnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzU29ydGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgICAgICA9IG1lLmNscyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG1lLnVwKCd0YWJsZS1jb250YWluZXInKTtcblxuICAgICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBU0MnOlxuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tc29ydC1kZXNjJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1hc2MnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0RFU0MnOlxuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tc29ydC1hc2MnKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWRlc2MnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAvLyB0ZXN0aW5nIGNoZWNrIHVudGlsIGFsbCBleGFtcGxlIHRhYmxlcyBoYXZlIGEgc3RvcmVcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5zdG9yZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUubW91bnRlZCAmJiBtZS5maXJlKCdzb3J0Jywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiB2YWx1ZSxcbiAgICAgICAgICAgIHByb3BlcnR5IDogbWUuZGF0YUZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0hlYWRlckZpbHRlciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dIZWFkZXJGaWx0ZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtZS5maWx0ZXJGaWVsZCkge1xuICAgICAgICAgICAgICAgIG1lLmZpbHRlckZpZWxkID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogJ2ZpbHRlci1maWVsZCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCxcblxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSAgICAgICAgOiBtZS5jaGFuZ2VGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yQ2hhbmdlOiBtZS5jaGFuZ2VGaWx0ZXJPcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICAgOiBtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0IDogJy41ZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcuNWVtJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5lZGl0b3JDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLnZkb20uY24ucHVzaChtZS5maWx0ZXJGaWVsZC52ZG9tKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lLmZpbHRlckZpZWxkLnZkb20ucmVtb3ZlRG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1lLmZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICBtZS5maWx0ZXJGaWVsZC52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBtZS52ZG9tID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhbGlnbiBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWxpZ24nLCAnYWxpZ25WYWx1ZXMnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLmZpbHRlckZpZWxkPy5kZXN0cm95KCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZkb20gcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0Vm5vZGVSb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2ZG9tIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZub2RlIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZkb21Sb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2bm9kZSByb290XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkJ1dHRvbkNsaWNrKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbWFwO1xuXG4gICAgICAgIGlmIChtZS5kZWZhdWx0U29ydERpcmVjdGlvbiA9PT0gJ0RFU0MnKSB7XG4gICAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAgICAgQVNDIDogbnVsbCxcbiAgICAgICAgICAgICAgICBERVNDOiAnQVNDJyxcbiAgICAgICAgICAgICAgICBudWxsOiAnREVTQydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAgICAgQVNDIDogJ0RFU0MnLFxuICAgICAgICAgICAgICAgIERFU0M6IG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbDogJ0FTQydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc1NvcnRlZCA9IG1hcFttZS5pc1NvcnRlZCArICcnXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EcmFnRW5kKCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGUgPSBtZS5zdHlsZTtcblxuICAgICAgICBkZWxldGUgc3R5bGUub3BhY2l0eTtcbiAgICAgICAgbWUuc3R5bGUgPSBzdHlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EcmFnRW50ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tZHJhZy1vdmVyJyk7XG4gICAgICAgIG1lLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EcmFnTGVhdmUoKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tZHJhZy1vdmVyJyk7XG4gICAgICAgIG1lLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ29uRHJhZ092ZXInLCBldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGUgPSBtZS5zdHlsZTtcblxuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC40O1xuICAgICAgICBtZS5zdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhlYWRlclRvb2xiYXIgID0gTmVvLmdldENvbXBvbmVudChtZS5wYXJlbnRJZCksXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgICA9IG1lLnN0eWxlLFxuICAgICAgICAgICAgdGFibGVDb250YWluZXIgPSBOZW8uZ2V0Q29tcG9uZW50KGhlYWRlclRvb2xiYXIucGFyZW50SWQpO1xuXG4gICAgICAgIG1lLm9uRHJhZ0xlYXZlKCk7XG4gICAgICAgIGhlYWRlclRvb2xiYXIuc3dpdGNoSXRlbXMobWUuaWQsIGRhdGEuc3JjSWQpO1xuICAgICAgICB0YWJsZUNvbnRhaW5lci5jcmVhdGVWaWV3RGF0YSh0YWJsZUNvbnRhaW5lci5zdG9yZS5kYXRhKTtcblxuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgbWUuc3R5bGUgPSBzdHlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNoYW5nZUZpbHRlck9wZXJhdG9yKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyID0gbWUudXAoJ3RhYmxlLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICAgPSB0YWJsZUNvbnRhaW5lcj8uc3RvcmUsXG4gICAgICAgICAgICBvcGVyYXRvciAgICAgICA9IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXIsIGZpbHRlcnM7XG5cbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzID0gc3RvcmUuZmlsdGVycztcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtZS5kYXRhRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZmlsdGVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNoYW5nZUZpbHRlclZhbHVlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyID0gbWUudXAoJ3RhYmxlLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICAgPSB0YWJsZUNvbnRhaW5lcj8uc3RvcmUsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgICA9IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBmaWVsZCwgZmlsdGVyLCBmaWx0ZXJzLCBtb2RlbDtcblxuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IHN0b3JlLmdldEZpbHRlcihtZS5kYXRhRmllbGQpO1xuICAgICAgICAgICAgbW9kZWwgID0gc3RvcmUubW9kZWw7XG4gICAgICAgICAgICBmaWVsZCAgPSBtb2RlbCAmJiBtb2RlbC5nZXRGaWVsZChtZS5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgZmllbGQudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzID0gc3RvcmUuZmlsdGVycztcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtZS5kYXRhRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnbGlrZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5maWx0ZXJDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHN0b3JlLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVTb3J0aW5nQ3NzKCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG5cbiAgICAgICAgbWUuY2xzICAgICAgID0gY2xzO1xuICAgICAgICBtZS5faXNTb3J0ZWQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuZGF0YUZpZWxkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGRhdGEudmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICByZW5kZXJlcihkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnZhbHVlO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoQnV0dG9uKTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xuIiwiaW1wb3J0IEJhc2VUb29sYmFyIGZyb20gJy4uLy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUuaGVhZGVyLlRvb2xiYXJcbiAqIEBleHRlbmRzIE5lby50b29sYmFyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2VUb29sYmFyIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYmxlLmhlYWRlci5Ub29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFibGUuaGVhZGVyLlRvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndGFibGUtaGVhZGVyLXRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFibGUtaGVhZGVyLXRvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGNscz1bJ3RhYmxlLWhlYWRlci10b29sYmFyJ11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyd0YWJsZS1oZWFkZXItdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYXlvdXQ9J2Jhc2UnXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6ICdiYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZSA6ICd0YWJsZS1oZWFkZXItYnV0dG9uJ31cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGUgOiAndGFibGUtaGVhZGVyLWJ1dHRvbidcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dIZWFkZXJGaWx0ZXJzXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0hlYWRlckZpbHRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e3RhZzogJ3RoZWFkJyxjbiA6IFt7dGFnOiAndHInLGNuIDogW119XX1cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAndGhlYWQnLCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ3RyJywgY246IFtdfVxuICAgICAgICBdfVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dIZWFkZXJGaWx0ZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0hlYWRlckZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmRvbSA9IG1lLnZkb207XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzaG93SGVhZGVyRmlsdGVyOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnZkb20gPSB2ZG9tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pdGVtRGVmYXVsdHMuc2hvd0hlYWRlckZpbHRlciA9IG1lLnNob3dIZWFkZXJGaWx0ZXJzO1xuXG4gICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICAgICAgbGV0IGRvY2tMZWZ0V2lkdGggID0gMCxcbiAgICAgICAgICAgIGRvY2tSaWdodFdpZHRoID0gMCxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgID0gbWUuaXRlbXMsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIHN0eWxlO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBzdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICAvLyB0b2RvOiBvbmx5IGFkZCBweCBpZiBudW1iZXJcbiAgICAgICAgICAgIGlmIChpdGVtLm1heFdpZHRoKSB7c3R5bGUubWF4V2lkdGggPSBpdGVtLm1heFdpZHRoICsgJ3B4J31cbiAgICAgICAgICAgIGlmIChpdGVtLm1pbldpZHRoKSB7c3R5bGUubWluV2lkdGggPSBpdGVtLm1pbldpZHRoICsgJ3B4J31cbiAgICAgICAgICAgIGlmIChpdGVtLndpZHRoKSAgICB7c3R5bGUud2lkdGggICAgPSBpdGVtLndpZHRoICAgICsgJ3B4J31cblxuICAgICAgICAgICAgaWYgKGl0ZW0uZG9jaykge1xuICAgICAgICAgICAgICAgIGl0ZW0udmRvbS5jbHMgPSBbJ25lby1sb2NrZWQnXTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmRvY2sgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gZG9ja0xlZnRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9ja0xlZnRXaWR0aCArPSAoaXRlbS53aWR0aCArIDEpOyAvLyB0b2RvOiBib3JkZXJzIGZpeFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLnZkb20uY2xzID0gW107IC8vIHJlbW92ZSB0aGUgYnV0dG9uIGNscyBmcm9tIHRoZSB0aCB0YWdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBzdHlsZTtcblxuICAgICAgICAgICAgLy8gaW52ZXJzZSBsb29wIGRpcmVjdGlvblxuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2xlbiAtIGluZGV4IC0xXTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uZG9jayA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIHN0eWxlID0gaXRlbS53cmFwcGVyU3R5bGU7XG4gICAgICAgICAgICAgICAgc3R5bGUucmlnaHQgPSBkb2NrUmlnaHRXaWR0aCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgICAgICAgICAgZG9ja1JpZ2h0V2lkdGggKz0gKGl0ZW0ud2lkdGggKyAxKTsgLy8gdG9kbzogYm9yZGVycyBmaXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudmRvbSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRvY2tcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBsYXlvdXRDb25maWdcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRDb25maWcoZG9jaykge1xuICAgICAgICByZXR1cm4gJ2Jhc2UnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSBpdGVtcyByb290IGlmIG5lZWRlZCAodXNlZnVsIGluIGNhc2UgdGhpcyBjb250YWluZXIgdXNlcyBhIHdyYXBwZXIgbm9kZSkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2ZG9tIGl0ZW1zIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tSXRlbXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWbm9kZVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZkb20gcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdm5vZGUgcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0VmRvbVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZub2RlIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlLmNoaWxkTm9kZXNbMF07XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhUb29sYmFyKTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhcjtcbiIsImltcG9ydCBCdXR0b24gIGZyb20gJy4vQnV0dG9uLm1qcyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuL1Rvb2xiYXIubWpzJztcblxuZXhwb3J0IHtCdXR0b24sIFRvb2xiYXJ9OyIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5Dc3NcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ3NzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkNzcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuQ3NzJ1xuICAgIH19XG5cbiAgICAvKipcbiAgICAgKiBQYXNzIHRoZSBzZWxlY3RvclRleHQgb2YgdGhlIHJ1bGVzIHdoaWNoIHlvdSB3YW50IHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBydWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVSdWxlcyhydWxlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBydWxlcyA9IFtydWxlc107XG4gICAgICAgIH1cblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5TdHlsZXNoZWV0LmRlbGV0ZUNzc1J1bGVzKHtcbiAgICAgICAgICAgIHJ1bGVzOiBydWxlc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gcnVsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zZXJ0UnVsZXMocnVsZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgcnVsZXMgPSBbcnVsZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldC5pbnNlcnRDc3NSdWxlcyh7XG4gICAgICAgICAgICBydWxlczogcnVsZXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhDc3MpO1xuXG5leHBvcnQgZGVmYXVsdCBDc3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=