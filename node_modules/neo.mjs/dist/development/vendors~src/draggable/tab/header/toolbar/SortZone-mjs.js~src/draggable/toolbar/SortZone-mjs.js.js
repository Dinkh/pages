self["webpackChunk"](["vendors~src/draggable/tab/header/toolbar/SortZone-mjs.js~src/draggable/toolbar/SortZone-mjs.js"],{

/***/ "./src/draggable/DragProxyComponent.mjs":
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragProxyComponent; });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {Boolean} autoRender=true
         */
        autoRender: true,
        /**
         * @member {String[]} cls=['neo-dragproxy']
         */
        cls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me = this;

        me.on('mounted', me.onMounted, me);
    }

    /**
     *
     * @param {String} id
     */
    onMounted(id) {
        if (this.moveInMainThread) {
            Neo.main.addon.DragDrop.setDragProxyElement({
                id: id
            });
        }
    }
}

Neo.applyClassConfig(DragProxyComponent);



/***/ }),

/***/ "./src/draggable/DragZone.mjs":
/*!************************************!*\
  !*** ./src/draggable/DragZone.mjs ***!
  \************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragZone; });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @class Neo.draggable.DragZone
 * @extends Neo.core.Base
 */
class DragZone extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragZone'
         * @protected
         */
        className: 'Neo.draggable.DragZone',
        /**
         * @member {String} ntype='dragzone'
         * @protected
         */
        ntype: 'dragzone',
        /**
         * drag:move will by default only fire in case moveInMainThread === false.
         * In case you want to move the dragProxy inside main but still get the event,
         * set this config to true.
         * @member {Boolean} alwaysFireDragMove=false
         */
        alwaysFireDragMove: false,
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName=null
         */
        appName: null,
        /**
         * @member {String|null} boundaryContainerId=null
         */
        boundaryContainerId: null,
        /**
         * The vdom (tree) of the element you want to drag
         * @member {Object|null} dragElement=null
         */
        dragElement: null,
        /**
         * The bounding client rect of the dragElement
         * Will get set inside dragStart()
         * @member {Object|null} dragElementRect=null
         */
        dragElementRect: null,
        /**
         * @member {Neo.component.Base|null} dragProxy=null
         * @protected
         */
        dragProxy: null,
        /**
         * @member {Object|null} dragProxyConfig=null
         */
        dragProxyConfig_: null,
        /**
         * @member {Boolean} moveHorizontal=true
         */
        moveHorizontal: true,
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true,
        /**
         * @member {Boolean} moveVertical=true
         */
        moveVertical: true,
        /**
         * @member {Number} offsetX=0
         */
        offsetX: 0,
        /**
         * @member {Number} offsetY=0
         */
        offsetY: 0,
        /**
         * @member {Neo.component.Base} owner=null
         */
        owner: null,
        /**
         * @member {String} proxyParentId_='document.body'
         */
        proxyParentId_: 'document.body',
        /**
         * @member {String|null} scrollContainerId=null
         */
        scrollContainerId: null,
        /**
         * @member {Number} scrollFactorLeft=1
         */
        scrollFactorLeft: 1,
        /**
         * @member {Number} scrollFactorTop=1
         */
        scrollFactorTop: 1,
        /**
         * True creates a position:absolute wrapper div which contains the cloned element
         * @member {Boolean} useProxyWrapper=true
         */
        useProxyWrapper: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        if (!Neo.main.addon.DragDrop) {
            throw new Error('You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons');
        }
    }

    /**
     * Triggered when accessing the dragProxyConfig config
     * We are re-using this config to create multiple dragProxies,
     * so it is important to work with a clone. see: createDragProxy()
     * @param {Object} value
     * @protected
     */
    beforeGetDragProxyConfig(value) {
        return Neo.clone(value, true, true);
    }

    /**
     *
     * @param {Object} data
     */
    createDragProxy(data) {
        let me        = this,
            component = Neo.getComponent(me.dragElement.id),
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(me.dragElement);

        const config = {
            module          : _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            vdom            : me.useProxyWrapper ? {cn: [clone]} : clone,

            style: {
                height: `${data.height}px`,
                left  : `${me.moveHorizontal ? data.left : 0}px`,
                top   : `${me.moveVertical   ? data.top  : 0}px`,
                width : `${data.width}px`
            },

            ...me.dragProxyConfig || {}
        };

        config.cls = config.cls || [];

        if (component) {
            config.cls.push(component.getTheme());
        }

        if (!me.useProxyWrapper) {
            config.cls.push(...clone.cls);
        }

        me.dragProxy = Neo.create(config);
    }

    /**
     * Override for using custom animations
     */
    destroyDragProxy() {
        let me = this,
            id = me.dragProxy.id;

        setTimeout(() => {
            Neo.currentWorker.promiseMessage('main', {
                action: 'updateDom',
                deltas: [{action: 'removeNode', id: id}]
            });
        }, me.moveInMainThread ? 0 : 30);

        me.dragProxy.destroy();
    }

    /**
     *
     */
    dragEnd() {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, 'neo-is-dragging');
        owner.cls = cls;

        if (me.dragProxy) {
            me.destroyDragProxy();
            me.dragProxy = null;
        }

        Object.assign(me, {
            dragElementRect  : null,
            offsetX          : 0,
            offsetY          : 0,
            scrollContainerId: null
        });
    }

    /**
     *
     * @param {Object} data
     */
    dragMove(data) {
        let me = this,
            style;

        if (!me.moveInMainThread && me.dragProxy) {
            style = me.dragProxy.style;

            if (me.moveHorizontal) {
                style.left = `${data.clientX - me.offsetX}px`;
            }

            if (me.moveVertical) {
                style.top = `${data.clientY - me.offsetY}px`;
            }

            me.dragProxy.style = style;
        }
    }

    /**
     *
     * @param {Object} data
     */
    dragStart(data) {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(cls, 'neo-is-dragging');
        owner.cls = cls;

        Neo.main.addon.DragDrop.setConfigs(me.getMainThreadConfigs());

        Neo.main.DomAccess.getBoundingClientRect({
            id: me.dragElement.id
        }).then(rect => {
            Object.assign(me, {
                dragElementRect: rect,
                offsetX        : data.clientX - rect.left,
                offsetY        : data.clientY - rect.top
            });

            me.createDragProxy(rect);
        });
    }

    /**
     * Override this method inside class extensions to add more configs
     * which get passed to main.addon.DragDrop onDragStart()
     * @returns {Object}
     * @protected
     */
    getMainThreadConfigs() {
        let me = this;

        return {
            alwaysFireDragMove : me.alwaysFireDragMove,
            boundaryContainerId: me.boundaryContainerId,
            scrollContainerId  : me.scrollContainerId,
            scrollFactorLeft   : me.scrollFactorLeft,
            scrollFactorTop    : me.scrollFactorTop
        };
    }
}

Neo.applyClassConfig(DragZone);



/***/ }),

/***/ "./src/draggable/toolbar/DragZone.mjs":
/*!********************************************!*\
  !*** ./src/draggable/toolbar/DragZone.mjs ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragZone; });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.draggable.toolbar.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.toolbar.DragZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.DragZone',
        /**
         * @member {String} ntype='toolbar-dragzone'
         * @protected
         */
        ntype: 'toolbar-dragzone'
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me           = this,
            owner        = me.owner,
            domListeners = owner.domListeners,
            opts         = {delegate: '.neo-draggable', scope: me};

        domListeners.push(
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        );

        owner.domListeners = domListeners;

        owner.on('insert', me.onItemInsert, me);

        me.adjustToolbarItemCls(true);
    }

    /**
     *
     * @param {Boolean} draggable
     */
    adjustToolbarItemCls(draggable) {
        let me    = this,
            owner = me.owner,
            vdom  = owner.vdom;

        vdom.cn.forEach(item => {
            item.cls = item.cls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][draggable ? 'add' : 'remove'](item.cls, 'neo-draggable');
        });

        owner.vdom = vdom;
    }

    /**
     *
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            setTimeout(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                setTimeout(() => {
                    me.dragEnd();
                }, 300);
            }, 30);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.owner.vdom, data.path[0].id).vdom;
            me.dragStart(data);
        }
    }

    /**
     * @param {Object} data
     * @param {Number} data.index
     * @param {Neo.component.Base} data.item
     */
    onItemInsert(data) {
        let item = data.item,
            cls  = item.cls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-draggable');
        item.cls = cls;
    }
}

Neo.applyClassConfig(DragZone);



/***/ }),

/***/ "./src/draggable/toolbar/SortZone.mjs":
/*!********************************************!*\
  !*** ./src/draggable/toolbar/SortZone.mjs ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SortZone; });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./src/draggable/toolbar/DragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @class Neo.draggable.toolbar.SortZone
 * @extends Neo.draggable.toolbar.DragZone
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.toolbar.SortZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.SortZone',
        /**
         * @member {String} ntype='toolbar-sortzone'
         * @protected
         */
        ntype: 'toolbar-sortzone',
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * Internal flag: onDragStart() will set the value to horizontal or vertical, depending on the current layout.
         * @member {String} sortDirection='horizontal'
         * @protected
         */
        sortDirection: 'horizontal',
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }}

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     *
     * @param {Object} data
     */
    onDragEnd(data) {
        let me         = this,
            owner      = me.owner,
            itemStyles = me.itemStyles,
            ownerStyle = owner.style || {},
            itemStyle;

        ownerStyle.height = me.ownerStyle.height || null;
        ownerStyle.width  = me.ownerStyle.width  || null;

        owner.style = ownerStyle;

        owner.items.forEach((item, index) => {
            itemStyle = item.style || {};

            Object.assign(itemStyle, {
                height  : itemStyles[index].height || null,
                left    : null,
                position: null,
                top     : null,
                width   : itemStyles[index].width || null
            });

            if (index === me.startIndex) {
                itemStyle.visibility = null;
            }

            item.style = itemStyle;
        });

        if (me.startIndex !== me.currentIndex) {
            me.moveTo(me.startIndex, me.currentIndex);
        }

        Object.assign(me, {
            currentIndex: -1,
            indexMap    : null,
            itemRects   : null,
            itemStyles  : null,
            ownerRect   : null,
            startIndex  : -1
        });

        me.dragEnd(data); // we do not want to trigger the super class call here
    }

    /**
     *
     * @param {Object} data
     */
    onDragMove(data) {
        if (this.itemRects) { // the method can trigger before we got the client rects from the main thread
            let me         = this,
                moveFactor = 0.55, // we can not use 0.5, since items would jump back & forth
                index      = me.currentIndex,
                itemRects  = me.itemRects,
                delta, itemWidth;

            if (me.sortDirection === 'horizontal') {
                delta     = data.clientX - me.offsetX - itemRects[index].left;
                itemWidth = 'width';
            } else {
                delta     = data.clientY - me.offsetY - itemRects[index].top;
                itemWidth = 'height';
            }

            if (index > 0 && delta < 0) {
                if (Math.abs(delta) > itemRects[index - 1][itemWidth] * moveFactor) {
                    me.currentIndex--;
                    me.switchItems(index, me.currentIndex);
                }
            }

            else if (index < itemRects.length - 1 && delta > 0) {
                if (delta > itemRects[index + 1][itemWidth] * moveFactor) {
                    me.currentIndex++;
                    me.switchItems(index, me.currentIndex);
                }
            }
        }
    }

    /**
     *
     * @param {Object} data
     */
    onDragStart(data) {
        let me         = this,
            button     = Neo.getComponent(data.path[0].id),
            owner      = me.owner,
            itemStyles = me.itemStyles = [],
            ownerStyle = owner.style || {},
            index, indexMap, itemStyle, rect;

        if (owner.sortable) {
            me.sortDirection = owner.layout.ntype === 'layout-vbox' ? 'vertical' : 'horizontal';

            me.dragProxyConfig = {
                ...me.dragProxyConfig || {},
                cls : ['neo-dragproxy', ...owner.cls]
            };

            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].findVdomChild(owner.vdom, button.id).vdom;
            me.dragStart(data); // we do not want to trigger the super class call here

            me.ownerStyle = {
                height: ownerStyle.height,
                width : ownerStyle.width
            };

            index = owner.indexOf(button.id);

            indexMap = {};

            owner.items.forEach((item, index) => {
                indexMap[index] = index;

                itemStyles.push({
                    height: item.style && item.style.height,
                    width : item.style && item.style.width
                })
            });

            Object.assign(me, {
                currentIndex: index,
                indexMap    : indexMap,
                startIndex  : index
            });

            Neo.main.DomAccess.getBoundingClientRect({
                id: [owner.id].concat(owner.items.map(e => e.id))
            }).then(itemRects => {
                me.ownerRect = itemRects[0];

                ownerStyle.height = `${itemRects[0].height}px`;
                ownerStyle.width  = `${itemRects[0].width}px`;

                // the only reason we are adjusting the toolbar style is that there is no min height or width present.
                // removing items from the layout could trigger a change in size.
                owner.style = ownerStyle;

                itemRects.shift();
                me.itemRects = itemRects;

                owner.items.forEach((item, index) => {
                    itemStyle = item.style || {};
                    rect      = itemRects[index];

                    Object.assign(itemStyle, {
                        height  : `${rect.height}px`,
                        left    : `${rect.left}px`,
                        position: 'absolute',
                        top     : `${rect.top}px`,
                        width   : `${rect.width}px`
                    });

                    item.style = itemStyle;
                });

                setTimeout(() => {
                    itemStyle = button.style || {};
                    itemStyle.visibility = 'hidden';
                    button.style = itemStyle;
                }, 30);
            });
        }
    }

    /**
     *
     * @param {Number} index1
     * @param {Number} index2
     */
    switchItems(index1, index2) {
        let tmp;

        if (index2 < index1) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp;
        }

        let me        = this,
            itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = itemRects[index1],
            rect2     = itemRects[index2],
            rect1Copy = {...rect1},
            rect2Copy = {...rect2};

        if (me.sortDirection === 'horizontal') {
            rect1.width = rect2Copy.width;
            rect2.left  = rect1Copy.left + rect2Copy.width;
            rect2.width = rect1Copy.width;
        } else {
            rect1.height = rect2Copy.height;
            rect2.height = rect1Copy.height;
            rect2.top    = rect1Copy.top + rect2Copy.height;
        }

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, rect1);
        me.updateItem(index2, rect2);
    }

    /**
     *
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me    = this,
            item  = me.owner.items[me.indexMap[index]],
            style = item.style;

        style.left = `${rect.left}px`;
        style.top  = `${rect.top}px`;

        item.style = style;
    }
}

Neo.applyClassConfig(SortZone);



/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZHJhZ2dhYmxlL0RyYWdQcm94eUNvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RyYWdnYWJsZS90b29sYmFyL0RyYWdab25lLm1qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJEQUFJO0FBQ3JDLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBa0Q7QUFDUTtBQUNQO0FBQ0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDM0M7QUFDQTs7QUFFQSw2QkFBNkIsc0RBQVE7QUFDckMsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLHVDQUF1QyxvQkFBb0I7QUFDM0QsdUNBQXVDLG1CQUFtQjs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQscUNBQXFDLFVBQVU7QUFDL0M7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QyxxQ0FBcUMsV0FBVztBQUNoRCxxQkFBcUI7O0FBRXJCO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEMseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEMsd0JBQXdCLFNBQVM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJ2ZW5kb3JzfnNyYy9kcmFnZ2FibGUvdGFiL2hlYWRlci90b29sYmFyL1NvcnRab25lLW1qcy5qc35zcmMvZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUtbWpzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBEcmFnUHJveHlDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2RyYWdwcm94eSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFncHJveHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9SZW5kZXI9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1JlbmRlcjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8tZHJhZ3Byb3h5J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWVcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5vbignbW91bnRlZCcsIG1lLm9uTW91bnRlZCwgbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICovXG4gICAgb25Nb3VudGVkKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVJbk1haW5UaHJlYWQpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldERyYWdQcm94eUVsZW1lbnQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERyYWdQcm94eUNvbXBvbmVudCk7XG5cbmV4cG9ydCB7RHJhZ1Byb3h5Q29tcG9uZW50IGFzIGRlZmF1bHR9OyIsImltcG9ydCBCYXNlICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50IGZyb20gJy4vRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1pvbmUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFnem9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFnem9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnOm1vdmUgd2lsbCBieSBkZWZhdWx0IG9ubHkgZmlyZSBpbiBjYXNlIG1vdmVJbk1haW5UaHJlYWQgPT09IGZhbHNlLlxuICAgICAgICAgKiBJbiBjYXNlIHlvdSB3YW50IHRvIG1vdmUgdGhlIGRyYWdQcm94eSBpbnNpZGUgbWFpbiBidXQgc3RpbGwgZ2V0IHRoZSBldmVudCxcbiAgICAgICAgICogc2V0IHRoaXMgY29uZmlnIHRvIHRydWUuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBpbnN0YW5jZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhcHBOYW1lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYm91bmRhcnlDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gKHRyZWUpIG9mIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIGRyYWdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdFbGVtZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdFbGVtZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBkcmFnRWxlbWVudFxuICAgICAgICAgKiBXaWxsIGdldCBzZXQgaW5zaWRlIGRyYWdTdGFydCgpXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnRWxlbWVudFJlY3Q9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0VsZW1lbnRSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGRyYWdQcm94eT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdQcm94eTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnUHJveHlDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5Q29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVIb3Jpem9udGFsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVIb3Jpem9udGFsOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZVZlcnRpY2FsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gb2Zmc2V0WD0wXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBvZmZzZXRZPTBcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V9IG93bmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcm94eVBhcmVudElkXz0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICovXG4gICAgICAgIHByb3h5UGFyZW50SWRfOiAnZG9jdW1lbnQuYm9keScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2Nyb2xsQ29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbEZhY3RvckxlZnQ9MVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsRmFjdG9yVG9wPTFcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEZhY3RvclRvcDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgY3JlYXRlcyBhIHBvc2l0aW9uOmFic29sdXRlIHdyYXBwZXIgZGl2IHdoaWNoIGNvbnRhaW5zIHRoZSBjbG9uZWQgZWxlbWVudFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VQcm94eVdyYXBwZXI9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUHJveHlXcmFwcGVyOiB0cnVlXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIGlmICghTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3ApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBub3QgdXNlIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmUgd2l0aG91dCBhZGRpbmcgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3AgdG8gdGhlIG1haW4gdGhyZWFkIGFkZG9ucycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkcmFnUHJveHlDb25maWcgY29uZmlnXG4gICAgICogV2UgYXJlIHJlLXVzaW5nIHRoaXMgY29uZmlnIHRvIGNyZWF0ZSBtdWx0aXBsZSBkcmFnUHJveGllcyxcbiAgICAgKiBzbyBpdCBpcyBpbXBvcnRhbnQgdG8gd29yayB3aXRoIGEgY2xvbmUuIHNlZTogY3JlYXRlRHJhZ1Byb3h5KClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RHJhZ1Byb3h5Q29uZmlnKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uY2xvbmUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVEcmFnUHJveHkoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQobWUuZHJhZ0VsZW1lbnQuaWQpLFxuICAgICAgICAgICAgY2xvbmUgICAgID0gVkRvbVV0aWwuY2xvbmUobWUuZHJhZ0VsZW1lbnQpO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICA6IERyYWdQcm94eUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBtZS5tb3ZlSW5NYWluVGhyZWFkLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgIDogbWUucHJveHlQYXJlbnRJZCxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICA6IG1lLnVzZVByb3h5V3JhcHBlciA/IHtjbjogW2Nsb25lXX0gOiBjbG9uZSxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke21lLm1vdmVIb3Jpem9udGFsID8gZGF0YS5sZWZ0IDogMH1weGAsXG4gICAgICAgICAgICAgICAgdG9wICAgOiBgJHttZS5tb3ZlVmVydGljYWwgICA/IGRhdGEudG9wICA6IDB9cHhgLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7ZGF0YS53aWR0aH1weGBcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC4uLm1lLmRyYWdQcm94eUNvbmZpZyB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbmZpZy5jbHMgPSBjb25maWcuY2xzIHx8IFtdO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaChjb21wb25lbnQuZ2V0VGhlbWUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnVzZVByb3h5V3JhcHBlcikge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKC4uLmNsb25lLmNscyk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5kcmFnUHJveHkgPSBOZW8uY3JlYXRlKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZm9yIHVzaW5nIGN1c3RvbSBhbmltYXRpb25zXG4gICAgICovXG4gICAgZGVzdHJveURyYWdQcm94eSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlkID0gbWUuZHJhZ1Byb3h5LmlkO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIucHJvbWlzZU1lc3NhZ2UoJ21haW4nLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgICAgICBkZWx0YXM6IFt7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBpZH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbWUubW92ZUluTWFpblRocmVhZCA/IDAgOiAzMCk7XG5cbiAgICAgICAgbWUuZHJhZ1Byb3h5LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRyYWdFbmQoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xzICAgPSBvd25lci5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1pcy1kcmFnZ2luZycpO1xuICAgICAgICBvd25lci5jbHMgPSBjbHM7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgbWUuZGVzdHJveURyYWdQcm94eSgpO1xuICAgICAgICAgICAgbWUuZHJhZ1Byb3h5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdCAgOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0WCAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBvZmZzZXRZICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBzdHlsZTtcblxuICAgICAgICBpZiAoIW1lLm1vdmVJbk1haW5UaHJlYWQgJiYgbWUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBzdHlsZSA9IG1lLmRyYWdQcm94eS5zdHlsZTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vdmVIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IGAke2RhdGEuY2xpZW50WCAtIG1lLm9mZnNldFh9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUubW92ZVZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gYCR7ZGF0YS5jbGllbnRZIC0gbWUub2Zmc2V0WX1weGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRyYWdQcm94eS5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xzICAgPSBvd25lci5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1pcy1kcmFnZ2luZycpO1xuICAgICAgICBvd25lci5jbHMgPSBjbHM7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0Q29uZmlncyhtZS5nZXRNYWluVGhyZWFkQ29uZmlncygpKTtcblxuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3MuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHtcbiAgICAgICAgICAgIGlkOiBtZS5kcmFnRWxlbWVudC5pZFxuICAgICAgICB9KS50aGVuKHJlY3QgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdDogcmVjdCxcbiAgICAgICAgICAgICAgICBvZmZzZXRYICAgICAgICA6IGRhdGEuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZICAgICAgICA6IGRhdGEuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuY3JlYXRlRHJhZ1Byb3h5KHJlY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgY2xhc3MgZXh0ZW5zaW9ucyB0byBhZGQgbW9yZSBjb25maWdzXG4gICAgICogd2hpY2ggZ2V0IHBhc3NlZCB0byBtYWluLmFkZG9uLkRyYWdEcm9wIG9uRHJhZ1N0YXJ0KClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRNYWluVGhyZWFkQ29uZmlncygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlIDogbWUuYWx3YXlzRmlyZURyYWdNb3ZlLFxuICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuYm91bmRhcnlDb250YWluZXJJZCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkICA6IG1lLnNjcm9sbENvbnRhaW5lcklkLFxuICAgICAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdCAgIDogbWUuc2Nyb2xsRmFjdG9yTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbEZhY3RvclRvcCAgICA6IG1lLnNjcm9sbEZhY3RvclRvcFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoRHJhZ1pvbmUpO1xuXG5leHBvcnQge0RyYWdab25lIGFzIGRlZmF1bHR9OyIsImltcG9ydCBCYXNlRHJhZ1pvbmUgZnJvbSAnLi4vLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5EcmFnWm9uZVxuICovXG5jbGFzcyBEcmFnWm9uZSBleHRlbmRzIEJhc2VEcmFnWm9uZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS50b29sYmFyLkRyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3Rvb2xiYXItZHJhZ3pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndG9vbGJhci1kcmFnem9uZSdcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IG93bmVyLmRvbUxpc3RlbmVycyxcbiAgICAgICAgICAgIG9wdHMgICAgICAgICA9IHtkZWxlZ2F0ZTogJy5uZW8tZHJhZ2dhYmxlJywgc2NvcGU6IG1lfTtcblxuICAgICAgICBkb21MaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uRHJhZ0VuZCwgICAuLi5vcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzptb3ZlJyA6IG1lLm9uRHJhZ01vdmUsICAuLi5vcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRHJhZ1N0YXJ0LCAuLi5vcHRzfVxuICAgICAgICApO1xuXG4gICAgICAgIG93bmVyLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVycztcblxuICAgICAgICBvd25lci5vbignaW5zZXJ0JywgbWUub25JdGVtSW5zZXJ0LCBtZSk7XG5cbiAgICAgICAgbWUuYWRqdXN0VG9vbGJhckl0ZW1DbHModHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRyYWdnYWJsZVxuICAgICAqL1xuICAgIGFkanVzdFRvb2xiYXJJdGVtQ2xzKGRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgPSBtZS5vd25lcixcbiAgICAgICAgICAgIHZkb20gID0gb3duZXIudmRvbTtcblxuICAgICAgICB2ZG9tLmNuLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmNscyA9IGl0ZW0uY2xzIHx8IFtdO1xuXG4gICAgICAgICAgICBOZW9BcnJheVtkcmFnZ2FibGUgPyAnYWRkJyA6ICdyZW1vdmUnXShpdGVtLmNscywgJ25lby1kcmFnZ2FibGUnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3duZXIudmRvbSA9IHZkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm93bmVyLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJveHkgICAgICAgID0gbWUuZHJhZ1Byb3h5LFxuICAgICAgICAgICAgICAgIGNscyAgICAgICAgICA9IHByb3h5LmNscyB8fCB7fSxcbiAgICAgICAgICAgICAgICByZWN0ICAgICAgICAgPSBtZS5kcmFnRWxlbWVudFJlY3QsXG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlID0gcHJveHkud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWFuaW1hdGUnKTtcbiAgICAgICAgICAgIHByb3h5LmNscyA9IGNscztcblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRvIGdldCBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS50b3AgID0gYCR7cmVjdC50b3B9cHhgO1xuXG4gICAgICAgICAgICAgICAgcHJveHkud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRyYWdFbmQoKTtcbiAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub3duZXIuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBtZS5kcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQobWUub3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tO1xuICAgICAgICAgICAgbWUuZHJhZ1N0YXJ0KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5pbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLml0ZW1cbiAgICAgKi9cbiAgICBvbkl0ZW1JbnNlcnQoZGF0YSkge1xuICAgICAgICBsZXQgaXRlbSA9IGRhdGEuaXRlbSxcbiAgICAgICAgICAgIGNscyAgPSBpdGVtLmNscyB8fCBbXTtcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWRyYWdnYWJsZScpO1xuICAgICAgICBpdGVtLmNscyA9IGNscztcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERyYWdab25lKTtcblxuZXhwb3J0IHtEcmFnWm9uZSBhcyBkZWZhdWx0fTsiLCJpbXBvcnQgRHJhZ1pvbmUgZnJvbSAnLi9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZVxuICovXG5jbGFzcyBTb3J0Wm9uZSBleHRlbmRzIERyYWdab25lIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbGJhci1zb3J0em9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sYmFyLXNvcnR6b25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0tMVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50SW5kZXg6IC0xLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpbmRleE1hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4TWFwOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVJlY3RzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVJlY3RzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVN0eWxlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1TdHlsZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG93bmVyUmVjdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyUmVjdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3duZXJTdHlsZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyU3R5bGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnOiBvbkRyYWdTdGFydCgpIHdpbGwgc2V0IHRoZSB2YWx1ZSB0byBob3Jpem9udGFsIG9yIHZlcnRpY2FsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgbGF5b3V0LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNvcnREaXJlY3Rpb249J2hvcml6b250YWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNvcnREaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc3RhcnRJbmRleD0tMVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydEluZGV4OiAtMVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY2xhc3MgZXh0ZW5zaW9ucyAoZS5nLiB0YWIuaGVhZGVyLlRvb2xiYXIpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgbW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB0aGlzLm93bmVyLm1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciAgICAgID0gbWUub3duZXIsXG4gICAgICAgICAgICBpdGVtU3R5bGVzID0gbWUuaXRlbVN0eWxlcyxcbiAgICAgICAgICAgIG93bmVyU3R5bGUgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZTtcblxuICAgICAgICBvd25lclN0eWxlLmhlaWdodCA9IG1lLm93bmVyU3R5bGUuaGVpZ2h0IHx8IG51bGw7XG4gICAgICAgIG93bmVyU3R5bGUud2lkdGggID0gbWUub3duZXJTdHlsZS53aWR0aCAgfHwgbnVsbDtcblxuICAgICAgICBvd25lci5zdHlsZSA9IG93bmVyU3R5bGU7XG5cbiAgICAgICAgb3duZXIuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW0uc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbVN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGl0ZW1TdHlsZXNbaW5kZXhdLmhlaWdodCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgOiBpdGVtU3R5bGVzW2luZGV4XS53aWR0aCB8fCBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBtZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlLnZpc2liaWxpdHkgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLnN0eWxlID0gaXRlbVN0eWxlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWUuc3RhcnRJbmRleCAhPT0gbWUuY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICBtZS5tb3ZlVG8obWUuc3RhcnRJbmRleCwgbWUuY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogLTEsXG4gICAgICAgICAgICBpbmRleE1hcCAgICA6IG51bGwsXG4gICAgICAgICAgICBpdGVtUmVjdHMgICA6IG51bGwsXG4gICAgICAgICAgICBpdGVtU3R5bGVzICA6IG51bGwsXG4gICAgICAgICAgICBvd25lclJlY3QgICA6IG51bGwsXG4gICAgICAgICAgICBzdGFydEluZGV4ICA6IC0xXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdFbmQoZGF0YSk7IC8vIHdlIGRvIG5vdCB3YW50IHRvIHRyaWdnZXIgdGhlIHN1cGVyIGNsYXNzIGNhbGwgaGVyZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbVJlY3RzKSB7IC8vIHRoZSBtZXRob2QgY2FuIHRyaWdnZXIgYmVmb3JlIHdlIGdvdCB0aGUgY2xpZW50IHJlY3RzIGZyb20gdGhlIG1haW4gdGhyZWFkXG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbW92ZUZhY3RvciA9IDAuNTUsIC8vIHdlIGNhbiBub3QgdXNlIDAuNSwgc2luY2UgaXRlbXMgd291bGQganVtcCBiYWNrICYgZm9ydGhcbiAgICAgICAgICAgICAgICBpbmRleCAgICAgID0gbWUuY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICAgIGl0ZW1SZWN0cyAgPSBtZS5pdGVtUmVjdHMsXG4gICAgICAgICAgICAgICAgZGVsdGEsIGl0ZW1XaWR0aDtcblxuICAgICAgICAgICAgaWYgKG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIGRlbHRhICAgICA9IGRhdGEuY2xpZW50WCAtIG1lLm9mZnNldFggLSBpdGVtUmVjdHNbaW5kZXhdLmxlZnQ7XG4gICAgICAgICAgICAgICAgaXRlbVdpZHRoID0gJ3dpZHRoJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgICAgID0gZGF0YS5jbGllbnRZIC0gbWUub2Zmc2V0WSAtIGl0ZW1SZWN0c1tpbmRleF0udG9wO1xuICAgICAgICAgICAgICAgIGl0ZW1XaWR0aCA9ICdoZWlnaHQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBpdGVtUmVjdHNbaW5kZXggLSAxXVtpdGVtV2lkdGhdICogbW92ZUZhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA8IGl0ZW1SZWN0cy5sZW5ndGggLSAxICYmIGRlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA+IGl0ZW1SZWN0c1tpbmRleCArIDFdW2l0ZW1XaWR0aF0gKiBtb3ZlRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidXR0b24gICAgID0gTmVvLmdldENvbXBvbmVudChkYXRhLnBhdGhbMF0uaWQpLFxuICAgICAgICAgICAgb3duZXIgICAgICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgaXRlbVN0eWxlcyA9IG1lLml0ZW1TdHlsZXMgPSBbXSxcbiAgICAgICAgICAgIG93bmVyU3R5bGUgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGluZGV4LCBpbmRleE1hcCwgaXRlbVN0eWxlLCByZWN0O1xuXG4gICAgICAgIGlmIChvd25lci5zb3J0YWJsZSkge1xuICAgICAgICAgICAgbWUuc29ydERpcmVjdGlvbiA9IG93bmVyLmxheW91dC5udHlwZSA9PT0gJ2xheW91dC12Ym94JyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG5cbiAgICAgICAgICAgIG1lLmRyYWdQcm94eUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZS5kcmFnUHJveHlDb25maWcgfHwge30sXG4gICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZHJhZ3Byb3h5JywgLi4ub3duZXIuY2xzXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbWUuZHJhZ0VsZW1lbnQgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG93bmVyLnZkb20sIGJ1dHRvbi5pZCkudmRvbTtcbiAgICAgICAgICAgIG1lLmRyYWdTdGFydChkYXRhKTsgLy8gd2UgZG8gbm90IHdhbnQgdG8gdHJpZ2dlciB0aGUgc3VwZXIgY2xhc3MgY2FsbCBoZXJlXG5cbiAgICAgICAgICAgIG1lLm93bmVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBvd25lclN0eWxlLmhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IG93bmVyU3R5bGUud2lkdGhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGluZGV4ID0gb3duZXIuaW5kZXhPZihidXR0b24uaWQpO1xuXG4gICAgICAgICAgICBpbmRleE1hcCA9IHt9O1xuXG4gICAgICAgICAgICBvd25lci5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGluZGV4TWFwW2luZGV4XSA9IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtLnN0eWxlICYmIGl0ZW0uc3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGl0ZW0uc3R5bGUgJiYgaXRlbS5zdHlsZS53aWR0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXhNYXAgICAgOiBpbmRleE1hcCxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ICA6IGluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IFtvd25lci5pZF0uY29uY2F0KG93bmVyLml0ZW1zLm1hcChlID0+IGUuaWQpKVxuICAgICAgICAgICAgfSkudGhlbihpdGVtUmVjdHMgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm93bmVyUmVjdCA9IGl0ZW1SZWN0c1swXTtcblxuICAgICAgICAgICAgICAgIG93bmVyU3R5bGUuaGVpZ2h0ID0gYCR7aXRlbVJlY3RzWzBdLmhlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgb3duZXJTdHlsZS53aWR0aCAgPSBgJHtpdGVtUmVjdHNbMF0ud2lkdGh9cHhgO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG9ubHkgcmVhc29uIHdlIGFyZSBhZGp1c3RpbmcgdGhlIHRvb2xiYXIgc3R5bGUgaXMgdGhhdCB0aGVyZSBpcyBubyBtaW4gaGVpZ2h0IG9yIHdpZHRoIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgbGF5b3V0IGNvdWxkIHRyaWdnZXIgYSBjaGFuZ2UgaW4gc2l6ZS5cbiAgICAgICAgICAgICAgICBvd25lci5zdHlsZSA9IG93bmVyU3R5bGU7XG5cbiAgICAgICAgICAgICAgICBpdGVtUmVjdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBtZS5pdGVtUmVjdHMgPSBpdGVtUmVjdHM7XG5cbiAgICAgICAgICAgICAgICBvd25lci5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtLnN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZWN0ICAgICAgPSBpdGVtUmVjdHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbVN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgIDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBgJHtyZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAgIDogYCR7cmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZSA9IGl0ZW1TdHlsZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBidXR0b24uc3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zdHlsZSA9IGl0ZW1TdHlsZTtcbiAgICAgICAgICAgICAgICB9LCAzMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDJcbiAgICAgKi9cbiAgICBzd2l0Y2hJdGVtcyhpbmRleDEsIGluZGV4Mikge1xuICAgICAgICBsZXQgdG1wO1xuXG4gICAgICAgIGlmIChpbmRleDIgPCBpbmRleDEpIHtcbiAgICAgICAgICAgIHRtcCAgICA9IGluZGV4MTtcbiAgICAgICAgICAgIGluZGV4MSA9IGluZGV4MjtcbiAgICAgICAgICAgIGluZGV4MiA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbVJlY3RzID0gbWUuaXRlbVJlY3RzLFxuICAgICAgICAgICAgbWFwICAgICAgID0gbWUuaW5kZXhNYXAsXG4gICAgICAgICAgICByZWN0MSAgICAgPSBpdGVtUmVjdHNbaW5kZXgxXSxcbiAgICAgICAgICAgIHJlY3QyICAgICA9IGl0ZW1SZWN0c1tpbmRleDJdLFxuICAgICAgICAgICAgcmVjdDFDb3B5ID0gey4uLnJlY3QxfSxcbiAgICAgICAgICAgIHJlY3QyQ29weSA9IHsuLi5yZWN0Mn07XG5cbiAgICAgICAgaWYgKG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgcmVjdDEud2lkdGggPSByZWN0MkNvcHkud2lkdGg7XG4gICAgICAgICAgICByZWN0Mi5sZWZ0ICA9IHJlY3QxQ29weS5sZWZ0ICsgcmVjdDJDb3B5LndpZHRoO1xuICAgICAgICAgICAgcmVjdDIud2lkdGggPSByZWN0MUNvcHkud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN0MS5oZWlnaHQgPSByZWN0MkNvcHkuaGVpZ2h0O1xuICAgICAgICAgICAgcmVjdDIuaGVpZ2h0ID0gcmVjdDFDb3B5LmhlaWdodDtcbiAgICAgICAgICAgIHJlY3QyLnRvcCAgICA9IHJlY3QxQ29weS50b3AgKyByZWN0MkNvcHkuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wICAgICAgICAgPSBtYXBbaW5kZXgxXTtcbiAgICAgICAgbWFwW2luZGV4MV0gPSBtYXBbaW5kZXgyXTtcbiAgICAgICAgbWFwW2luZGV4Ml0gPSB0bXA7XG5cbiAgICAgICAgbWUudXBkYXRlSXRlbShpbmRleDEsIHJlY3QxKTtcbiAgICAgICAgbWUudXBkYXRlSXRlbShpbmRleDIsIHJlY3QyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICovXG4gICAgdXBkYXRlSXRlbShpbmRleCwgcmVjdCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSAgPSBtZS5vd25lci5pdGVtc1ttZS5pbmRleE1hcFtpbmRleF1dLFxuICAgICAgICAgICAgc3R5bGUgPSBpdGVtLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICBzdHlsZS50b3AgID0gYCR7cmVjdC50b3B9cHhgO1xuXG4gICAgICAgIGl0ZW0uc3R5bGUgPSBzdHlsZTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFNvcnRab25lKTtcblxuZXhwb3J0IHtTb3J0Wm9uZSBhcyBkZWZhdWx0fTsiXSwic291cmNlUm9vdCI6IiJ9