self["webpackChunk"](["vendors~src/draggable/tab/header/toolbar/SortZone-mjs.js~src/draggable/toolbar/SortZone-mjs.js"],{

/***/ "./src/draggable/DragProxyComponent.mjs":
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragProxyComponent; });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {Boolean} autoRender=true
         */
        autoRender: true,
        /**
         * @member {String[]} cls=['neo-dragproxy']
         */
        cls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me = this;

        me.on('mounted', me.onMounted, me);
    }

    /**
     *
     * @param {String} id
     */
    onMounted(id) {
        if (this.moveInMainThread) {
            Neo.main.addon.DragDrop.setDragProxyElement({
                id: id
            });
        }
    }
}

Neo.applyClassConfig(DragProxyComponent);



/***/ }),

/***/ "./src/draggable/DragZone.mjs":
/*!************************************!*\
  !*** ./src/draggable/DragZone.mjs ***!
  \************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragZone; });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @class Neo.draggable.DragZone
 * @extends Neo.core.Base
 */
class DragZone extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragZone'
         * @protected
         */
        className: 'Neo.draggable.DragZone',
        /**
         * @member {String} ntype='dragzone'
         * @protected
         */
        ntype: 'dragzone',
        /**
         * drag:move will by default only fire in case moveInMainThread === false.
         * In case you want to move the dragProxy inside main but still get the event,
         * set this config to true.
         * @member {Boolean} alwaysFireDragMove=false
         */
        alwaysFireDragMove: false,
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName=null
         */
        appName: null,
        /**
         * @member {String|null} boundaryContainerId=null
         */
        boundaryContainerId: null,
        /**
         * The vdom (tree) of the element you want to drag
         * @member {Object|null} dragElement=null
         */
        dragElement: null,
        /**
         * The bounding client rect of the dragElement
         * Will get set inside dragStart()
         * @member {Object|null} dragElementRect=null
         */
        dragElementRect: null,
        /**
         * @member {Neo.component.Base|null} dragProxy=null
         * @protected
         */
        dragProxy: null,
        /**
         * @member {Object|null} dragProxyConfig=null
         */
        dragProxyConfig: null,
        /**
         * @member {Boolean} moveHorizontal=true
         */
        moveHorizontal: true,
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true,
        /**
         * @member {Boolean} moveVertical=true
         */
        moveVertical: true,
        /**
         * @member {Number} offsetX=0
         */
        offsetX: 0,
        /**
         * @member {Number} offsetY=0
         */
        offsetY: 0,
        /**
         * @member {Neo.component.Base} owner=null
         */
        owner: null,
        /**
         * @member {String} proxyParentId_='document.body'
         */
        proxyParentId_: 'document.body',
        /**
         * @member {String|null} scrollContainerId=null
         */
        scrollContainerId: null,
        /**
         * @member {Number} scrollFactorLeft=1
         */
        scrollFactorLeft: 1,
        /**
         * @member {Number} scrollFactorTop=1
         */
        scrollFactorTop: 1,
        /**
         * True creates a position:absolute wrapper div which contains the cloned element
         * @member {Boolean} useProxyWrapper=true
         */
        useProxyWrapper: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        if (!Neo.main.addon.DragDrop) {
            throw new Error('You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons');
        }
    }

    /**
     *
     * @param {Object} data
     */
    createDragProxy(data) {
        let me    = this,
            clone = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(me.dragElement);

        const config = {
            module          : _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            vdom            : me.useProxyWrapper ? {cn: [clone]} : clone,

            style: {
                height: `${data.height}px`,
                left  : `${me.moveHorizontal ? data.left : 0}px`,
                top   : `${me.moveVertical   ? data.top  : 0}px`,
                width : `${data.width}px`
            },

            ...me.dragProxyConfig || {}
        };

        if (!me.useProxyWrapper) {
            config.cls = clone.cls;
        }

        me.dragProxy = Neo.create(config);
    }

    /**
     * Override for using custom animations
     */
    destroyDragProxy() {
        let me = this,
            id = me.dragProxy.id;

        setTimeout(() => {
            Neo.currentWorker.promiseMessage('main', {
                action: 'updateDom',
                deltas: [{action: 'removeNode', id: id}]
            });
        }, me.moveInMainThread ? 0 : 30);

        me.dragProxy.destroy();
    }

    /**
     *
     */
    dragEnd() {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, 'neo-is-dragging');
        owner.cls = cls;

        if (me.dragProxy) {
            me.destroyDragProxy();
            me.dragProxy = null;
        }

        Object.assign(me, {
            dragElementRect  : null,
            offsetX          : 0,
            offsetY          : 0,
            scrollContainerId: null
        });
    }

    /**
     *
     * @param {Object} data
     */
    dragMove(data) {
        let me = this,
            style;

        if (!me.moveInMainThread && me.dragProxy) {
            style = me.dragProxy.style;

            if (me.moveHorizontal) {
                style.left = `${data.clientX - me.offsetX}px`;
            }

            if (me.moveVertical) {
                style.top = `${data.clientY - me.offsetY}px`;
            }

            me.dragProxy.style = style;
        }
    }

    /**
     *
     * @param {Object} data
     */
    dragStart(data) {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(cls, 'neo-is-dragging');
        owner.cls = cls;

        Neo.main.addon.DragDrop.setConfigs(me.getMainThreadConfigs());

        Neo.main.DomAccess.getBoundingClientRect({
            id: me.dragElement.id
        }).then(rect => {
            Object.assign(me, {
                dragElementRect: rect,
                offsetX        : data.clientX - rect.left,
                offsetY        : data.clientY - rect.top
            });

            me.createDragProxy(rect);
        });
    }

    /**
     * Override this method inside class extensions to add more configs
     * which get passed to main.addon.DragDrop onDragStart()
     * @returns {Object}
     * @protected
     */
    getMainThreadConfigs() {
        let me = this;

        return {
            alwaysFireDragMove : me.alwaysFireDragMove,
            boundaryContainerId: me.boundaryContainerId,
            scrollContainerId  : me.scrollContainerId,
            scrollFactorLeft   : me.scrollFactorLeft,
            scrollFactorTop    : me.scrollFactorTop
        };
    }
}

Neo.applyClassConfig(DragZone);



/***/ }),

/***/ "./src/draggable/toolbar/DragZone.mjs":
/*!********************************************!*\
  !*** ./src/draggable/toolbar/DragZone.mjs ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragZone; });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.draggable.toolbar.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.toolbar.DragZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.DragZone',
        /**
         * @member {String} ntype='toolbar-dragzone'
         * @protected
         */
        ntype: 'toolbar-dragzone',
        /**
         * @member {Object|null} dragProxyConfig
         */
        dragProxyConfig: {
            cls: ['neo-dragproxy', 'neo-toolbar']
        }
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me           = this,
            owner        = me.owner,
            domListeners = owner.domListeners,
            opts         = {delegate: '.neo-draggable', scope: me};

        domListeners.push(
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        );

        owner.domListeners = domListeners;

        me.adjustToolbarItemCls(true);
    }

    /**
     *
     * @param {Boolean} draggable
     */
    adjustToolbarItemCls(draggable) {
        let me    = this,
            owner = me.owner,
            vdom  = owner.vdom;

        vdom.cn.forEach(item => {
            item.cls = item.cls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][draggable ? 'add' : 'remove'](item.cls, 'neo-draggable');
        });

        owner.vdom = vdom;
    }

    /**
     *
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            setTimeout(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                setTimeout(() => {
                    me.dragEnd();
                }, 300);
            }, 30);
        }
    }

    /**
     *
     * @param {Object} data
     */
    onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findVdomChild(me.owner.vdom, data.path[0].id).vdom;
            me.dragStart(data);
        }
    }
}

Neo.applyClassConfig(DragZone);



/***/ }),

/***/ "./src/draggable/toolbar/SortZone.mjs":
/*!********************************************!*\
  !*** ./src/draggable/toolbar/SortZone.mjs ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SortZone; });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./src/draggable/toolbar/DragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @class Neo.draggable.toolbar.SortZone
 * @extends Neo.draggable.toolbar.DragZone
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.toolbar.SortZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.SortZone',
        /**
         * @member {String} ntype='toolbar-sortzone'
         * @protected
         */
        ntype: 'toolbar-sortzone',
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }}

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     *
     * @param {Object} data
     */
    onDragEnd(data) {
        let me         = this,
            owner      = me.owner,
            itemStyles = me.itemStyles,
            ownerStyle = owner.style || {},
            itemStyle;

        ownerStyle.height = me.ownerStyle.height || null;
        ownerStyle.width  = me.ownerStyle.width  || null;

        owner.style = ownerStyle;

        owner.items.forEach((item, index) => {
            itemStyle = item.style || {};

            Object.assign(itemStyle, {
                height  : itemStyles[index].height || null,
                left    : null,
                position: null,
                top     : null,
                width   : itemStyles[index].width || null
            });

            if (index === me.startIndex) {
                itemStyle.visibility = null;
            }

            item.style = itemStyle;
        });

        if (me.startIndex !== me.currentIndex) {
            me.moveTo(me.startIndex, me.currentIndex);
        }

        Object.assign(me, {
            currentIndex: -1,
            indexMap    : null,
            itemRects   : null,
            itemStyles  : null,
            ownerRect   : null,
            startIndex  : -1
        });

        me.dragEnd(data); // we do not want to trigger the super class call here
    }

    /**
     *
     * @param {Object} data
     */
    onDragMove(data) {
        if (this.itemRects) { // the method can trigger before we got the client rects from the main thread
            let me         = this,
                moveFactor = 0.55, // we can not use 0.5, since items would jump back & forth
                index      = me.currentIndex,
                itemRects  = me.itemRects,
                deltaX     = data.clientX - me.offsetX - me.itemRects[index].left;

            if (index > 0 && deltaX < 0) {
                if (Math.abs(deltaX) > itemRects[index - 1].width * moveFactor) {
                    me.currentIndex--;
                    me.switchItems(index, me.currentIndex);
                }
            }

            else if (index < itemRects.length - 1 && deltaX > 0) {
                if (deltaX > itemRects[index + 1].width * moveFactor) {
                    me.currentIndex++;
                    me.switchItems(index, me.currentIndex);
                }
            }
        }
    }

    /**
     *
     * @param {Object} data
     */
    onDragStart(data) {
        let me         = this,
            button     = Neo.getComponent(data.path[0].id),
            owner      = me.owner,
            itemStyles = me.itemStyles = [],
            ownerStyle = owner.style || {},
            index, indexMap, itemStyle, rect;

        if (owner.sortable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].findVdomChild(owner.vdom, button.id).vdom;
            me.dragStart(data); // we do not want to trigger the super class call here

            me.ownerStyle = {
                height: ownerStyle.height,
                width : ownerStyle.width
            };

            index = owner.indexOf(button.id);

            indexMap = {};

            owner.items.forEach((item, index) => {
                indexMap[index] = index;

                itemStyles.push({
                    height: item.style && item.style.height,
                    width : item.style && item.style.width
                })
            });

            Object.assign(me, {
                currentIndex: index,
                indexMap    : indexMap,
                startIndex  : index
            });

            Neo.main.DomAccess.getBoundingClientRect({
                id: [owner.id].concat(owner.items.map(e => e.id))
            }).then(itemRects => {
                me.ownerRect = itemRects[0];

                ownerStyle.height = `${itemRects[0].height}px`;
                ownerStyle.width  = `${itemRects[0].width}px`;

                owner.style = ownerStyle;

                itemRects.shift();
                me.itemRects = itemRects;

                owner.items.forEach((item, index) => {
                    itemStyle = item.style || {};
                    rect      = itemRects[index];

                    Object.assign(itemStyle, {
                        height  : `${rect.height}px`,
                        left    : `${rect.left}px`,
                        position: 'absolute',
                        top     : `${rect.top}px`,
                        width   : `${rect.width}px`
                    });

                    item.style = itemStyle;
                });

                setTimeout(() => {
                    itemStyle = button.style || {};
                    itemStyle.visibility = 'hidden';
                    button.style = itemStyle;
                }, 30);
            });
        }
    }

    /**
     *
     * @param {Number} index1
     * @param {Number} index2
     */
    switchItems(index1, index2) {
        let tmp;

        if (index2 < index1) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp;
        }

        let me        = this,
            itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = {...itemRects[index1]},
            rect2     = {...itemRects[index2]};

        Object.assign(itemRects[index1], {
            width: rect2.width
        });

        Object.assign(itemRects[index2], {
            left : rect1.left + rect2.width,
            width: rect1.width
        });

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, itemRects[index1]);
        me.updateItem(index2, itemRects[index2]);
    }

    /**
     *
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me    = this,
            item  = me.owner.items[me.indexMap[index]],
            style = item.style;

        Object.assign(style, {
            left: `${rect.left}px`,
            top : `${rect.top}px`
        });

        item.style = style;
    }
}

Neo.applyClassConfig(SortZone);



/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZHJhZ2dhYmxlL0RyYWdQcm94eUNvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RyYWdnYWJsZS90b29sYmFyL0RyYWdab25lLm1qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJEQUFJO0FBQ3JDLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBa0Q7QUFDUTtBQUNQO0FBQ0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFlBQVk7QUFDakQscUNBQXFDLFVBQVU7QUFDL0M7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QyxxQ0FBcUMsV0FBVztBQUNoRCxxQkFBcUI7O0FBRXJCO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQixxQkFBcUIsU0FBUztBQUM5QixTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJ2ZW5kb3JzfnNyYy9kcmFnZ2FibGUvdGFiL2hlYWRlci90b29sYmFyL1NvcnRab25lLW1qcy5qc35zcmMvZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUtbWpzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBEcmFnUHJveHlDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2RyYWdwcm94eSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFncHJveHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9SZW5kZXI9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1JlbmRlcjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8tZHJhZ3Byb3h5J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWVcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5vbignbW91bnRlZCcsIG1lLm9uTW91bnRlZCwgbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICovXG4gICAgb25Nb3VudGVkKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVJbk1haW5UaHJlYWQpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldERyYWdQcm94eUVsZW1lbnQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERyYWdQcm94eUNvbXBvbmVudCk7XG5cbmV4cG9ydCB7RHJhZ1Byb3h5Q29tcG9uZW50IGFzIGRlZmF1bHR9OyIsImltcG9ydCBCYXNlICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50IGZyb20gJy4vRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1pvbmUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFnem9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFnem9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnOm1vdmUgd2lsbCBieSBkZWZhdWx0IG9ubHkgZmlyZSBpbiBjYXNlIG1vdmVJbk1haW5UaHJlYWQgPT09IGZhbHNlLlxuICAgICAgICAgKiBJbiBjYXNlIHlvdSB3YW50IHRvIG1vdmUgdGhlIGRyYWdQcm94eSBpbnNpZGUgbWFpbiBidXQgc3RpbGwgZ2V0IHRoZSBldmVudCxcbiAgICAgICAgICogc2V0IHRoaXMgY29uZmlnIHRvIHRydWUuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBpbnN0YW5jZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhcHBOYW1lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYm91bmRhcnlDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gKHRyZWUpIG9mIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIGRyYWdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdFbGVtZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdFbGVtZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBkcmFnRWxlbWVudFxuICAgICAgICAgKiBXaWxsIGdldCBzZXQgaW5zaWRlIGRyYWdTdGFydCgpXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnRWxlbWVudFJlY3Q9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0VsZW1lbnRSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGRyYWdQcm94eT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdQcm94eTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnUHJveHlDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUhvcml6b250YWw9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUhvcml6b250YWw6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlVmVydGljYWw9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVZlcnRpY2FsOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBvZmZzZXRYPTBcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG9mZnNldFk9MFxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHByb3h5UGFyZW50SWRfPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKi9cbiAgICAgICAgcHJveHlQYXJlbnRJZF86ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzY3JvbGxDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxDb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsRmFjdG9yTGVmdD0xXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxGYWN0b3JMZWZ0OiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxGYWN0b3JUb3A9MVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yVG9wOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBjcmVhdGVzIGEgcG9zaXRpb246YWJzb2x1dGUgd3JhcHBlciBkaXYgd2hpY2ggY29udGFpbnMgdGhlIGNsb25lZCBlbGVtZW50XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVByb3h5V3JhcHBlcj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VQcm94eVdyYXBwZXI6IHRydWVcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG5vdCB1c2UgTmVvLmRyYWdnYWJsZS5EcmFnWm9uZSB3aXRob3V0IGFkZGluZyBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcCB0byB0aGUgbWFpbiB0aHJlYWQgYWRkb25zJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgY3JlYXRlRHJhZ1Byb3h5KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNsb25lID0gVkRvbVV0aWwuY2xvbmUobWUuZHJhZ0VsZW1lbnQpO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICA6IERyYWdQcm94eUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBtZS5tb3ZlSW5NYWluVGhyZWFkLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgIDogbWUucHJveHlQYXJlbnRJZCxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICA6IG1lLnVzZVByb3h5V3JhcHBlciA/IHtjbjogW2Nsb25lXX0gOiBjbG9uZSxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke21lLm1vdmVIb3Jpem9udGFsID8gZGF0YS5sZWZ0IDogMH1weGAsXG4gICAgICAgICAgICAgICAgdG9wICAgOiBgJHttZS5tb3ZlVmVydGljYWwgICA/IGRhdGEudG9wICA6IDB9cHhgLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7ZGF0YS53aWR0aH1weGBcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC4uLm1lLmRyYWdQcm94eUNvbmZpZyB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghbWUudXNlUHJveHlXcmFwcGVyKSB7XG4gICAgICAgICAgICBjb25maWcuY2xzID0gY2xvbmUuY2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZHJhZ1Byb3h5ID0gTmVvLmNyZWF0ZShjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZvciB1c2luZyBjdXN0b20gYW5pbWF0aW9uc1xuICAgICAqL1xuICAgIGRlc3Ryb3lEcmFnUHJveHkoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZCA9IG1lLmRyYWdQcm94eS5pZDtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3VwZGF0ZURvbScsXG4gICAgICAgICAgICAgICAgZGVsdGFzOiBbe2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZDogaWR9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIG1lLm1vdmVJbk1haW5UaHJlYWQgPyAwIDogMzApO1xuXG4gICAgICAgIG1lLmRyYWdQcm94eS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkcmFnRW5kKCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGNscyAgID0gb3duZXIuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8taXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgb3duZXIuY2xzID0gY2xzO1xuXG4gICAgICAgIGlmIChtZS5kcmFnUHJveHkpIHtcbiAgICAgICAgICAgIG1lLmRlc3Ryb3lEcmFnUHJveHkoKTtcbiAgICAgICAgICAgIG1lLmRyYWdQcm94eSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3QgIDogbnVsbCxcbiAgICAgICAgICAgIG9mZnNldFggICAgICAgICAgOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJJZDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGU7XG5cbiAgICAgICAgaWYgKCFtZS5tb3ZlSW5NYWluVGhyZWFkICYmIG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgc3R5bGUgPSBtZS5kcmFnUHJveHkuc3R5bGU7XG5cbiAgICAgICAgICAgIGlmIChtZS5tb3ZlSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBgJHtkYXRhLmNsaWVudFggLSBtZS5vZmZzZXRYfXB4YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLm1vdmVWZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLnRvcCA9IGAke2RhdGEuY2xpZW50WSAtIG1lLm9mZnNldFl9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5kcmFnUHJveHkuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGNscyAgID0gb3duZXIuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8taXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgb3duZXIuY2xzID0gY2xzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldENvbmZpZ3MobWUuZ2V0TWFpblRocmVhZENvbmZpZ3MoKSk7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7XG4gICAgICAgICAgICBpZDogbWUuZHJhZ0VsZW1lbnQuaWRcbiAgICAgICAgfSkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3QsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCAgICAgICAgOiBkYXRhLmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgOiBkYXRhLmNsaWVudFkgLSByZWN0LnRvcFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmNyZWF0ZURyYWdQcm94eShyZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIGNsYXNzIGV4dGVuc2lvbnMgdG8gYWRkIG1vcmUgY29uZmlnc1xuICAgICAqIHdoaWNoIGdldCBwYXNzZWQgdG8gbWFpbi5hZGRvbi5EcmFnRHJvcCBvbkRyYWdTdGFydCgpXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0TWFpblRocmVhZENvbmZpZ3MoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsd2F5c0ZpcmVEcmFnTW92ZSA6IG1lLmFsd2F5c0ZpcmVEcmFnTW92ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG1lLmJvdW5kYXJ5Q29udGFpbmVySWQsXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJJZCAgOiBtZS5zY3JvbGxDb250YWluZXJJZCxcbiAgICAgICAgICAgIHNjcm9sbEZhY3RvckxlZnQgICA6IG1lLnNjcm9sbEZhY3RvckxlZnQsXG4gICAgICAgICAgICBzY3JvbGxGYWN0b3JUb3AgICAgOiBtZS5zY3JvbGxGYWN0b3JUb3BcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERyYWdab25lKTtcblxuZXhwb3J0IHtEcmFnWm9uZSBhcyBkZWZhdWx0fTsiLCJpbXBvcnQgQmFzZURyYWdab25lIGZyb20gJy4uLy4uL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqL1xuY2xhc3MgRHJhZ1pvbmUgZXh0ZW5kcyBCYXNlRHJhZ1pvbmUge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuRHJhZ1pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyLWRyYWd6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXItZHJhZ3pvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdQcm94eUNvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5Q29uZmlnOiB7XG4gICAgICAgICAgICBjbHM6IFsnbmVvLWRyYWdwcm94eScsICduZW8tdG9vbGJhciddXG4gICAgICAgIH1cbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IG93bmVyLmRvbUxpc3RlbmVycyxcbiAgICAgICAgICAgIG9wdHMgICAgICAgICA9IHtkZWxlZ2F0ZTogJy5uZW8tZHJhZ2dhYmxlJywgc2NvcGU6IG1lfTtcblxuICAgICAgICBkb21MaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uRHJhZ0VuZCwgICAuLi5vcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzptb3ZlJyA6IG1lLm9uRHJhZ01vdmUsICAuLi5vcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRHJhZ1N0YXJ0LCAuLi5vcHRzfVxuICAgICAgICApO1xuXG4gICAgICAgIG93bmVyLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVycztcblxuICAgICAgICBtZS5hZGp1c3RUb29sYmFySXRlbUNscyh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJhZ2dhYmxlXG4gICAgICovXG4gICAgYWRqdXN0VG9vbGJhckl0ZW1DbHMoZHJhZ2dhYmxlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgdmRvbSAgPSBvd25lci52ZG9tO1xuXG4gICAgICAgIHZkb20uY24uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uY2xzID0gaXRlbS5jbHMgfHwgW107XG5cbiAgICAgICAgICAgIE5lb0FycmF5W2RyYWdnYWJsZSA/ICdhZGQnIDogJ3JlbW92ZSddKGl0ZW0uY2xzLCAnbmVvLWRyYWdnYWJsZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvd25lci52ZG9tID0gdmRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMub3duZXIuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwcm94eSAgICAgICAgPSBtZS5kcmFnUHJveHksXG4gICAgICAgICAgICAgICAgY2xzICAgICAgICAgID0gcHJveHkuY2xzIHx8IHt9LFxuICAgICAgICAgICAgICAgIHJlY3QgICAgICAgICA9IG1lLmRyYWdFbGVtZW50UmVjdCxcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBwcm94eS53cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tYW5pbWF0ZScpO1xuICAgICAgICAgICAgcHJveHkuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gZ2V0IGludG8gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IGAke3JlY3QubGVmdH1weGA7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLnRvcCAgPSBgJHtyZWN0LnRvcH1weGA7XG5cbiAgICAgICAgICAgICAgICBwcm94eS53cmFwcGVyU3R5bGUgPSB3cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ0VuZCgpO1xuICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICB9LCAzMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5vd25lci5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIG1lLmRyYWdFbGVtZW50ID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS5vd25lci52ZG9tLCBkYXRhLnBhdGhbMF0uaWQpLnZkb207XG4gICAgICAgICAgICBtZS5kcmFnU3RhcnQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERyYWdab25lKTtcblxuZXhwb3J0IHtEcmFnWm9uZSBhcyBkZWZhdWx0fTsiLCJpbXBvcnQgRHJhZ1pvbmUgZnJvbSAnLi9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZVxuICovXG5jbGFzcyBTb3J0Wm9uZSBleHRlbmRzIERyYWdab25lIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbGJhci1zb3J0em9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sYmFyLXNvcnR6b25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0tMVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50SW5kZXg6IC0xLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpbmRleE1hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4TWFwOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVJlY3RzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVJlY3RzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVN0eWxlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1TdHlsZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG93bmVyUmVjdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyUmVjdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3duZXJTdHlsZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyU3R5bGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHN0YXJ0SW5kZXg9LTFcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRJbmRleDogLTFcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgZm9yIGNsYXNzIGV4dGVuc2lvbnMgKGUuZy4gdGFiLmhlYWRlci5Ub29sYmFyKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleFxuICAgICAqL1xuICAgIG1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgdGhpcy5vd25lci5tb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgICAgICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgaXRlbVN0eWxlcyA9IG1lLml0ZW1TdHlsZXMsXG4gICAgICAgICAgICBvd25lclN0eWxlID0gb3duZXIuc3R5bGUgfHwge30sXG4gICAgICAgICAgICBpdGVtU3R5bGU7XG5cbiAgICAgICAgb3duZXJTdHlsZS5oZWlnaHQgPSBtZS5vd25lclN0eWxlLmhlaWdodCB8fCBudWxsO1xuICAgICAgICBvd25lclN0eWxlLndpZHRoICA9IG1lLm93bmVyU3R5bGUud2lkdGggIHx8IG51bGw7XG5cbiAgICAgICAgb3duZXIuc3R5bGUgPSBvd25lclN0eWxlO1xuXG4gICAgICAgIG93bmVyLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW1TdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgOiBpdGVtU3R5bGVzW2luZGV4XS5oZWlnaHQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICB0b3AgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgIDogaXRlbVN0eWxlc1tpbmRleF0ud2lkdGggfHwgbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbWUuc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZS52aXNpYmlsaXR5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5zdHlsZSA9IGl0ZW1TdHlsZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1lLnN0YXJ0SW5kZXggIT09IG1lLmN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgbWUubW92ZVRvKG1lLnN0YXJ0SW5kZXgsIG1lLmN1cnJlbnRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXg6IC0xLFxuICAgICAgICAgICAgaW5kZXhNYXAgICAgOiBudWxsLFxuICAgICAgICAgICAgaXRlbVJlY3RzICAgOiBudWxsLFxuICAgICAgICAgICAgaXRlbVN0eWxlcyAgOiBudWxsLFxuICAgICAgICAgICAgb3duZXJSZWN0ICAgOiBudWxsLFxuICAgICAgICAgICAgc3RhcnRJbmRleCAgOiAtMVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kcmFnRW5kKGRhdGEpOyAvLyB3ZSBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIHRoZSBzdXBlciBjbGFzcyBjYWxsIGhlcmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1SZWN0cykgeyAvLyB0aGUgbWV0aG9kIGNhbiB0cmlnZ2VyIGJlZm9yZSB3ZSBnb3QgdGhlIGNsaWVudCByZWN0cyBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG1vdmVGYWN0b3IgPSAwLjU1LCAvLyB3ZSBjYW4gbm90IHVzZSAwLjUsIHNpbmNlIGl0ZW1zIHdvdWxkIGp1bXAgYmFjayAmIGZvcnRoXG4gICAgICAgICAgICAgICAgaW5kZXggICAgICA9IG1lLmN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgICBpdGVtUmVjdHMgID0gbWUuaXRlbVJlY3RzLFxuICAgICAgICAgICAgICAgIGRlbHRhWCAgICAgPSBkYXRhLmNsaWVudFggLSBtZS5vZmZzZXRYIC0gbWUuaXRlbVJlY3RzW2luZGV4XS5sZWZ0O1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGFYKSA+IGl0ZW1SZWN0c1tpbmRleCAtIDFdLndpZHRoICogbW92ZUZhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA8IGl0ZW1SZWN0cy5sZW5ndGggLSAxICYmIGRlbHRhWCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFYID4gaXRlbVJlY3RzW2luZGV4ICsgMV0ud2lkdGggKiBtb3ZlRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidXR0b24gICAgID0gTmVvLmdldENvbXBvbmVudChkYXRhLnBhdGhbMF0uaWQpLFxuICAgICAgICAgICAgb3duZXIgICAgICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgaXRlbVN0eWxlcyA9IG1lLml0ZW1TdHlsZXMgPSBbXSxcbiAgICAgICAgICAgIG93bmVyU3R5bGUgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGluZGV4LCBpbmRleE1hcCwgaXRlbVN0eWxlLCByZWN0O1xuXG4gICAgICAgIGlmIChvd25lci5zb3J0YWJsZSkge1xuICAgICAgICAgICAgbWUuZHJhZ0VsZW1lbnQgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG93bmVyLnZkb20sIGJ1dHRvbi5pZCkudmRvbTtcbiAgICAgICAgICAgIG1lLmRyYWdTdGFydChkYXRhKTsgLy8gd2UgZG8gbm90IHdhbnQgdG8gdHJpZ2dlciB0aGUgc3VwZXIgY2xhc3MgY2FsbCBoZXJlXG5cbiAgICAgICAgICAgIG1lLm93bmVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBvd25lclN0eWxlLmhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IG93bmVyU3R5bGUud2lkdGhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGluZGV4ID0gb3duZXIuaW5kZXhPZihidXR0b24uaWQpO1xuXG4gICAgICAgICAgICBpbmRleE1hcCA9IHt9O1xuXG4gICAgICAgICAgICBvd25lci5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGluZGV4TWFwW2luZGV4XSA9IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtLnN0eWxlICYmIGl0ZW0uc3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGl0ZW0uc3R5bGUgJiYgaXRlbS5zdHlsZS53aWR0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXhNYXAgICAgOiBpbmRleE1hcCxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ICA6IGluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IFtvd25lci5pZF0uY29uY2F0KG93bmVyLml0ZW1zLm1hcChlID0+IGUuaWQpKVxuICAgICAgICAgICAgfSkudGhlbihpdGVtUmVjdHMgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm93bmVyUmVjdCA9IGl0ZW1SZWN0c1swXTtcblxuICAgICAgICAgICAgICAgIG93bmVyU3R5bGUuaGVpZ2h0ID0gYCR7aXRlbVJlY3RzWzBdLmhlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgb3duZXJTdHlsZS53aWR0aCAgPSBgJHtpdGVtUmVjdHNbMF0ud2lkdGh9cHhgO1xuXG4gICAgICAgICAgICAgICAgb3duZXIuc3R5bGUgPSBvd25lclN0eWxlO1xuXG4gICAgICAgICAgICAgICAgaXRlbVJlY3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbWUuaXRlbVJlY3RzID0gaXRlbVJlY3RzO1xuXG4gICAgICAgICAgICAgICAgb3duZXIuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlID0gaXRlbS5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCAgICAgID0gaXRlbVJlY3RzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW1TdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgICAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgICAgIDogYCR7cmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggICA6IGAke3JlY3Qud2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUgPSBpdGVtU3R5bGU7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlID0gYnV0dG9uLnN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uc3R5bGUgPSBpdGVtU3R5bGU7XG4gICAgICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgyXG4gICAgICovXG4gICAgc3dpdGNoSXRlbXMoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgbGV0IHRtcDtcblxuICAgICAgICBpZiAoaW5kZXgyIDwgaW5kZXgxKSB7XG4gICAgICAgICAgICB0bXAgICAgPSBpbmRleDE7XG4gICAgICAgICAgICBpbmRleDEgPSBpbmRleDI7XG4gICAgICAgICAgICBpbmRleDIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1SZWN0cyA9IG1lLml0ZW1SZWN0cyxcbiAgICAgICAgICAgIG1hcCAgICAgICA9IG1lLmluZGV4TWFwLFxuICAgICAgICAgICAgcmVjdDEgICAgID0gey4uLml0ZW1SZWN0c1tpbmRleDFdfSxcbiAgICAgICAgICAgIHJlY3QyICAgICA9IHsuLi5pdGVtUmVjdHNbaW5kZXgyXX07XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihpdGVtUmVjdHNbaW5kZXgxXSwge1xuICAgICAgICAgICAgd2lkdGg6IHJlY3QyLndpZHRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbVJlY3RzW2luZGV4Ml0sIHtcbiAgICAgICAgICAgIGxlZnQgOiByZWN0MS5sZWZ0ICsgcmVjdDIud2lkdGgsXG4gICAgICAgICAgICB3aWR0aDogcmVjdDEud2lkdGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG1wICAgICAgICAgPSBtYXBbaW5kZXgxXTtcbiAgICAgICAgbWFwW2luZGV4MV0gPSBtYXBbaW5kZXgyXTtcbiAgICAgICAgbWFwW2luZGV4Ml0gPSB0bXA7XG5cbiAgICAgICAgbWUudXBkYXRlSXRlbShpbmRleDEsIGl0ZW1SZWN0c1tpbmRleDFdKTtcbiAgICAgICAgbWUudXBkYXRlSXRlbShpbmRleDIsIGl0ZW1SZWN0c1tpbmRleDJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICovXG4gICAgdXBkYXRlSXRlbShpbmRleCwgcmVjdCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSAgPSBtZS5vd25lci5pdGVtc1ttZS5pbmRleE1hcFtpbmRleF1dLFxuICAgICAgICAgICAgc3R5bGUgPSBpdGVtLnN0eWxlO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHtcbiAgICAgICAgICAgIGxlZnQ6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICB0b3AgOiBgJHtyZWN0LnRvcH1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5zdHlsZSA9IHN0eWxlO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoU29ydFpvbmUpO1xuXG5leHBvcnQge1NvcnRab25lIGFzIGRlZmF1bHR9OyJdLCJzb3VyY2VSb290IjoiIn0=